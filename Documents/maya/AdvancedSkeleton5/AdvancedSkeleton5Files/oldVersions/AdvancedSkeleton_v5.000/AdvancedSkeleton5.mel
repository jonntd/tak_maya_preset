//     AdvancedSkeleton
//     Version 5.000
//
//
// AdvancedSkeleton is is a collection of Maya tools for doing character setup.
//
// INSTALLATION:
// drag`n`drop the "install.mel" file into Maya (drop in any viewport).
//
// For detailed instructions read the "install.txt" file
//
// Copyright (C)2015 Animation Studios
//
// email: support@animationstudios.com.au
// Last Modified 30/06/2015

global proc AdvancedSkeleton5 ()
{
global int $asBuilding;
global int $asRebuilding;
global int $asFaceIsResetting;
global string $gMainProgressBar;
global string $asDSAltPivot;
global int $asFitModeScriptJobNr4;
global int $asSkipConfirm;
asFitModeManualUpdate;
int $asDock=`optionVar -q asDock`;
if (!`optionVar -ex asDock`)
	$asDock=1;
$asBuilding=0;
$asRebuilding=0;
$asFitModeSkip=0;
$asSkipConfirm=0;
$asDSAltPivot="";
int $csm=0;//CorrectiveShapeMode
string $asScriptLocation=`asGetScriptLocation`;
string $labels[]={"Root","Chest","Mid","Hip","Foot","Heel","Toes","ToesEnd","BigToe","PinkyToe","LegAim","Shoulder","Hand","0","1","2","3"};
string $attributes[]={"twist/bendy","inbetween","global","aim","wheel","freeOrient","worldOrient","flipOrient","noMirror","noFlip","noControl","ikLocal","centerBtwFeet","geoAttach"};
string $geometry,$allFaceGeoString,$eyeL,$eyeR,$upperTeeth,$lowerTeeth,$tongue,$label,
	$eyeBrowL,$eyeBrowR,$eyeLashL,$eyeLashR,$headJoint,$skinCluster;
if (`attributeExists geometry FaceFitSkeleton`)
	$geometry=`getAttr FaceFitSkeleton.geometry`;
if (`attributeExists AllFaceGeo FaceFitSkeleton`)
	$allFaceGeoString=`getAttr FaceFitSkeleton.AllFaceGeo`;
if (`attributeExists Eye_L FaceFitSkeleton`)
	$eyeL=`getAttr FaceFitSkeleton.Eye_L`;
if (`attributeExists Eye_R FaceFitSkeleton`)
	$eyeR=`getAttr FaceFitSkeleton.Eye_R`;
if (`attributeExists UpperTeeth FaceFitSkeleton`)
	$upperTeeth=`getAttr FaceFitSkeleton.UpperTeeth`;
if (`attributeExists LowerTeeth FaceFitSkeleton`)
	$lowerTeeth=`getAttr FaceFitSkeleton.LowerTeeth`;
if (`attributeExists Tongue FaceFitSkeleton`)
	$tongue=`getAttr FaceFitSkeleton.Tongue`;
if (`attributeExists HeadJoint FaceFitSkeleton`)
	$headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
if (`attributeExists "SkinCluster" FaceFitSkeleton`)
	$skinCluster=`getAttr FaceFitSkeleton.SkinCluster`;

string $rootLevelObjects[]=`ls -as -type transform`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		$csm=1;
int $dsm=0;//DrivingSystemMode
$rootLevelObjects=`ls -as -type transform`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists sdkDriverValue $rootLevelObjects[$i]`)
		$dsm=1;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
if ($asFitModeScriptJobNr4!=0)
	if (!`scriptJob -ex $asFitModeScriptJobNr4`)
		$asFitModeScriptJobNr4=0;
if ($asFitModeScriptJobNr4==0)
	$asFitModeScriptJobNr4=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;

if (`dockControl -q -ex AdvancedSkeletonDockControl`)
	deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
window -t AdvancedSkeleton5 AdvancedSkeletonWindow;
formLayout asFormLayout;
scrollLayout asScrollLayout;
columnLayout -adj 1 asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pre" asPreFrameLayout;
		columnLayout -adj 0;
			text -fn "smallBoldLabelFont" -l "This \"Preparation\" section is optional,";
			text -fn "smallBoldLabelFont" -l "but recommended for clean file and workflow";
			separator -h 10;
			text -l "Clean :";
			text -l "Group your model, so that you have 1 top node.";
			text -l "And name this group \"geo\"";
			text -l "Then use the model-cleaner tool:";
			rowLayout -nc 4 -cw4 60 114 51 15;
				separator;
				button -w 72 -l "Model Clean" -c asModelCleaner;
				separator;
				button -w 11 -l "?" -c "asHelpImage asPreModelCleaner";
				setParent..;
			separator -h 10;
			text -l "Then save your cleaned model.";
			separator -h 5;
			separator -w 262;
			separator -h 5;
			if (`asIsMayaLT`)
				{
				separator -w 262 -h 10	;
				text -fn "smallBoldLabelFont" -l "Next is to reference model-file into rig-file.";
				text -fn "smallBoldLabelFont" -l "But MayaLT does not have referencing.";
				text -fn "smallBoldLabelFont" -l "So, just rig the model-file instead.";
				}
			else
				{
				text -l "Create rig file:";
				rowLayout -nc 4 -cw4 60 114 51 15;
					separator;
					button -w 72 -l "New Scene" -c NewScene;
					separator;
					button -w 11 -l "?" -c "asHelpImage asPreNewScene";
					setParent..;

				text -l "Reference-in the model:";
				rowLayout -nc 4 -cw4 60 114 51 15;
					separator;
					button -w 72 -l "Reference" -c asReferenceModelBrowser;
					separator;
					button -w 11 -l "?" -c "asHelpImage asPreReference";
					setParent..;
				}
		setParent..;
	setParent..;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Body" asBodyFrameLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asBodyFitFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 1;
				text -l "FitSkeletons:";
				setParent..;
			rowLayout -nc 4 -cw4 60 114 49 15;
				separator;
				columnLayout;
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asFitFiles;
						button -l "Import" -c asFitSkeletonImport;
						button -w 11 -l "?" -c "asHelpImage asFitSkeletons";
						setParent..;
					text -l " extra limbs:";
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asLimbFiles;
						button -l "Import" -c asFitSkeletonLimbsImport;
						button -w 11 -l "?" -c "asHelpImage asFitLimbs";
						setParent..;

					separator -h 5;
					rowLayout -nc 3 -cw3 114 49 15;
						separator;
						button -h 15 -l "Export" -c asFitSkeletonExport;
						button -h 15 -w 11 -l "?" -c "asHelpImage asFitExport";
						setParent..;

					setParent..;
				setParent..;

			separator;
			rowLayout -nc 1;
				text -l "Create:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
 				$gBuffStr = `toolButton -style iconOnly -doubleClickCommand "toolPropertyWindow" -cl toolCluster `;
    		$gBuffStr1 = `    jointCtx -image1 "kinJoint.png" -image2 "vacantCell.png" -image3 "vacantCell.png" -scaleCompensateJ 1
        -degreeOfFreedomJ "xyz" -jointOrientationJ 0 0 0 -scaleOrientationJ 0 0 0 -scaleJ 1 1 1 -autoJointOrient "xyz" 
        -secondaryAxisOrient "yup" -jointAutoLimits 0-createIKHandle 0-solverTypeH "ikSCsolver" -autoPriorityH 0
        -snapHandleH 1 -forceSolverH 1 -stickyH "off" -priorityH 1 -weightH 1 -poWeightH 1 -smallBoneLength 1
        -smallBoneRadius 0.5 -largeBoneLength 30 -largeBoneRadius 2 -variableBoneSize 1`;
		    toolButton -edit -tool $gBuffStr1 -toolImage1 $gBuffStr1 "kinJoint.png" $gBuffStr;
		    toolButton -edit -tool $gBuffStr1 $gBuffStr;
		    button -w 72 -l "ReSample" -c asFitResample;
				button -w 11 -l "?" -c "asHelpImage asFitCreate";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "IK-Label:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				optionMenu -cc asUpdateLabelHelp asLabelType;
				for ($label in $labels)
					menuItem -l $label;
				separator;
//				button -w 72 -c asLabelJoint -l "set label";
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn "smallBoldLabelFont" -en 0 asLabelHelp;
				button -w 11 -l "?" -c "asHelpImage asFitLabels";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointLabel;
				button -w 72 -l "Remove" -c asRemoveFitJointLabel;
				setParent..;
			separator -h 10;
			rowLayout -nc 1;
				text -l "Attribute:";
				setParent..;

			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
				optionMenu -cc asUpdateAttributeHelp asAttributeType;
				for ($attribute in $attributes)
					menuItem -l $attribute;
				setParent..;

			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn "smallBoldLabelFont" -en 0 asAttributeHelp;
				button -w 11 -l "?" -c "asHelpImage asFitAttributes";
				setParent..;

			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointAttribute;
				button -w 72 -l "Remove" -c asRemoveFitJointAttribute;
				setParent..;

			separator;
			rowLayout -nc 1;
				text -l "Display:";
				setParent..;
			floatSliderGrp -cw3 85 35 20 -l "joint" -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			rowLayout -nc 4 -cw4 62 78 85 15;
				separator;
				checkBox -l "geometry" -cc asFitGeometry asVisGeo;
				optionMenu -en 0 -cc asChangeVisGeoType asVisGeoType;
					menuItem -l "cylinders" -data 0;
					menuItem -l "boxes" -data 1;
					menuItem -l "spheres" -data 2;
					menuItem -l "bones" -data 3;
				button -w 11 -l "?" -c "asHelpImage asFitDisplay";
				setParent..;
			floatSliderGrp -cw3 85 35 20 -l "gap" -field 1 -min 0.01 -max 1 -pre 2 -v 0.75 asVisGap;
			rowLayout -nc 3 -cw3 62 78 60;
				separator;
				checkBox -l "joint-axis" -onc "asFitDisplayAxis 1" -ofc "asFitDisplayAxis 0";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Placement:";
				setParent..;
			rowLayout -nc 5 -cw5 62 29 40 92 15;
				separator -st none;
				if (`asHaveMeshCenterSnap`)
					{
					text -l "Snap:";
					iconTextCheckBox -w 26 -h 26 -i "snapMeshCenter.png" -cc "snapMode -meshCenter #1" -annotation (uiRes("m_statusLine.kSnapeMeshCenterAnnot")) asMeshCenterSnapButton;
					}
				else
					{
					separator -st none;
					separator -st none;
					}
				checkBox -l "Lock middle" -cc asFitModeLockCenterJoints asLockCenterJoints;
				button -w 11 -l "?" -c "asHelpImage asFitPlacement";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Auto-Orient:";
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator -st none;
				button -w 156 -l FitMode -c asFitMode;
				button -w 11 -l "?" -c "asHelpImage asFitMode";
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 82 62 81 15;
				separator -st none;
				text -l "Or, manual:";
				button -w 72 -l "Update Now" -c asFitModeManualUpdate;
				button -w 11 -l "?" -c "asHelpImage asFitUpdateNow";
				setParent..;
			separator;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asBodyBuildFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 2;
				separator -w 120 -st none;
				checkBox -l "ReBuild Connections" -v 1 asRebuildConnections;
				setParent..;
			rowLayout -nc 4;
				separator -w 15 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitAdvancedSkeleton asToggleFitSkeletonButton;
				separator -w 5 -st none;
				button -l "Build AdvancedSkeleton" -c asReBuildAdvancedSkeleton asBuildAdvancedSkeletonButton;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option1)" asBodyDeform1FrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 2 -cw2 229 15;
				text -l "Skinning:";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinning";
				setParent..;
//			separator -st none -h 5;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				columnLayout;
					text -l "Select objects to deform, then:";  
					separator -h 5 -st none;
					button -w 140 -l "+ Select DeformJoints" -c asSelectDeformJoints;
					separator -h 5 -st none;
					button -w 140 -l "Set Smooth Bind Options" -c asSetSmoothBindOptions;
					setParent..;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option2)" asBodyDeform2FrameLayout;
		columnLayout -adj 0;
			text -l "SkinCage:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinCage;
				button -w 60 -l "Delete" -c asDeleteSkinCage;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCage";
				setParent..;
			separator -st "none";
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 SkinCageCurvesSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 SkinCageCurvesSet";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageMirror";
				setParent..;
			separator -h 5 -st "none";
			setParent..;
		separator;
		columnLayout -adj 0;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select objects to deform, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Copy weights" -c asCopySkin;
					button -w 11 -l "?" -c "asHelpImage asDeformSkinCageCopyWeights";
					setParent..;
				setParent..;
			setParent..;
		separator;
		columnLayout -adj 0;
			text -l "advanced options:";
			separator -h 5 -st none;
			rowLayout -nc 2 -cw2 228 15;
				button -l " Move red SkinCurves to \"DeformationWidth\"" -c asSkinCurvesToWidth;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDWidth";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Sliders:";
				button -w 60 -l "Create" -c asCreateSliders;
				button -w 60 -l "Delete" -c asDeleteSliders;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageSliders";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Delete SkinCurves" -c asDeleteSkinCurves;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDeleteCurves";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option3)" asBodyDeform3FrameLayout;
		columnLayout -adj 0;
			text -l "SubWrap:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinSub;
				button -w 60 -l "Delete" -c asDeleteSkinSub;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapCage";
				setParent..;
			separator -h 5 -st none;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				text -l "Select objects to deform, then:";  
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Wrap selected mesh" -c asWrapSkin;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapWrap";
				setParent..;
			setParent..;
		separator;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Detach" -c asSkinSubDetach;
				button -w 60 -l "Attach" -c asSkinSubAttach;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapAttach";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Exclude selected vertices" -c asWrapExlude;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapExlude";
				setParent..;
			setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option4)" asBodyDeform4FrameLayout;
		columnLayout -adj 0;
			text -l "SkinLoops:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select EdgeLoop + FK control, then";
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				separator;
				checkBox -v 1 -l "mirror" asCreateSkinLoopCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Create New SkinLoop" -c "asCreateSkinLoop 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCreate";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Select All SkinLoops" -c asSelectAllSkinLoops;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsSelectAll";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to deform, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Bind" -c "asBindSkinLoops 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsBind";
				setParent..;
			separator -w 242 -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "CutUp:";
				button -w 60 -l "Create" -c "asBindSkinLoops 1";
				button -w 60 -l "Delete" -c asDeleteCutUp;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCutUp";
				setParent..;
			separator -w 242 -h 5;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Skeleton)" asBodyGeometrySkeletonFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateSkeleton;
				button -w 60 -l "Delete" -c asDeleteSkeleton;
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Skeleton 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Skeleton 0";
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonMirror";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (PolyBoxes)" asBodyGeometryPolyBoxesFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreatePolyBoxes;
				button -w 60 -l "Delete" -c asDeletePolyBoxes;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Boxes 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Boxes 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Boolean:";
				button -w 60 -l "Create" -c asCreateBoolean;
				button -w 60 -l "Delete" -c asDeleteBoolean;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesBoolean";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Warp:";
				button -w 60 -l "Create" -c asCreateWarp;
				button -w 60 -l "Delete" -c asDeleteWarp;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesWarp";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Mannequin)" asBodyGeometryMannequinFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateMannequin;
				button -w 60 -l "Delete" -c asDeleteMannequin;
				button -w 11 -l "?" -c "asHelpImage asGeometryMannequinCreate";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Curves" asBodyControlCurvesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 ControlSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 ControlSet";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Scale:";
				floatField -v 1 -ann "set scale-factor" ScaleCCFloatField;
				button -w 60 -l "Scale" -c "asScaleControlCurves";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesScale";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Swap:";
				text -l "First select Control(s) to replace,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then select (add) any custom curve,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Swap Curve" -c asSwapCurve;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesSwap";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Motion Capture" asBodyMotionCaptureFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Skeleton:";
				button -w 60 -l "Create" -c asCreateMoCap;
				button -w 60 -l "Delete" -c asDeleteMocap;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "FK/IK:";
				button -w 60 -l "Set All FK" -c asSetAllFK;
				button -w 60 -l "Default" -c "asGoToBuildPose bodySetup";
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureAllFK";
				setParent..;
			rowLayout -nc 5 -cw5 60 60 38 64 15;
				text -l "Bvh file:";
				button -w 60 -l "Read" -c asReadBVH;
				floatField -w 38 -v 120 -pre 1 -ann "set frames per second (in bvh file)" asBVHfps;
				button -w 60 -l "Delete" -c asDeleteBHV;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureReadBvh";
				setParent..;
			separator;
			rowLayout -nc 4 -cw4 60 60 38 100;
				separator -st none;
				columnLayout;
					text -l "Then constrain the Bvh skeleton,";
					text -l "to the MoCap skeleton.";
					separator -h 5 -st none;
					text -l "Or try auto-connect";
					setParent..;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Connect" -c asAutoMapMocap;
				button -w 60 -l "Disconnect" -c asDeleteMocapMap;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureConnect";
				setParent..;
			setParent..;
		setParent..;

	setParent..;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Face" asFaceFrameLayout;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Pre" asFacePrepFrameLayout;
		columnLayout -adj 0;
			button -l "Create Face FitSkeleton Node" -c asCreateFaceFitSkeleton;
			rowLayout -nc 2 -cw2 228 15;
				text -l "Then move and scale this,";
				button -w 11 -l "?" -c "asHelpImage faceFitSkeletonNode";
				setParent..;
			text -l "lower circle just under the character`s jaw";
			text -l "upper circle just above the character`s head";
			separator -h 10;

			text -l "Choose Geometry";
			text -l " * = Optional";
			rowLayout -nc 2;
				button -w 120 -l "Face" -c "asChooseInput asFaceGeometryTextField";
				textField -w 100 -ed 0 -tx $geometry asFaceGeometryTextField;
				setParent..;
			rowLayout -nc 2;
				button -w 120 -l "All Head" -c "asChooseInput asFaceAllFaceGeoTextField";
				textField -w 100 -ed 0 -tx $allFaceGeoString asFaceAllFaceGeoTextField;
				setParent..;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Left Eye" -c "asChooseInput asFaceEye_LTextField";
				textField -w 100 -ed 0 -tx $eyeL asFaceEye_LTextField;
				setParent..;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Right Eye" -c "asChooseInput asFaceEye_RTextField";
				textField -w 100 -ed 0 -tx $eyeR asFaceEye_RTextField;
				setParent..;
			separator -h 7;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Upper Teeth" -c "asChooseInput asFaceUpperTeethTextField";
				textField -w 100 -ed 0 -tx $upperTeeth asFaceUpperTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Lower Teeth" -c "asChooseInput asFaceLowerTeethTextField";
				textField -w 100 -ed 0 -tx $lowerTeeth asFaceLowerTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw 1 120;
				button -w 120 -l "Tongue" -c "asChooseInput asFaceTongueTextField";
				textField -w 100 -ed 0 -tx $tongue asFaceTongueTextField;
				text -l "*";
				setParent..;
			separator -h 10;
			checkBox -m 1 -l advanced -onc "columnLayout -e -m 1 asFaceAdvancedinputColumnLayout" -ofc "columnLayout -e -m 0 asFaceAdvancedinputColumnLayout";
			columnLayout -m 0 asFaceAdvancedinputColumnLayout;
				separator -h 15;
				text -l "This section is for using FaceSetup with\nrigs not generated with AdvancedSkeleton.";
				separator -h 5;
				rowLayout -nc 2 -cw 1 120;
					button -w 120 -l "Choose Head Joint" -c "asChooseInput asFaceHeadJointTextField";
				textField -w 100 -ed 0 -tx $headJoint asFaceHeadJointTextField;
					setParent..;
				text -l "SkinCluster found on Face Geo:";
				textField -w 150 -m 1 -tx $skinCluster asFaceSkinClusterTextField;
				setParent..;
//			checkBox -m 1 -l "symmetry test" -onc "columnLayout -e -m 1 asFaceTestinputColumnLayout" -ofc "columnLayout -e -m 0 asFaceTestinputColumnLayout";
			columnLayout -m 0 asFaceTestinputColumnLayout;
				separator -h 15;
				text -l "FaceSetup required symmetrical geometry.";
				text -l "This section lets you test the symmetry.";
				button -l "Duplicate Face Geometry" -c asFaceCreateTestDuplicate;
				separator -h 10;
				text -l "The duplicate should match 100%\n with the slider at both ends";
				floatSlider -w 120 -min -1 -max 1 -value -1 -step 0.01 asFaceDuplicateSlider;
				separator -h 10;
				button -l "Delete Test Geometry" -c "delete FaceSymmetryTestGroup";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asFaceFitFrameLayout;
		columnLayout -adj 0;
		$checkValue=`objExists FaceFitEyeBall`;
		rowLayout -nc 4;
			button -w 100 -l EyeBall -c asBuildFitEyeBall;
			separator -w 5 -st none;
			checkBox -l "" -w 119 -ed $checkValue -v $checkValue -ofc "asFaceDeleteFromCheckBox EyeBall" asFaceEyeBall;
			button -w 11 -l "?" -c ("asHelpImage fitFaceEyeBall");
			setParent..;
		separator -h 18 -w 242;

		text -l "For the next steps:";
		text -l "Place the locators in 2D (Front View)";
		text -l "then \"project\"";
		text -l "Note: Some locators have \"fineCtrl\" attribute";
		text -l "which will display more locators.";
		text -l "*Optional:";
		text -l "  First select edge(loops) for automatic placement";
		separator -st none -h 10;

		string $sections[]={"EyeLid","EyeBrow","Lip","noseCorner","cheek","Jaw","Nose","Tongue"};
		string $parts[]={"Main","Outer"};
		int $upAndLo[]={1,0,1,0,0,0,0,0};
		int $mainAndOuter[]={1,1,0,0,0,1,0,0};
		float $radiuss[]={0.4,1.0,2.0,1.0,1.0,1.0,2.0,1.0};
		int $isSphere[]={0,0,0,1,1,0,0,0};
		int $place2D[]={1,1,1,1,1,0,0,0};
		for ($c=0;$c<size($sections);$c++)
			{
			for ($a=0;$a<size($parts);$a++)
				{
				if ($mainAndOuter[$c]==0) $parts[$a]="";
				else $parts={"Main","Outer"};
				if ($mainAndOuter[$c]==0 && $a>0)
					continue;

				if ($c==5 && $a==0)
					{
					text -l "For the next steps:";
					text -l "Place the locators in 3D";
					}

				$checkValue=`objExists ("FaceFit"+$sections[$c]+$parts[$a])`;
				rowLayout -nc 6;
					button -w 100 -l ($sections[$c]+$parts[$a]) -c ("asCreateFaceFit "+$sections[$c]+" \""+$parts[$a]+"\" "+$upAndLo[$c]+" "+$mainAndOuter[$c]+" "+$radiuss[$c]+" "+$isSphere[$c]);
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$sections[$c]+$parts[$a]) ("asFace"+$sections[$c]+$parts[$a]);
					button -w 15 -l "?" -c ("asHelpImage fitFace"+$sections[$c]+$parts[$a]);
					separator -w 10 -st none;
					if ($place2D[$c])
						button -w 80 -l "project" -c ("asFaceFitProject "+$sections[$c]+" \""+$parts[$a]+"\" "+$upAndLo[$c]);
					if ($sections[$c]=="Tongue")
						text -l "*Optional";
					setParent..;
				}
			}
		separator -h 18 -w 242;

			rowLayout -nc 2;
				separator -w 15 -st none;
				columnLayout;
					rowLayout -nc 2;
						text -l "EyeBrows:";
						optionMenu asFaceEyeBrowsStyleOptionMenu;
							menuItem -l "realistic (sliding)";
							menuItem -l "cartoony(free)";
						setParent..;
					rowLayout -nc 2 -cw2 209 15;
						button -w 160 -l "Animate Fit" -c asAnimateFaceFit;
//						button -w 11 -l "?" -c "asHelpImage asNotYet";
						setParent..;
					rowLayout -nc 3 -cw3 20 187 15;
						separator -st none;
						text -l "Tweak locator animation";
						button -w 11 -l "?" -c "asHelpImage fitFaceAnimate";
						setParent..;
					setParent..;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asFaceBuildFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 2 asFaceRebuildKeepBSRowLayout;
				separator -w 120 -st none;
				checkBox -l "Keep BlendShapes" -v 1 asFaceKeepBlendShapes;
				setParent..;
			rowLayout -nc 4;
				separator -w 15 -st none;
				button -w 60 -l FitMode -c asToggleFitModeFace asToggleFitFaceButton;
				separator -w 20 -st none;
				button -w 140 -l "Build AdvancedFace" -c "$stepBuild=0;asBuildAdvancedFace" asBuildAdvancedFaceButton;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build ..." asFaceStepBuildFrameLayout;
		columnLayout -adj 0;
			text -l "Step Build:";
			text -fn "smallBoldLabelFont" -l "Only use this section if normal Build had errors,";
			text -fn "smallBoldLabelFont" -l "or to only build some of the face-features.";
			separator -h 5;
			for ($i=1;$i<19;$i++)
				{
				rowLayout -nc 2 -cw2 159 80;
					text -l ($i+":") ("stepBuild"+$i+"Text");
					button -w 80 -h 15 -l "Build" -c ("$stepBuild="+$i+";asBuildAdvancedFace;");
					setParent..;
				if ($i==5)
					{
					rowLayout -nc 2 -cw2 180 80;
						text -l "Now should have selection like this:";
						button -w 40 -h 12 -l "image" -c "asHelpImage asStepBuildEyeLid";
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
						text -l "If not, make correct selection, then:";
						button -w 40 -h 12 -l "update" -c "sets -clear eyeLidVtxs;sets -add eyeLidVtxs `ls -sl`;print \"// Updated\\n\"";
						setParent..;
					}
				if ($i==6)
					{
					rowLayout -nc 2 -cw2 180 80;
						text -l "Now should have curves like this:";
						button -w 40 -h 12 -l "image" -c "asHelpImage asStepBuildEyeBrowCurves";
						setParent..;
					}
				if ($i==7)
					{
					rowLayout -nc 2 -cw2 180 80;
						text -l "Now should have object like this:";
						button -w 40 -h 12 -l "image" -c "asHelpImage asStepBuildEyeBrowObject";
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
						text -l "If not, adjust the curves, and try cutout again:";
						setParent..;
					}
				if ($i==8)
					{
					rowLayout -nc 2 -cw2 180 80;
						text -l "You can now test the NCloth:";
						setParent..;
					}
				if ($i==11)
					{
					rowLayout -nc 2 -cw2 180 80;
						text -l "Now should have curves like this:";
						button -w 40 -h 12 -l "image" -c "asHelpImage asStepBuildJawCurves";
						setParent..;
					}
				if ($i==12)
					{
					rowLayout -nc 2 -cw2 180 80;
						text -l "Now should have selection like this:";
						button -w 40 -h 12 -l "image" -c "asHelpImage asStepBuildJawArea";
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
						text -l "If not, adjust the curves, and run step 11 again";
						setParent..;
					}
				if ($i==13)
					{
					rowLayout -nc 2 -cw2 180 80;
						text -l "Now should have object like this:";
						button -w 40 -h 12 -l "image" -c "asHelpImage asStepBuildJawObject";
						setParent..;
					}
				if ($i==14)
					{
					text -l "Lip vertices should now be selected";
					text -l "You can now test the NCloth:";
					}
				separator -w 240;
				}
			text -e -l "1: Unlock All SkinInfluences" stepBuild1Text;
			text -e -l "2: Check for re-build info" stepBuild2Text;
			text -e -l "3: Setup ctrlBox" stepBuild3Text;
			text -e -l "4: Setup EyeBall" stepBuild4Text;
			text -e -l "5: Setup EyeLid" stepBuild5Text;
			text -e -l "6: Detect EyeBrow" stepBuild6Text;
			text -e -l "7: Cutout EyeBrow" stepBuild7Text;
			text -e -l "8: NCloth Prep" stepBuild8Text;
			text -e -l "9: NCloth Sim" stepBuild9Text;
			text -e -l "10: Setup Jaw" stepBuild10Text;
			text -e -l "11: Detect Jaw" stepBuild11Text;
			text -e -l "12: Detect JawArea" stepBuild12Text;
			text -e -l "13: Cutout Jaw" stepBuild13Text;
			text -e -l "14: Detect Lip" stepBuild14Text;
			text -e -l "15: NCloth Sim" stepBuild15Text;
			text -e -l "16: Skin Tongue" stepBuild16Text;
			text -e -l "17: Squint Setup" stepBuild17Text;
			text -e -l "18: The Rest" stepBuild18Text;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeBrows" asFaceBrowsFrameLayout;
		columnLayout -adj 0;
			separator -st "none" -h 10;
			rowLayout -nc 2;
				separator -st none -w 15;
				text -l "Select EyeBrows, then:";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "WrapDeform to face" -c "asFaceWrapDeformToFace";
//				button -w 11 -l "?" -c "asHelpImage asNotYet";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeLashes" asFaceLashesFrameLayout;
		columnLayout -adj 0;
			separator -st "none" -h 10;
			rowLayout -nc 2;
				separator -st none -w 15;
				text -l "Select EyeLashes, then:";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "SkinBind" -c "asFaceSkinEyeLashes";
//				button -w 11 -l "?" -c "asHelpImage asNotYet";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " HeadSquash" asFaceSquashFrameLayout;
		columnLayout -adj 0;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Create HeadSquash" -c "asAdvancedSquash";
//				button -w 11 -l "?" -c "asHelpImage asNotYet";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Optimize HeadSquash" -c "asOptimizeSquash";
//				button -w 11 -l "?" -c "asHelpImage asNotYet";
				setParent..;
			text -fn "smallBoldLabelFont" -l "To make sure only head";
			text -fn "smallBoldLabelFont" -l "and no other parts of body gets squashed";
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Rubber-Face" asFaceRubberFaceFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 3 -cw3 15 211 15;
				text -w 15 -l "1:";
				button -w 150 -l "Create Placement Locator" -c "asFaceCreatePlacementLocator 0 \"\"";
//				button -w 11 -l "?" -c "asHelpImage asNotYet";
				setParent..;
			rowLayout -nc 2;
				text -w 15 -l "2:";
				text -l "Place the locator";
				setParent..;
			rowLayout -nc 2;
				text -w 15 -l "3:";
				button -w 150 -l "Create Rubber Control" -c asFaceCreateRubberControl;
				setParent..;
			rowLayout -nc 3;
				text -w 15 -l "4:";
				text -w 211 -l "Test control and \"Falloff-Radius\" attribute";
//				button -w 11 -l "?" -c "asHelpImage asNotYet";
				setParent..;
			rowLayout -nc 2;
				text -w 15 -l "5:";
				button -w 150 -l "Save \"Falloff-Radius\" value" -c asFaceSaveRubberFalloff;
				setParent..;
			separator -h 5;
			rowLayout -nc 2;
				separator -st none -w 15;
				button -w 150 -l "Mirror Rubber Control" -c asFaceMirrorRubberControl;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EditBlendShapes" asFaceEditBlendShapesFrameLayout;
		columnLayout -adj 0;
			text -l "Set controls to the shape for adjustment, then:";
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "create blendShape target" -c "asBSAdjustTarget";
				separator -st none;
				button -h 18 -w 40 -l "reset" -c "asBSResetTarget";
				button -w 11 -l "?" -c "asHelpImage asEditBlendShapesCreate";
				setParent..;
			rowLayout -nc 2;
				separator -w 15 -st none;
				floatSlider -en 0 -w 130 -min 0 -max 1 -value 0 -step 0.1 asFaceBSFloatSlider;
				setParent..;
			rowLayout -nc 3 -cw3 15 162 18;
				separator -st none;
				text -l "Delete the targets when finished:";
				button -h 18 -w 40 -l delete -c "delete deleteThis";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				columnLayout -adj 0;
					text -l "Or step through ALL the BlendShape targets,";
					text -l "with the blendShapes wizard:";
					setParent..;
				setParent..;
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "start blendShapes wizard" -c "asBSWizard";
				separator -st none;
				button -en 0 -w 40 -l "next.." -c "asBSWizardNext" asBSWizardNextButton;
				button -w 11 -en 0 -l "?" -c "asHelpImage asBSWizardStep0" asBSWizardHelpButton;
				setParent..;
			rowLayout -nc 4 -cw4 15 30 140 50;
				separator -st none;
				text -en 0 -w 30 -l "0/37" asBSWizardStepText;
				text -en 0 -w 140 -l "..." asBSWizardObjAttrText;
				text -en 0 -w 50 -l "..." asBSWizardValueText;
				setParent..;
			rowLayout -nc 2 -cw2 15 200;
				separator -st none;
				button -w 150 -l "stop blendShapes wizard" -c "asBSWizardStop";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				text -l "Or extract All targets:";
				setParent..;
			rowLayout -nc 3 -cw3 15 211 15;
				separator;
				button -w 150 -l "extract All targets" -c "asBSExtractAll";
				button -w 11 -l "?" -c "asHelpImage asEditBlendShapesExtractAll";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " TweakControllers" asFaceTweakControlsFrameLayout;
		columnLayout -adj 1;
			rowLayout;
				text -l "Create:";
				setParent..;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					iconTextButton -w 35 -h 35 -i "softMod.png" -c SoftModTool;
					text -l "Create a softmod, then:";
					rowLayout -nc 2 -cw2 40 100;
						separator;
						checkBox -l "Middle Controller" asFaceIsMiddleControlCheckBox;
						setParent..;
//					separator -h 5;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Create Control from selected SoftMod" -c "asFaceConvertSoftModToControl 0";
						button -w 11 -l "?" -c "asHelpImage asTweakControllersCreate";
						setParent..;
					setParent..;
				setParent..;
			separator;
			rowLayout;
				text -l "Edit:";
				setParent..;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Paint weights for selected Control" -c asFacePaintControllerWeights;
						button -w 11 -l "?" -c "asHelpImage asTweakControllersPaint";
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Convert selected Control to SoftMod" -c asFaceConvertControlToSoftMod;
						button -w 11 -l "?" -c "asHelpImage asTweakControllersConvertToSoftMod";
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Convert SoftMod Back to Control" -c "asFaceConvertSoftModToControl 1";
						button -w 11 -l "?" -c "asHelpImage asTweakControllersConvertBackToControl";
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Mirror weights for selected Control" -c asFaceMirrorControllerWeights;
						button -w 11 -l "?" -c "asHelpImage asTweakControllersMirrorWeights";
						setParent..;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
		setParent..;
	setParent..;

frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pose" asPoseFrameLayout;;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Driving Systems" asBodyDrivingSystemsFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				columnLayout -adj 0;
					text -l "First make the pose to be driven";
					text -l "(e.g. folded wings, hand guesture..)";
					text -l "Then:";
					setParent..;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l"Create Driving System" -c asCreateDrivingSystem;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsCreate";
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Right Click on any of these buttons,\nto access existing Driving Systems.";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15;
				separator;
				button -w 50 -en (!$dsm) -l "Edit" -c asAutoFindAndEditDrivingSystem asEditDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Edit" asEditDrivingSystemsPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Delete" asDeleteDrivingSystemsPopupMenu;
				button -w 50 -en (!$dsm) -l "Graph" asGraphDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Graph" asGraphDrivingSystemsPopupMenu;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsEdit";
				setParent..;
			separator -st "none" -h 20;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "After editing pose, then:";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15 asDSEditChoicesRowLayout;
				separator;
				button -w 50 -l "Apply" -c asDrivingSystemEditApply;
				checkBox -v 1 -l "mirror" asDrivingSystemMirrorCheckBox;
				button -w 50 -l "Cancel" -c asDrivingSystemEditCancel;
//				button -w 11 -l "?" -c "asHelpImage asNotYet";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes" asBodyCorrectiveFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				columnLayout -adj 0;
					text -l "Go to pose to correct, then:";
					text -l "Select mesh to correct, then:";
					setParent..;
				setParent..;
			rowLayout -nc 2 -cw2 80 100;
				separator;
				checkBox -v 1 -l "Angle Rotations" asCorrectiveAngleCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -en (!$csm) -l "Create Corrective Shape" -c asCreateCorrectiveShape asCreateCorrectiveButton;
				button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesCreate";
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Right Click on any of these buttons,\nto access existing Corrective Shapes.";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15;
				separator;
				button -w 50 -en (!$csm) -l "Edit" asEditCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Edit" asEditCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Delete" asDeleteCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Graph" asGraphCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Graph" asGraphCorrectiveShapesPopupMenu;
				button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesEdit";
				setParent..;
			separator -st "none" -h 20;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "After sculpted shape, then:";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15 asCorrectiveEditChoicesRowLayout;
				separator;
				button -l "Apply" -c asConnectCorrectiveShape;
				checkBox -v 1 -l "mirror" asCorrectiveMirrorCheckBox;
				button -l "Cancel" -c asCancelCorrectiveShape;
//				button -w 11 -l "?" -c "asHelpImage asNotYet";
				setParent..;
			checkBox -l advanced -onc "columnLayout -e -m 1 asCorrectiveAdvancedColumnLayout" -ofc "columnLayout -e -m 0 asCorrectiveAdvancedColumnLayout";
			columnLayout -m 0 asCorrectiveAdvancedColumnLayout;
				separator -h 15 -st none;
				rowLayout -nc 2 -cw2 227 100;
					text -l "Bake Deformations to Corrective Shapes:";
					button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesBake";
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "Source" -c "textField -e -tx `ls -sl` asBakeToCorrective1TextField";
					textField -w 100 -ed 0 asBakeToCorrective1TextField;
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "Destination" -c "textField -e -tx `ls -sl` asBakeToCorrective2TextField";
					textField -w 100 -ed 0 asBakeToCorrective2TextField;
					setParent..;
				text -l "rotations:";
				rowLayout -nc 6;
					checkBox -l "+x" -v 1 asBakeX1CheckBox;
					checkBox -l "+y" -v 1 asBakeY1CheckBox;
					checkBox -l "+z" -v 1 asBakeZ1CheckBox;
					checkBox -l "-x" -v 1 asBakeX2CheckBox;
					checkBox -l "-y" -v 1 asBakeY2CheckBox;
					checkBox -l "-z" -v 1 asBakeZ2CheckBox;
					setParent..;
				text -l "Select FK controller, then:";
				button -w 120 -l "Bake" -c asBakeIntoCorrectiveShapes;
				setParent..;
			setParent..;
		setParent..;

	setParent..;

frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Tools" asToolsFrameLayout;
	columnLayout;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "SelectorDesigner" -c asSelectorDesigner;
			button -w 11 -l "?" -c "asHelpImage asSelectorDesigner";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "PoserDesigner" -c asPoserDesigner;
			button -w 11 -l "?" -c "asHelpImage asPoserDesigner";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "WalkDesigner" -c asWalkDesigner;
			button -w 11 -l "?" -c "asHelpImage asWalkDesigner";
			setParent..;
		setParent..;

	setParent..;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Display" asDisplayFrameLayout;
	columnLayout;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "MotionSystem:";
			button -w 60 -l "Hide" -c "setAttr MotionSystem.v 0";
			button -w 60 -l "Show" -c "setAttr MotionSystem.v 1";
			setParent..;

		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joints:";
			button -w 60 -l "Hide" -c "asJointsVisibility 0";
			button -w 60 -l "Show" -c "asJointsVisibility 1";
			setParent..;

		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joint axis:";
			button -w 60 -l "Hide" -c "asDisplayRigRLA 0";
			button -w 60 -l "Show" -c "asDisplayRigRLA 1";
			setParent..;

		rowLayout -nc 2 -cw2 73 100;
			text "Joint Size:";
			floatSliderGrp -cw2 35 130 -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			setParent..;

		rowLayout -nc 3 -cw3 73 100 100;
			separator;
			button -w 150 -l "Select jointLayer" -c "select jointLayer;AttributeEditor";
			setParent..;

		setParent..;
	setParent..;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Optimize" asOptimizeFrameLayout;
	columnLayout -adj 0;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused Nodes" -c "hyperShadePanelMenuCommand(\"\", \"deleteUnusedNodes\")";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Remove Unused Influences" -c asRemoveAllUnusedInfluences;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Prune Clusters" -c asPrunAllClusters;
			setParent..;
		setParent..;
	setParent..;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Publish" asPublishFrameLayout;
	columnLayout -adj 0;
		rowLayout -nc 3 -cw3 73 165 15;
			separator -st none;
			button -w 140 -l "Publish" -c asPublish;
			button -w 11 -l "?" -c "asHelpImage asPublish";
			setParent..;
		setParent..;
	setParent..;


frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "About" asAboutFrameLayout;
	columnLayout -adj 1;
		image -i ($asScriptLocation+"/AdvancedSkeleton5Files/icons/asLogo.png") asHelpImage;
		if (`asIsMayaLT`)
			text -l "\nNote:\nRunning Maya LT,\n so not all AdvancedSkeleton features enabled.\n";
		button -l "visit AdvancedSkeleton website" -c "showHelp -a \"http://www.animationstudios.com.au/advancedskeleton\"";
		separator -h 15;
		rowLayout -nc 3 -cw3 60 50 100;
			text -l " Window:";
			button -c "asDockWindow 1" -l " Dock ";
			button -c "asDockWindow 0" -l " UnDock ";
			setParent..;
	separator -h 15;
	columnLayout -adj 0;
		button -l "Open Help Files" -c "showHelp -a \"http://www.animationstudios.com.au/advancedskeleton/help\"";
		setParent..;
	separator -h 15;
		rowLayout -nc 5 -cw5 110 30 40 54 15;
			button -l "Check For Updates" -c asCheckForUpdates;
			text -l "found:";
			text -m 1 -l "x.xxx" asUpdateFoundVersion;
			button -en 0 -l "Update" -c asUpdateVersion asUpdateVersionButton;
			button -w 11 -l "?" -c "asHelpImage asAboutUpdate";
		setParent..;
	checkBox -m 0 -v 0 asBetaCheckBox;
	separator -h 15;
		rowLayout -nc 3 -cw3 80 158 15;
			text -l "current version:";
			button -l `asGetScriptVersionAsString` -c "print \"// right click on button to change version\"";
				popupMenu asVersionsPopupMenu;
			button -w 11 -l "?" -c "asHelpImage asAboutCurrentVersion";
			setParent..;
		setParent..;
	separator -h 5;
	columnLayout -adj 0;
		text -l "For support, go to:\nwww.facebook.com/AdvancedSkeleton\nOr email: support@animationstudios.com.au\n\nFor license information, read the eula.txt file.";
		setParent..;
	setParent..;
setParent..;
rowLayout -nc 2 -cw2 120 100 asRowLayout;
columnLayout;
	rowLayout -nc 5;
		text -l "body:" asBodyText;
		button -c "asGoToBuildPose bodySetup" -l "Go to Build Pose";
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose bodySetup";
		separator -w 10 -st none;
		text -l "face:" asFaceText;
		button -c "asGoToBuildPose faceSetup" -l "Go to Build Pose" asGoToBuildPoseFaceButton;
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose faceSetup";
		setParent..;
	setParent..;

formLayout -e
	-af asScrollLayout "right" 0
	-af asScrollLayout "left" 0
	-af asScrollLayout "top" 0
	-ac asScrollLayout "bottom" 0 asRowLayout
	-af asRowLayout "bottom" 0
	asFormLayout;

if($asDock)
	{
	dockControl -l AdvancedSkeleton -w 296 -fl 0 -floatChangeCommand asDockWindowChangeFloatingState -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
	evalDeferred "dockControl -e -r AdvancedSkeletonDockControl;";
	}
else
	showWindow;
asUpdateLabelHelp;
asUpdateAttributeHelp;
asFitSkeletonConnectControl;
asUpdateButtonEnables;
if (`window -q -ex AdvancedSkeletonWindow`)
	{
	window -e -w 296 AdvancedSkeletonWindow;
	if (!`windowPref -q -ex AdvancedSkeletonWindow`)
		window -e -h 500 AdvancedSkeletonWindow;
	}

if ($asFaceIsResetting)
	$asFaceIsResetting=0;
else
	asFaceUpdateInfo 1;

//update UI from optionVars
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
    if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
        if (`optionVar -ex $framLayouts[$i]`)
            frameLayout -e -cl `optionVar -q $framLayouts[$i]` $framLayouts[$i];

//populate fitSkeletonFiles optionMenu
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletons/";
string $fitSkeletonFiles[]=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asFitFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}

$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
$fitSkeletonFiles=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asLimbFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}

//Exist EditDrivingSystemMode (if stuck)
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;

//Set 0.2 jointDisplayScale if first run of AdvancedSkeleton
if (!`optionVar -ex asBodyFrameLayout`)
	jointDisplayScale 0.2;

//populate asVersionsPopupMenu
string $oldVersionsDir=$asScriptLocation+"/AdvancedSkeleton5Files/oldVersions/";
int $latestLocal;
setParent -menu asVersionsPopupMenu;
string $oldVersions[];
if (`file -q -ex $oldVersionsDir`)
	$oldVersions=`getFileList -fld $oldVersionsDir`;
$oldVersions=`sort $oldVersions`;
for ($i=size($oldVersions);$i>-1;$i--)
	{
	if ($i==size($oldVersions))
		{
		$label=`asGetLatestLocalVersionAsString`;
		$latestLocal=1;
		}
	else
		{
		$label=$oldVersions[$i];
		$latestLocal=0;
		}
	$label=`substitute "AdvancedSkeleton_v" $label ""`;
	menuItem -l $label -c ("asSourceVersion \""+$label+"\" "+$latestLocal);
	}
//Maya LT limitations
if (`asIsMayaLT`)
	{
	frameLayout -e -en 0 asBodyDeform2FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDeform3FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDrivingSystemsFrameLayout;//no sdk
	frameLayout -e -en 0 asFaceFrameLayout;//no nCloth
	}
progressBar -e -ep $gMainProgressBar;
}

global proc asScriptLocatorProc (){}

global proc string asGetScriptLocation ()
{
string $whatIs=`whatIs asScriptLocatorProc`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder-1)`;
return $scriptLocation;
}

global proc float asGetScriptVersion ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton5.mel";
float $version=`asGetScriptVersionFromFile $file`;
return $version;
}

global proc string asGetScriptVersionAsString ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton5.mel";
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
return $versionAsString;
}

global proc float asGetScriptVersionFromFile (string $file)
{
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
float $version=$versionAsString;
return $version;
}

global proc string asGetScriptVersionFromFileAsString (string $file)
{
string $versionString;
string $tempString[];
int $lineNr;
if (`file -q -ex $file`)
	{
	int $fileId=`fopen $file "r"`;
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$lineNr++;
		$nextLine = `fgetline $fileId`;
		if (`gmatch $nextLine "*Version*"`)
			{
			tokenize $nextLine $tempString;
			tokenize $tempString[2] "[.]" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				$versionString+=$tempString[$i];
				if ($i==0)
					$versionString+=".";
				}
//			$version=$versionString;
			}
		if($lineNr>10)
			break;
		}
	fclose $fileId;
	}
else
	warning "Unable to determine AdvancedSkeleton version number";
return $versionString;
}

global proc asSourceVersion (string $versionAsString, int $latestLocal)
{
global string $gShelfTopLevel;
int $sucess;
string $buttons[];

string $asFile,$iol,$image;
string $latestLocalScriptLocation=`asGetLatestLocalScriptLocation`;
if ($latestLocal)
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton5.mel";
else
	{
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton5Files/oldVersions/AdvancedSkeleton_v"+$versionAsString+"/AdvancedSkeleton5.mel";
	$iol=$versionAsString;
	if (!`file -q -ex $asFile`)
		{
		warning ("attempted to source version: "+$versionAsString+", but could not find file:\""+$asFile+"\", so using latest installed version instead");
		optionVar -iv asUseVersionLatestLocal 1;
		return;
		}
	}

string $cmd="source \""+$asFile+"\";AdvancedSkeleton5;";
string $shelves[]=`tabLayout -q -ca $gShelfTopLevel`;
for ($i=0;$i<size($shelves);$i++)
	{
	$buttons=`layout -q -ca $shelves[$i]`;
	for ($y=0;$y<size($buttons);$y++)
		{
		string $ann=`shelfButton -q -ann $buttons[$y]`;
		if ($ann=="AdvancedSkeleton5")
			{
			$image=`shelfButton -q -i $buttons[$y]`;
			if ($iol=="")
				$image=`substitute "AS4version" $image "AS4"`;
			else
				$image=`substitute "AS4" $image "AS4version"`;
			shelfButton -e -c $cmd -iol $iol -i $image -i1 $image $buttons[$y];
			$sucess=1;
			}
		}
	}
if ($sucess)
	{
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		evalDeferred -lp ("deleteUI -control AdvancedSkeletonDockControl");
	else if (`window -q -ex AdvancedSkeletonWindow`)
	    evalDeferred -lp ("deleteUI AdvancedSkeletonWindow");
	print ("// Shelf button updated, Click on the button to launch choosen version of AdvancedSkeleton\n");
	}
}

global proc int asIsMayaLT ()
{
int $isMayaLT=0;
if (!`exists CreateWrap`)
	$isMayaLT=1;
return $isMayaLT;
}

global proc int asHaveMeshCenterSnap ()
{
int $haveSnap;
string $helpString=`help snapMode`;
string $tempString[];
tokenize $helpString $tempString;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]=="-meshCenter")
		$haveSnap=1;
return $haveSnap;
}

global proc asUpdateLabelHelp ()
{
string $type=`optionMenu -q -v asLabelType`;
string $help="";
if ($type=="Hand" || $type=="Shoulder")
	$help="Hand + Shoulder = Arm IK";
if ($type=="Hip" || $type=="Foot")
	$help="Hip + Foot = Leg IK";
if ($type=="LegAim")
	$help="LegAim + Hip + Foot = 3 bone Leg IK";
if ($type=="Heel" || $type=="Toes" || $type=="ToesEnd")
	$help="Ball + Heel + Toe = FootRoll";
if ($type=="BigToe" || $type=="PinkyToe")
	$help="BigToe + PinkyToe = FootRock";
if ($type=="Root" || $type=="Chest" || $type=="Mid")
	$help="Root + Chest (+ Mid) = Spine IK";
if ($type=="0" || $type=="1" || $type=="2" || $type=="3")
	$help="0,1,2, etc.. = Spline IK (tail)";


text -e -l $help asLabelHelp;
}

global proc asUpdateAttributeHelp ()
{
string $type=`optionMenu -q -v asAttributeType`;
string $help="";
if ($type=="twist/bendy")
	$help="TwistJoints & Bendy-limbs";
if ($type=="inbetween")
	$help="Creates extra inbetween joints";
if ($type=="global")
	$help="Keeps limbs orientation fixed";
if ($type=="aim")
	$help="LookAt (AimConstraint)";
if ($type=="wheel")
	$help="Wheel Roller";
if ($type=="freeOrient")
	$help="Free limb orientation";
if ($type=="worldOrient")
	$help="Orient limb to world-space";
if ($type=="flipOrient")
	$help="Reverse up-vector";
if ($type=="noMirror")
	$help="For non-symmetrical limbs";
if ($type=="noControl")
	$help="Skips creating FK-control";
if ($type=="geoAttach")
	$help="Controller sticks to geometry";

text -e -l $help asAttributeHelp;
}

global proc asFitResample ()
{
if (`window -q -ex asFitResample`)
	deleteUI asFitResample;
window -t Resample asFitResample;

int $numJoints=2;
string $allDescendents[],$tempString[];
string $selJoints[]=`ls -sl -type joint`;
string $startJoint=$endJoint="none";
if (size($selJoints)==1)
	{
	string $asFitJointIKInfo[]=`asFitJointIKInfo $selJoints[0]`;
	if ($asFitJointIKInfo[1]!="")
		$startJoint=$asFitJointIKInfo[1];
	if ($asFitJointIKInfo[3]!="")
		$endJoint=$asFitJointIKInfo[3];
	}
if (size($selJoints)==2)
	{
	$allDescendents=`listRelatives -ad $selJoints[0]`;
	if (`stringArrayCount $selJoints[1] $allDescendents`)
		{
		$startJoint=$selJoints[0];
		$endJoint=$selJoints[1];
		}
	$allDescendents=`listRelatives -ad $selJoints[1]`;
	if (`stringArrayCount $selJoints[0] $allDescendents`)
		{
		$startJoint=$selJoints[1];
		$endJoint=$selJoints[0];
		}
	}
//Find current $numJoints
if (`objExists $startJoint` && `objExists $endJoint` )
	{
	string $countJoint=$endJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`listRelatives -p $countJoint`;
		$countJoint=$tempString[0];
		if ($countJoint=="" || $countJoint==$startJoint)
			break;
		$numJoints++;
		}
	}

columnLayout -adj 1;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "StartJoint:" -ed 0 -tx $startJoint asFitResampleStartJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleStartJointtextFieldGrp";
	setParent..;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "EndJoint" -ed 0 -tx $endJoint asFitResampleEndJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleEndJointtextFieldGrp";
	setParent..;
intFieldGrp -v1 $numJoints -cw2 60 50 -l "joints" asFitResampleNumJoints;
button -l "ReSample" -c asFitResampleJoints;
showWindow asFitResample;
}

global proc asFitResampleJoints ()
{
global string $gSelect;
setToolTo $gSelect;
string $sel[]=`ls -sl`;
string $tempString[],$joints[],$parentJoints[];
string $newJoint;
string $startJoint=`textFieldGrp -q -tx asFitResampleStartJointtextFieldGrp`;
string $endJoint=`textFieldGrp -q -tx asFitResampleEndJointtextFieldGrp`;
int $numJoints=`intFieldGrp -q -v1 asFitResampleNumJoints`;
$tempString=`ls -l $endJoint`;
tokenize $tempString[0] "|" $parentJoints;
int $reachedStart=0;
for ($i=0;$i<size($parentJoints);$i++)
	{
	if ($parentJoints[$i]==$startJoint)
		$reachedStart=1;
	if ($reachedStart)
		$joints[size($joints)]=$parentJoints[$i];	
	}
if (!`objExists $startJoint`)
	error ("startJoint :\""+$startJoint+"\" does not exists");
if (!`objExists $endJoint`)
	error ("endJoint :\""+$endJoint+"\" does not exists");
if ($numJoints<2)
	error "Can not ReSample to less than 2";
if (!`stringArrayCount $startJoint $joints`)
	error ("endJoint:\""+$endJoint+"\" is not a child of startJoint:\""+$startJoint+"\"");
if ($startJoint==$endJoint)
	error "StartJoint and EndJoint can not be the same";

select $startJoint $endJoint;
$tempString=`ikHandle -sol ikSplineSolver -scv false -pcv false`;
duplicate -n tempIKCurve $tempString[2];
delete $tempString[0] $tempString[2];
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempIKCurveShape.worldSpace[0] tempPointOnCurveInfo.inputCurve;
select tempIKCurve;refresh;

int $startJointLocks[]=`asUnLockAttrs $startJoint`;
int $endJointLocks[]=`asUnLockAttrs $endJoint`;

float $startJointFat=1;
float $startJointFatY=1;
float $startJointFatZ=1;
float $endJointFat=1;
float $endJointFatY=1;
float $endJointFatZ=1;
if (`attributeExists fat $startJoint`) $startJointFat=`getAttr ($startJoint+".fat")`;
if (`attributeExists fatY $startJoint`) $startJointFatY=`getAttr ($startJoint+".fatY")`;
if (`attributeExists fatZ $startJoint`) $startJointFatZ=`getAttr ($startJoint+".fatZ")`;
if (`attributeExists fat $endJoint`) $endJointFat=`getAttr ($endJoint+".fat")`;
if (`attributeExists fatY $endJoint`) $endJointFatY=`getAttr ($endJoint+".fatY")`;
if (`attributeExists fatZ $endJoint`) $endJointFatZ=`getAttr ($endJoint+".fatZ")`;

$tempString=`listRelatives -p $startJoint`;
string $startJointParent=$tempString[0];
if ($startJointParent!="")
	parent -w $startJoint;
parent -w $endJoint;
float $radius=`getAttr ($startJoint+".radius")`;
rename $endJoint tempRename;
if (`objExists $joints[1]`) delete $joints[1];
string $parent=$startJoint;
string $newJointName=$joints[0];
if ($joints[0]=="Root")
	{
	createNode -n Spine transform;
	$newJointName="Spine";
	}
for ($i=1;$i<$numJoints-1;$i++)
	{
	select -cl;
	$newJoint=`joint -n $newJointName -rad $radius`;
	setAttr tempPointOnCurveInfo.parameter ((1.0/($numJoints-1))*$i);
	$pos=`getAttr tempPointOnCurveInfo.position`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $newJoint;
	parent $newJoint $parent;
	$parent=$newJoint;
	asEnsureFitJointAttrs $newJoint;
	setAttr ($newJoint+".fat") ($startJointFat+(($i/($numJoints-1.0))*($endJointFat-$startJointFat)));
	setAttr ($newJoint+".fatY") ($startJointFatY+(($i/($numJoints-1.0))*($endJointFatY-$startJointFatY)));
	setAttr ($newJoint+".fatZ") ($startJointFatZ+(($i/($numJoints-1.0))*($endJointFatZ-$startJointFatZ)));
	asFitModeUpdateJoints $newJoint 0;
	refresh;
	}
if ($joints[0]=="Root" && `objExists |Spine`) delete |Spine;
if (`objExists $endJoint`)
	rename $endJoint ($endJoint+"_2");
rename tempRename $endJoint;
parent $endJoint $parent;
if ($startJointParent!="")
	parent $startJoint $startJointParent;

asReLockAttrs $startJoint $startJointLocks;
asReLockAttrs $endJoint $endJointLocks;

asFitModeUpdateJoints $endJoint 0;
delete tempIKCurve;
if (`checkBox -q -ex asLockCenterJoints`)
	if (`checkBox -q -v asLockCenterJoints`)
		asFitModeLockCenterJoints;

print ("// Joints Resampled\n");
catchQuiet (`select $sel`);
}

global proc int[] asUnLockAttrs (string $obj)
{
int $lockedAttrs[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		$lockedAttrs[size($lockedAttrs)]=`getAttr -l ($obj+"."+$trs[$y]+$xyz[$z])`;
		setAttr -l 0 ($obj+"."+$trs[$y]+$xyz[$z]);
		}
return $lockedAttrs;
}

global proc asReLockAttrs (string $obj, int $lockedAttrs[])
{
int $attrNr=0;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		setAttr -l $lockedAttrs[$attrNr] ($obj+"."+$trs[$y]+$xyz[$z]);
		$attrNr++;
		}
}

global proc asFitResamplePick (string $textFieldGrp)
{
string $selJoints[]=`ls -sl -type joint`;
if (!size($selJoints))
	error "No joint selected";
textFieldGrp -e -tx $selJoints[0] $textFieldGrp;
}

global proc asAddFitJointLabel ()
{
string $labelType=`optionMenu -q -v asLabelType`;
string $sel[]=`ls -sl -type joint`;
int $labelCode;
for ($i=0;$i<size($sel);$i++)
	{
	setAttr ($sel[$i]+".drawLabel") 1;
	$labelCode=`asLabelCodeLookup $labelType 1`;
	setAttr ($sel[$i]+".type") $labelCode;
	if ($labelCode==18)
		setAttr -type "string" ($sel[$i]+".otherType") $labelType;
	}
}

global proc asRemoveFitJointLabel ()
{
string $sel[]=`ls -sl -type joint`;
for ($i=0;$i<size($sel);$i++)
	setAttr ($sel[$i]+".drawLabel") 0;
}

global proc string asLabelCodeLookup (string $labelCode, int $labelToCode)
{

string $result;
int $codes[]={0,1,2,4,18,10,12,15,16,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18};
string $labels[]={"None","Root","Hip","Foot","ToesEnd","Shoulder","Hand","PropA","PropB","PropC","Other","Chest","Mid","Toes","Heel","BigToe","PinkyToe","LegAim","Eye","Wheel","0","1","2","3"};

for ($i=0;$i<size($labels);$i++)
	{
	if ($labelToCode)
		if ($labels[$i]==$labelCode)
			return $codes[$i];
	if (!$labelToCode)
		if ($codes[$i]==$labelCode)
			return $labels[$i];
	}
return "";
}

global proc string asLabel (string $obj)
{
string $label;
if (size(`ls -ap $obj`)>1)
	error ("More than one object matches name: "+$obj+"\n");
if (!`objExists $obj`)
	return "AA";
if (!`attributeExists "type" $obj`)
	return "BB";
int $labelNum=`getAttr ($obj+".type")`;
if (!`getAttr ($obj+".drawLabel")`)
	return "";

$label=`asLabelCodeLookup $labelNum 0`;
if ($labelNum==18)
	{
	$label=`getAttr ($obj+".otherType")`;
	}

return $label;
}

global proc asAddFitJointAttribute ()
{
string $attr=`optionMenu -q -v asAttributeType`;
string $sel[]=`ls -sl`;
float $dv=1;
string $meshObject;
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]`)
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}
	if ($attr=="twist/bendy" && `attributeExists twistJoints $sel[$i]`)
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}

	if ($attr=="twist/bendy")
		{
		addAttr -k 1 -ln "twistJoints" -at long -min 0 -max 10 -dv 2 $sel[$i];
		addAttr -k 1 -ln "bendyJoints" -at bool -dv 0 $sel[$i];
		//Update geo, if in FitMode
		global int $asFitModeScriptJobNr1;
		if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
			if (`checkBox -q -ex asVisGeo`)
				if (`checkBox -q -v asVisGeo`)
					asFitModeUpdateAllGeometry;
		}
	else if ($attr=="inbetween")
		addAttr -k 1 -ln "inbetweenJoints" -at long -min 0 -dv 2 $sel[$i]; 
	else if ($attr=="global")
		addAttr -k 1 -ln $attr -at double -min 0 -max 10 -dv 0 $sel[$i];
	else if ($attr=="worldOrient")
		addAttr -k 1 -ln $attr -at "enum" -en "xUp:yUp:zUp:xDown:yDown:zDown:" -dv 0 $sel[$i];
	else if ($attr=="geoAttach")
		{
		for ($y=0;$y<size($sel);$y++)
			{
			string $tempString[]=`listRelatives -s $sel[$y]`;
			if ($tempString[0]!="")
				if (`objectType $tempString[0]`=="mesh")
					$meshObject=$sel[$y];
			}
		if (size($sel)<2 || $meshObject=="")
			error "Select both FitJoint AND Geometry to attach to";
		addAttr -k 1 -ln $attr -at "enum" -en `substituteAllString $meshObject ":" "__"` $sel[$i];
		select $sel[$i];
		}
	else
		addAttr -k 1 -ln $attr -at bool -dv $dv $sel[$i];
	}
}

global proc asRemoveFitJointAttribute ()
{
string $sel[]=`ls -sl -type joint`;
string $attr=`optionMenu -q -v asAttributeType`;
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]`)
		deleteAttr ($sel[$i]+"."+$attr);
	if ($attr=="twist/bendy" && `attributeExists "twistJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".twistJoints");
	if ($attr=="twist/bendy" && `attributeExists "bendyJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".bendyJoints");
	if ($attr=="inbetween" && `attributeExists "inbetweenJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".inbetweenJoints");
	}
}

global proc asFitDisplayAxis (int $onOff)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
string $tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $fitJoints[$i]`;
	string $child=$tempString[0];
	if ($child=="")
		continue;
	setAttr ($fitJoints[$i]+".displayLocalAxis") $onOff;
	}
}

global proc asFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr3;
string $sel[]=`ls -sl`;
int $onOff=1;
if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
	$onOff=0;
//asByPassSDK $onOff;
select -cl;
if ($onOff)
	{
	asFitModeManualUpdate;
	$asFitModeScriptJobNr1=`scriptJob -cu 1 -killWithScene -e SelectionChanged asFitModeSelectionChanged`;
	if (`objExists FitSkeleton`)
		$asFitModeScriptJobNr3=`scriptJob -cu 1 -killWithScene -ac FitSkeleton.s asFitModeUpdateScale`;
	headsUpDisplay -s 2 -b 0 -bs "medium" -l "FitMode" -lfs "large" HUDFitMode;
	print "// Entered FitMode\n";
	}
else
	{
	if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr1;
		$asFitModeScriptJobNr1=0;
		}
	if (`scriptJob -ex $asFitModeScriptJobNr3`  && $asFitModeScriptJobNr3!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr3;
		$asFitModeScriptJobNr3=0;
		}
	asFitModeSelectionChanged;
	if (`headsUpDisplay -ex HUDFitMode`)
		headsUpDisplay -rem HUDFitMode;
	print "// Exited FitMode\n";
	}
select $sel;
}

global proc asToggleFitAdvancedSkeleton  ()
{
int $fitSkeletonVis=`getAttr FitSkeleton.visibility`;
setAttr -l 0 FitSkeleton.visibility;
setAttr -l 1 FitSkeleton.visibility (!$fitSkeletonVis);
setAttr MotionSystem.visibility $fitSkeletonVis;
setAttr DeformationSystem.visibility $fitSkeletonVis;
if (!$fitSkeletonVis)
	asDrivingSystemToFitSkeleton;
}

global proc asDrivingSystemToFitSkeleton ()
{
if (!`objExists DrivingSystem`)
	return;

if (`attributeExists drivingSystem FitSkeleton`)
	deleteAttr FitSkeleton.drivingSystem;
addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;

string $userAttrs[]=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	if (`gmatch $userAttrs[$i] "drivingSystem_*"`)
		deleteAttr ("FitSkeleton."+$userAttrs[$i]);

string $tempString[];	
string $drivingSystems[]=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	addAttr -k 0 -ln ("drivingSystem_"+$drivingSystems[$i]) -at bool -dv true -multi FitSkeleton;
	int $attrNr=0;
	string $userAttrs[]=`listAttr -ud -s -k $drivingSystems[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		string $sdks[]=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$userAttrs[$y])`;
		for ($z=0;$z<size($sdks);$z++)
			{
			if (!`attributeExists drivingSystemOut $sdks[$z]`) addAttr -k 0 -ln drivingSystemOut -at message $sdks[$z];
			if (`attributeExists $userAttrs[$y] $sdks[$z]`)
				deleteAttr ($sdks[$z]+"."+$userAttrs[$y]);
			string $addAttrCmd="addAttr -k 0 -ln "+$userAttrs[$y]+" -at \"float\" ";
			if (`addAttr -q -hasMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasSoftMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasSoftMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			$addAttrCmd+=$sdks[$z];
			eval ($addAttrCmd);

			connectAttr -f ("FitSkeleton.drivingSystem_"+$drivingSystems[$i]+"["+$attrNr+"]") ($sdks[$z]+"."+$userAttrs[$y]);
			$tempString=`listConnections ($sdks[$z]+".drivingSystemOut")`;
			if ($tempString[0]!="FitSkeleton")
				connectAttr -na ($sdks[$z]+".drivingSystemOut") FitSkeleton.drivingSystem;
			$attrNr++;
			}
		}
	}
}

global proc string asUniqueName (string $obj)
{
string $newName=$obj;
string $tempString[]=`ls $obj`;
if (size($tempString)>1)
	for ($i=1;$i<99;$i++)
		if (!`objExists ($obj+$i)`)
			{
			$newName=$obj+$i;
			rename $tempString[0] $newName;
			break;
			}
return $newName;
}

global proc asFitModeManualUpdate ()
{
string $sel[]=`ls -sl`;
//asByPassSDK 1;
if (!`objExists FitSkeleton`)
	return;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	$fitJoints[$i]=`asUniqueName $fitJoints[$i]`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	asFitModeUpdateJoints $fitJoints[$i] 0;
	asFitModeUpdateFat $fitJoints[$i];
	}
catchQuiet (`select $sel`);
//asByPassSDK 0;
print "// Updated Orientations\n";
}

global proc asFitModeSelectionChanged ()
{
global int $asFitModeScriptJobNr2[];
global string $asFitModeOffRLA[];
for ($i=0;$i<size($asFitModeOffRLA);$i++)
	if (`objExists $asFitModeOffRLA[$i]`)
		setAttr ($asFitModeOffRLA[$i]+".displayLocalAxis") 0;

clear $asFitModeOffRLA;
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
string $sel[]=`ls -sl -type joint`;
string $tempString[];
string $rlaParent,$rlaChild;
float $pos[];
string $aimParents;
for ($i=0;$i<size($sel);$i++)
	{
	//Parent
//	if (size(`ls -ap $sel[$i]`)>1)
//		continue;
	$rlaParent=`asRlaParent $sel[$i]`;
	if (!`objExists $rlaParent`)
		continue;
//	string $parentOtherChildren[]=`listRelatives -c -type joint $rlaParent`;
//	$parentOtherChildren=`stringArrayRemove {$sel[$i]} $parentOtherChildren`;
//	if (size($parentOtherChildren) && $sel[$i]!="BackA")
//		continue;

	if (!`getAttr ($rlaParent+".displayLocalAxis")`)
		$asFitModeOffRLA[$i]=$rlaParent;
	setAttr ($rlaParent+".displayLocalAxis") 1;
	if ($aimParents!="")
		$aimParents+="@";
	$aimParents+=$sel[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	//Child
	$rlaChild=`asRlaChild $sel[$i]`;
//	if (size(`ls -ap $rlaChild`)!=1)
//		continue;
	$aimParents+="@"+$rlaChild;
	if (`attributeExists fatYabs $sel[$i]`)
		$asFitModeScriptJobNr2[2]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".fatYabs") ("asFitModeUpdateFat \""+$sel[$i]+"\"")`;
	if (`attributeExists fatZabs $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".fatZabs") ("asFitModeUpdateFat \""+$sel[$i]+"\"")`;
	if (`attributeExists twistJoints $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".twistJoints") ("asFitModeUpdateAllGeometry")`;

	}
if ($aimParents!="")
	{
	$asFitModeScriptJobNr2[0]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".translate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	$asFitModeScriptJobNr2[1]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".rotate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	}
}

global proc asFitModeLockCenterJoints ()
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`)
	return;
int $lock=`getAttr FitSkeleton.lockCenterJoints`;
float $scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
float $pos[],$pos2[];
string $fitSkeletonJoints[]=`listRelatives -f -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitSkeletonJoints);$i++)
	{
	$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
	if ($lock)
		if ($pos[0]<-$centerTolerance || $pos[0]>$centerTolerance)
			continue;

	$tempString=`listRelatives -p $fitSkeletonJoints[$i]`;
	$parent=$tempString[0];
	createNode -n transformSampler -p $parent transform;

	setAttr -type float3 transformSampler.t 1 0 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".tx");

	setAttr -type float3 transformSampler.t 0 1 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".ty");

	setAttr -type float3 transformSampler.t 0 0 1;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".tz");

	delete transformSampler;
	setAttr -l $lock ($fitSkeletonJoints[$i]+".rx");
	setAttr -l $lock ($fitSkeletonJoints[$i]+".ry");
	}
select $sel;
}

global proc asFitModeUpdateFat (string $joint)
{
string $rlaParent=`asRlaParent $joint`;
//update flare
if (`objExists ($rlaParent+"GapBlenderA")`)
	if (`attributeExists dummyInput1 ($rlaParent+"GapBlenderA")`)
		{
		setAttr ($rlaParent+"GapBlenderA"+".input[1]") `getAttr ($rlaParent+"GapBlenderA"+".dummyInput1")`;
		setAttr ($rlaParent+"GapBlenderB"+".input[1]") `getAttr ($rlaParent+"GapBlenderB"+".dummyInput1")`;
		}
}

global proc asFitModeUpdateAllGeometry ()
{
checkBox -e -v 0 asVisGeo;
asFitGeometry;
checkBox -e -v 1 asVisGeo;
asFitGeometry;
}

global proc asFitModeUpdateScale ()
{
float $fitSkeletonScale[3]=`getAttr FitSkeleton.s`;
if ($fitSkeletonScale[0]==1 && $fitSkeletonScale[1]==1 && $fitSkeletonScale[2]==1)
	return;
string $sel[]=`ls -sl`;
int $lockTxs[],$lockTys[],$lockTzs[];
string $fitJointsParent[],$tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
setAttr -type float3 FitSkeleton.s 1 1 1;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$lockTxs[$i]=`getAttr -l ($fitJoints[$i]+".tx")`;$lockTys[$i]=`getAttr -l ($fitJoints[$i]+".ty")`;$lockTzs[$i]=`getAttr -l ($fitJoints[$i]+".tz")`;
	setAttr -l 0 ($fitJoints[$i]+".tx");setAttr -l 0 ($fitJoints[$i]+".ty");setAttr -l 0 ($fitJoints[$i]+".tz");
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -p $fitJoints[$i]`;
	$fitJointsParent[$i]=$tempString[0];
	parent -w $fitJoints[$i];
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	float $pos[]=`xform -q -ws -t $fitJoints[$i]`;
	xform -ws -t ($pos[0]*$fitSkeletonScale[0]) ($pos[1]*$fitSkeletonScale[1]) ($pos[2]*$fitSkeletonScale[2]) $fitJoints[$i];
	if (`attributeExists fat $fitJoints[$i]`) setAttr ($fitJoints[$i]+".fat") (`getAttr ($fitJoints[$i]+".fat")`*$fitSkeletonScale[1]);
	}
for ($i=0;$i<size($fitJoints);$i++)
	if (`objExists $fitJointsParent[$i]`)
		parent $fitJoints[$i] $fitJointsParent[$i];
for ($i=0;$i<size($fitJoints);$i++)
	{
	setAttr -l $lockTxs[$i] ($fitJoints[$i]+".tx");setAttr -l $lockTys[$i] ($fitJoints[$i]+".ty");setAttr -l $lockTzs[$i] ($fitJoints[$i]+".tz");
	}
scale -r -p 0 0 0 $fitSkeletonScale[1] $fitSkeletonScale[1] $fitSkeletonScale[1] FitSkeletonShape.cv[0:7] ;
asFitModeManualUpdate;
select $sel;
}

global proc asFitModeUpdateJoints (string $jointsString, int $recursive)
{
int $upV[3]={0,1,0};
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
asFitModeUpdateScale;
string $sel[]=`ls -sl`;
string $tempString[],$joints[],$jointAllDescendents[],$otherJointsInIK[],$connectCmds[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $generatedTransform1,$generatedTransform2,$IKParentJoint,$IKChildJoint,$jointLongName,$worldOrient;
tokenize $jointsString "@" $joints;
for ($joint in $joints)
	{
	if (size(`ls -ap $joint`)!=1)
		continue;
	string $rlaParent=`asRlaParent $joint`;
	$rlaParent=`asUniqueName $rlaParent`;
	string $rlaChild=`asRlaChild $joint`;
	$rlaChild=`asUniqueName $rlaChild`;
	if (!`objExists $rlaParent`)
		continue;
	if (`attributeExists freeOrient $rlaParent`)
		continue;
	if (`asRlaChild $rlaParent`!=$joint && $rlaParent!="Cup")
		continue;
	$worldOrient="";
	if (`attributeExists worldOrient $rlaParent`)
		$worldOrient=`getAttr ($rlaParent+".worldOrient")`;
	$flipOrient=0;
	if (`attributeExists flipOrient $joint`)
		if (`getAttr ($joint+".flipOrient")`)
			$flipOrient=!$flipOrient;
	string $rlaParentParent=`asRlaParent $rlaParent`;
	clear $otherJointsInIK;
	$tempString=`ls -l $joint`;
	$jointLongName=$tempString[0];
	$jointAllDescendents=`listRelatives -allDescendents -type joint $joint`;
	$jointAllDescendents[size($jointAllDescendents)]=$joint;
	string $parentOtherChildren[]=`listRelatives -c $rlaParent`;
	$parentOtherChildren=`stringArrayRemove {$joint} $parentOtherChildren`;
	int $center=0;
	$pos=`xform -q -ws -t $joint`;
	if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;

	//IK-plane ($flip)
	tokenize $jointLongName "|" $tempString;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		if (!$recursive)
			if (!`stringArrayCount $tempString[$i] $joints`)
				$otherJointsInIK[size($otherJointsInIK)]=$tempString[$i];
		if (`attributeExists flipOrient $tempString[$i]`)
			if (`getAttr ($tempString[$i]+".flipOrient")`)
				$flipOrient=!$flipOrient;
		$label=`asLabel $tempString[$i]`;
		if (`gmatch $label "*Shoulder*"` || `gmatch $label "*Hip*"`)
			{
			$IKParentJoint=$tempString[$i];
			break;
			}
		}
	for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
		{
		if (!$recursive)
			if (!`stringArrayCount $jointAllDescendents[$i] $joints`)
				$otherJointsInIK[size($otherJointsInIK)]=$jointAllDescendents[$i];
		$label=`asLabel $jointAllDescendents[$i]`;
		if (`gmatch $label "*Hand*"` || `gmatch $label "*Foot*"`)
			{$IKChildJoint=$jointAllDescendents[$i];break;}
		}

	int $lockTX=`getAttr -l ($joint+".tx")`;int $lockTY=`getAttr -l ($joint+".ty")`;int $lockTZ=`getAttr -l ($joint+".tz")`;
	int $lockRX=`getAttr -l ($joint+".rx")`;int $lockRY=`getAttr -l ($joint+".ry")`;int $lockRZ=`getAttr -l ($joint+".rz")`;
	int $lockPTX=`getAttr -l ($rlaParent+".tx")`;int $lockPTY=`getAttr -l ($rlaParent+".ty")`;int $lockPTZ=`getAttr -l ($rlaParent+".tz")`;
	int $lockPRX=`getAttr -l ($rlaParent+".rx")`;int $lockPRY=`getAttr -l ($rlaParent+".ry")`;int $lockPRZ=`getAttr -l ($rlaParent+".rz")`;
	setAttr -l 0 ($joint+".tx");setAttr -l 0 ($joint+".ty");setAttr -l 0 ($joint+".tz");
	setAttr -l 0 ($joint+".rx");setAttr -l 0 ($joint+".ry");setAttr -l 0 ($joint+".rz");
	setAttr -l 0 ($rlaParent+".tx");setAttr -l 0 ($rlaParent+".ty");setAttr -l 0 ($rlaParent+".tz");
	setAttr -l 0 ($rlaParent+".rx");setAttr -l 0 ($rlaParent+".ry");setAttr -l 0 ($rlaParent+".rz");

	if (size($parentOtherChildren))
		{
		createNode -n otherChildrenPlaceHolder -p $rlaParent transform;
		parent -w otherChildrenPlaceHolder;
		}
	for ($i=0;$i<size($parentOtherChildren);$i++)
		{
		$tempString=`parent $parentOtherChildren[$i] otherChildrenPlaceHolder`;
		$parentOtherChildren[$i]=$tempString[0];
		}
		
	$tempString=`parent -w $joint`;
	$joint=$tempString[0];
	$tempString=`listRelatives -p $joint`;
	if (size($tempString))
		$generatedTransform1=$tempString[0];

	//disconnect connections
	clear $connectCmds;
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$tempString=`listConnections -p 1 ($rlaParent+"."+$trs[$y]+$xyz[$z])`;
			if ($tempString[0]!="")
				{
				$connectCmds[size($connectCmds)]="connectAttr -f "+$tempString[0]+" "+$rlaParent+"."+$trs[$y]+$xyz[$z]+";";
				disconnectAttr $tempString[0] ($rlaParent+"."+$trs[$y]+$xyz[$z]);
				}
			}

	if ($center) // Center
		{
		$upV={0,0,1}; if ($flipOrient) $upV={0,0,-1};
		$tempString=`aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "vector" -worldUpVector 1 0 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	if (($IKParentJoint=="" || $IKChildJoint=="") && !$center) // Non-IK (side)
		{
		$upV={0,1,0}; // if ($flipOrient) $upV={0,-1,0}; These are free oriented, so no flip
		string $upVecObj=`createNode joint`;
		parent -r $upVecObj $rlaParent;
		setAttr ($upVecObj+".translate") 0 3 0;
		parent -w $upVecObj;
		$tempString=`listRelatives -p $upVecObj`;
		if (size($tempString))
			$generatedTransform2=$tempString[0];
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0] $upVecObj;
		}

	if (($IKParentJoint!="" && $IKChildJoint!="") && !$center) // IK
		{
		$upV={0,1,0}; if ($flipOrient) $upV={0,-1,0};
		$label=`asLabel $IKParentJoint`;
		if (`gmatch $label "*Hip*"`)
			$upV={0,-1,0};
		string $upVecObj=`createNode joint`;
		parent -r $upVecObj $rlaParent;
		setAttr ($upVecObj+".translate") 0 3 0;
		parent -w $upVecObj;
		$tempString=`listRelatives -p $upVecObj`;
		if (size($tempString))
			$generatedTransform2=$tempString[0];
		pointConstraint $IKParentJoint $IKChildJoint $upVecObj;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0] $upVecObj;
		}
	else
		clear $otherJointsInIK;

	//Special case, $worldOrient
	if ($worldOrient!="" && `objExists $rlaParentParent`)
		{
		$upVecObj=$rlaParentParent;
		$upVecObj=`createNode -n tempUpVector -p $joint transform`;
		parent -w $upVecObj;
		move -r -ws 0 1 0 $upVecObj;
		float $upVec=1;
		parent $upVecObj $rlaParentParent;
		//Could be `reverse-knee`
//		if (`getAttr ($upVecObj+".ty")`<0)
//			$upVec=-1;
		createNode -n tempAimAt -p $rlaParent transform;
		parent -w tempAimAt;
		move -r -ws 0 -1 0 tempAimAt;
		if ($worldOrient==0) $tempString=`aimConstraint -aimVector -1 0 0 -upVector 0 $upVec 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==1) $tempString=`aimConstraint -aimVector 0 -1 0 -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==2) $tempString=`aimConstraint -aimVector 0 0 -1 -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==3) $tempString=`aimConstraint -aimVector 1 0 0  -upVector 0 $upVec 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==4) $tempString=`aimConstraint -aimVector 0 1 0  -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==5) $tempString=`aimConstraint -aimVector 0 0 1  -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;

		delete $tempString[0] $upVecObj tempAimAt;
		}
	//Special case, Ball
	$label=`asLabel $rlaParent`;
	if (`gmatch $label "*Ball*"`)
		{
		//Could be `reverse-knee`
		float $upVec=1;
		createNode -n tempAimAt -p $rlaParentParent transform;
		asAlign tempAimAt $joint 1 0 0 0;
		if (`getAttr tempAimAt.ty`<0)
			$upVec=-1;
		delete tempAimAt;
		$tempString=`aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 $upVec 0 -worldUpType "vector" -worldUpVector 0 1 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Scapula
	if (`gmatch $rlaParent "Scapula*"` && $IKParentJoint!="")
		{
		$upVecObj=$IKParentJoint;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, LegAim
	if (`gmatch $label "LegAim*"`)
		{
		$upVecObj=$IKParentJoint;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Cup
	if ($rlaParent=="Cup" && `objExists RingFinger1` && `objExists MiddleFinger1`)
		{
		$upVecObj=`asRlaParent $rlaParent`;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj RingFinger1 MiddleFinger1 $rlaParent`;
		delete $tempString[0];
		}

	//Special case, Root with no centered child
	if ($rlaParent=="Root" && !$center)
		{
		setAttr -type float3 ($rlaParent+".rotate") 0 0 0;
		setAttr -type float3 ($rlaParent+".jointOrient") 90 0 90;
		}

	makeIdentity -a 1 -t 0 -r 1 -s 0 $rlaParent;

	if (size($parentOtherChildren))
		{
		parent $parentOtherChildren $rlaParent;
		delete otherChildrenPlaceHolder;
		}

	parent $joint $rlaParent;
	if (`objExists $generatedTransform1`) delete $generatedTransform1;
	if (`objExists $generatedTransform2`) delete $generatedTransform2;

	//restore connections
	for ($i=0;$i<size($connectCmds);$i++)
		if (catchQuiet (`eval ($connectCmds[$i])`)) 
			warning ("Failed: "+$connectCmds[$i]+"\n");

	//update lenght
	if (`objExists ($rlaParent+"ScaleYMultiDiv1")`)
		setAttr ($rlaParent+"ScaleYMultiDiv1.input1Y") (`getAttr ($rlaParent+"ScaleYMultiDiv1.dummyInput1Y")`*(1.0/$scale));

	//update skeleton scale
	if (`objExists ($rlaParent+"Bone")` && `objExists ($rlaParent+"Distance")`)
		{
		float $lenght=`getAttr ($rlaParent+"Distance.distance")`*(1.0/$scale);
		setAttr ($rlaParent+"Bone.sx") $lenght;
		}

	//update scale from FitSkeleton
//	if (`objExists ($joint+"Aim")`)
//		setAttr ($joint+"Aim.sx") (1.0/$scale);

	setAttr -l $lockTX ($joint+".tx");setAttr -l $lockTY ($joint+".ty");setAttr -l $lockTZ ($joint+".tz");
	setAttr -l $lockRX ($joint+".rx");setAttr -l $lockRY ($joint+".ry");setAttr -l $lockRZ ($joint+".rz");
	setAttr -l $lockPTX ($rlaParent+".tx");setAttr -l $lockPTY ($rlaParent+".ty");setAttr -l $lockPTZ ($rlaParent+".tz");
	setAttr -l $lockPRX ($rlaParent+".rx");setAttr -l $lockPRY ($rlaParent+".ry");setAttr -l $lockPRZ ($rlaParent+".rz");
	}

//Update the other joints in the same IK to ensure IK-plane
for ($i=0;$i<size($otherJointsInIK);$i++)
	asFitModeUpdateJoints $otherJointsInIK[$i] 1;

select $sel;
}

global proc string[] asFitJointIKInfo (string $joint)
{
int $IKNumCtrls=2;
string $ik,$IKParentJoint,$IKMiddleJoint,$IKChildJoint,$IKSolver,$IKParentJointLabel;
string $asFitJointIKInfo[],$tempString[];
$tempString=`ls -l $joint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$label=`asLabel $tempString[$i]`;
	if ($i<size($tempString)-1)
		if (`gmatch $label "*Hand*"` || `gmatch $label "*Foot*"` || `gmatch $label "*Chest*"`)
			break;
	if (`gmatch $label "*Shoulder*"` || `gmatch $label "*Hip*"` || `gmatch $label "*Root*"` || `gmatch $label "0*"`)
		{
		$IKParentJoint=$tempString[$i];
		$IKParentJointLabel=$label;
		break;
		}
	}

string $jointAllDescendents[]=`listRelatives -allDescendents -type joint $joint`;
$jointAllDescendents[size($jointAllDescendents)]=$joint;
for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
	{
	$label=`asLabel $jointAllDescendents[$i]`;
	int $validLabelHit=0;
	if (`gmatch $label "*Hand*"` && `gmatch $IKParentJointLabel "*Shoulder*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Foot*"` && `gmatch $IKParentJointLabel "*Hip*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Chest*"` && `gmatch $IKParentJointLabel "*Root*"`)
		$validLabelHit=1;
	if ($validLabelHit)
		{
		$IKChildJoint=$jointAllDescendents[$i];
		break;
		}
	if (`gmatch $label "*[0-9]*"` && `gmatch $IKParentJointLabel "*0*"`)
		$IKChildJoint=$jointAllDescendents[$i];
	}

if ($IKParentJoint!= "" && $IKChildJoint!="")
	{
	//Find $IKMiddleJoint
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	int $numIkJoints=0;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		$numIkJoints++;
		if ($tempString[$i]==$IKParentJoint)
		break;
		}
	int $middleNr=$numIkJoints/2;
	$IKMiddleJoint=$tempString[size($tempString)-1-$middleNr];
	//Find $IKNumCtrls
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	for ($i=size($tempString)-2;$i>-1;$i--)
		{
		if ($tempString[$i]==$IKParentJoint)
		break;
		$label=`asLabel $tempString[$i]`;
		if (`gmatch $label "*Mid*"` || `gmatch $label "[0-9]*"`)
			$IKNumCtrls++;
		}

	$IKSolver="ikRPsolver";
	$label=`asLabel $IKParentJoint`;
	if (`gmatch $label "*Shoulder*"`)
		$ik="Arm"+`substitute "Shoulder" $label ""`;
	if (`gmatch $label "*Hip*"`)
		$ik="Leg"+`substitute "Hip" $label ""`;
	if (`gmatch $label "*Root*"`)
		{
		$ik="Spine"+`substitute "Root" $label ""`;
		$IKSolver="ikSplineSolver";
		}
	if (`gmatch $label "*0*"`)
		{
		$ik="Spline"+`substitute "[0-9]*" $label ""`;
		$IKSolver="ikSplineSolver";
		}
	$asFitJointIKInfo[0]=$ik;
	$asFitJointIKInfo[1]=$IKParentJoint;
	$asFitJointIKInfo[2]=$IKMiddleJoint;	
	$asFitJointIKInfo[3]=$IKChildJoint;	
	$asFitJointIKInfo[4]=$IKSolver;
	$asFitJointIKInfo[5]=$IKNumCtrls;
	}
return $asFitJointIKInfo;
}

global proc string[] asGetIKJoints (string $IKStartJoint, string $IKEndJoint)
{
string $IKJoints[];
string $tempString[]=`ls -l $IKEndJoint`;
tokenize $tempString[0] "|" $tempString;
int $foundStartJoint=0;
for ($i=0;$i<size($tempString);$i++)
	{
    if ($tempString[$i]==$IKStartJoint)
        $foundStartJoint=1;
    if ($foundStartJoint)
    	$IKJoints[size($IKJoints)]=$tempString[$i];
	}
return $IKJoints;
}

global proc asFitSDKCreateAttribute ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$drivenObjs[],$drivenAttrs[];
float $drivenDefaultValue[],$drivenValue[];
if (!size($sel))
	warning "Nothing selected, you should select a SDK Object first\n";
else
	$tempString=`listRelatives -c $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not a nurbsCurve\n";
if (`objectType $tempString[0]`!="nurbsCurve")
	error "Selected Object is not a nurbsCurve\n";
$existingDefaultPoseCmdString=`getAttr ($sel[0]+".defaultPose")`;
$existingDefaultPoseCmds=`stringToStringArray $existingDefaultPoseCmdString ";"`;

string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $cmd;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
		{
		$objAttr=$fitJoints[$i]+"."+$trs[$y]+$xyz[$z];
		float $value=`getAttr $objAttr`;
		for ($a=0;$a<size($existingDefaultPoseCmds);$a++)
			if (`gmatch $existingDefaultPoseCmds[$a] ("setAttr "+$objAttr+" *")`)
				{
				tokenize $existingDefaultPoseCmds[$a] $tempString;
				float $defaultValue=$tempString[2];
				if ($value>$defaultValue+0.001 || $value<$defaultValue-0.001)
					{
					tokenize $tempString[1] "." $tempString2;
					$drivenObjs[size($drivenObjs)]=$tempString2[0];
					$drivenAttrs[size($drivenAttrs)]=$tempString2[1];
					$drivenDefaultValue[size($drivenDefaultValue)]=$defaultValue;
					$drivenValue[size($drivenValue)]=$value;
					}
				}
		}
if (!size($drivenObjs))
	error "Found No attributes changed from Default Pose";

string $suggestAttrName;
if (`gmatch $drivenObjs[0] "*Finger*"` || `gmatch $drivenObjs[0] "*Toe*"`)
	{
	$suggestAttrName=`substitute "[0-9]" $drivenObjs[0] ""`;
	$suggestAttrName=`substitute "Finger" $suggestAttrName ""`;
	$suggestAttrName=`substitute "Toe" $suggestAttrName ""`;
	$suggestAttrNameFirstLetter=`substring $suggestAttrName 1 1`;
	$suggestAttrName=`tolower $suggestAttrNameFirstLetter`+`substring $suggestAttrName 2 99`+"Curl";
	}

$asFitSDKMessage="Create Set-Driven-Key for these ?\n\n";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $value=`getAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i])`;
	float $roundFactor=0.5;
	if ($value<0) $roundFactor=-0.5;
	$value=(trunc($value*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
	$asFitSDKMessage+=$drivenObjs[$i]+"."+$drivenAttrs[$i]+" = "+$value+"\n";
	}
$asFitSDKAttrName=$suggestAttrName;
$asFitSDKObjName=$sel[0];
$asFitSDKDriverValue=10;

string $dialogResult=`layoutDialog -t "Confirm" -ui asFitSDKCreateAttributeLayout`;
if ($dialogResult!="OK")
	return;

string $attrName=$asFitSDKAttrName;
if ($attrName=="" || `gmatch $attrName "* *"`)
	error "Not a valid attribute name";	
if (`attributeExists $attrName $sel[0]`)
	deleteAttr ($sel[0]+"."+$attrName);
addAttr -k 1 -ln $attrName -at double $sel[0];
if ($asFitSDKDriverHasMin) addAttr -e -softMinValue $asFitSDKDriverMin ($sel[0]+"."+$attrName);
if ($asFitSDKDriverHasMax) addAttr -e -softMaxValue $asFitSDKDriverMax ($sel[0]+"."+$attrName);

for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $driverValue=10;
	$objAttr=$drivenObjs[$i]+"."+$drivenAttrs[$i];
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenDefaultValue[$i] -dv 0 -cd ($sel[0]+"."+$attrName) $objAttr;
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValue[$i] -dv $asFitSDKDriverValue -cd ($sel[0]+"."+$attrName) $objAttr;
//	setAttr ($sel[0]+"."+$attrName) $driverValue;
	}
select $drivenObjs;
setInfinity -pri cycleRelative -poi cycleRelative;

select $sel;
}

global proc asFitSDKCreateAttributeLayout ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $tempString[];
tokenize $asFitSDKMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asFitSDKMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asFitSDKMessage+=$tempString[$i]+"\n";
	$asFitSDKMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout;
	text -l $asFitSDKMessage;
	separator -h 10 -st none;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 -tx $asFitSDKAttrName asFitSDKAttrNameTextField;
		setParent..;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Value:";
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverValueFloatField;
		setParent..;
	separator -st none -h 3;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		checkBox -l "Min" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMinFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMinFloatField" asFitSDKDriverHasMinCheckBox;
		checkBox -l "Max" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMaxFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMaxFloatField" asFitSDKDriverHasMaxCheckBox;
		setParent..;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		floatField -w 50 -v 0 -pre 1 asFitSDKDriverMinFloatField;
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverMaxFloatField;
		setParent..;
	separator -h 10 -st none;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asFitSDKCreateAttributeGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;
}

global proc asFitSDKCreateAttributeGetName ()
{
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
$asFitSDKAttrName=`textField -q -tx asFitSDKAttrNameTextField`;
$asFitSDKDriverValue=`textField -q -tx asFitSDKDriverValueFloatField`;
$asFitSDKDriverHasMin=`checkBox -q -v asFitSDKDriverHasMinCheckBox`;
$asFitSDKDriverHasMax=`checkBox -q -v asFitSDKDriverHasMaxCheckBox`;
$asFitSDKDriverMin=`floatField -q -v asFitSDKDriverMinFloatField`;
$asFitSDKDriverMax=`floatField -q -v asFitSDKDriverMaxFloatField`;
}

global proc string asRlaParent (string $joint)
{
string $tempString[]=`listRelatives -p -type joint $joint`;
string $rlaParent=$tempString[0];
return $rlaParent;
}

global proc string asRlaChild (string $joint)
{
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
string $children[]=`listRelatives -type joint -c $joint`;
string $rlaChild="";
float $pos[3]=`xform -q -ws -t $joint`;
int $center=0;
if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;
for ($y=0;$y<size($children);$y++)
	{
	float $childPos[3]=`xform -q -ws -t $children[$y]`;
	int $childCenter=0;
	if ($childPos[0]>-$centerTolerance && $childPos[0]<$centerTolerance) $childCenter=1;
	if ($center && $childCenter) $rlaChild=$children[$y];
	if (!$center && !$childCenter) $rlaChild=$children[$y];
	}

if (!$center && size($children)>1)
	$rlaChild="";

//Preferred $rlaChild
if (`gmatch $joint "*Head*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Head*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Ankle*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Toes*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Root*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Spine*"`)
			$rlaChild=$children[$y];

return $rlaChild;
}

global proc asFitGeometry ()
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $sel[]=`ls -sl`;
int $displayGeometry=`checkBox -q -v asVisGeo`;
if (`objExists FitSkeletonVisualizers`) delete FitSkeletonVisualizers;
if (`objExists Mannequin_Geometry`) delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`) delete Skeleton_Geometry;
if ($displayGeometry==0)
	{
	asUpdateButtonEnables;
	return;
	}
asFitModeEnsureShaders;
int $twistJoints,$inbetweenJoints;
float $aimV[3]={1,0,0};
float $upV[3]={0,1,0};
string $part;

createNode -n FitSkeletonVisualizers transform;
connectAttr FitSkeleton.s FitSkeletonVisualizers.s;
createNode -n Aims -p FitSkeletonVisualizers transform;
string $tempString[],$geoObjs[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
string $templateBones[]=`listRelatives -c Skeleton_Geometry`;
for ($i=0;$i<size($templateBones);$i++)
	rename $templateBones[$i] ($templateBones[$i]+"_template");

for ($i=size($fitJoints)-1;$i>-1;$i--) // Reverse order, so endJoints can copy `fat` value from parent
	asEnsureFitJointAttrs $fitJoints[$i];

for ($i=0;$i<size($fitJoints);$i++)
	{
	clear $geoObjs;
	string $rlaChild=`asRlaChild $fitJoints[$i]`;
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($rlaChild=="" && $fitJoints[$i]=="Root" && $tempString[0]!="") // Root to use sideChild, if no middleChild
		$rlaChild=$tempString[0];
	if ($rlaChild=="")
		continue;
	if (`attributeExists worldOrient $fitJoints[$i]`)
		continue;
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	if ($fitJoints[$i]=="*Jaw*" || `gmatch $fitJoints[$i] "*Eye*"`)
		continue;	

	createNode -n ($fitJoints[$i]+"Aim") -p Aims transform;
	$twistJoints=0;
	if (`attributeExists twistJoints  $fitJoints[$i]`)
		$twistJoints=`getAttr ($fitJoints[$i]+".twistJoints")`;
	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints  $fitJoints[$i]`)
		$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+$part+"Geo") -p ($fitJoints[$i]+"Aim") transform;
	
		//box
		$tempString=`polyCube -n ($fitJoints[$i]+$part+"Box") -w 1.75 -h 1 -d 1.75 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
		$box=$tempString[0];
		$geoObjs[size($geoObjs)]=$box;
		move -r 0 0.5 0 ($box+".vtx[0:7] ");
		sets -e -forceElement asRedSG ($box+".f[1]");
		sets -e -forceElement asRed2SG ($box+".f[3]");
		sets -e -forceElement asGreenSG ($box+".f[0]");
		sets -e -forceElement asGreen2SG ($box+".f[2]");
		sets -e -forceElement asBlueSG ($box+".f[4]");
		sets -e -forceElement asBlue2SG ($box+".f[5]");
		connectAttr FitSkeleton.visBoxes ($box+".v");
		setAttr ($box+"Shape.overrideEnabled") 1;
		setAttr ($box+"Shape.overrideDisplayType") 2;
		parent $box ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($box+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($box+".vtx[0:7]");
	
		
		//cylinder
		$tempString=`cylinder -n ($fitJoints[$i]+$part+"Cyl") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -hr 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 0`;
		$cyl=$tempString[0];
		$geoObjs[size($geoObjs)]=$cyl;
		move -r 0 0.5 0 ($cyl+".cv[0:3][0:7]");
		sets -e -forceElement asBlueSG ($cyl+".sf[0][7]") ($cyl+".sf[0][0]");//sf[0][1:2]
		sets -e -forceElement asGreenSG ($cyl+".sf[0][1:2]");//sf[0][3:4]
		sets -e -forceElement asBlue2SG ($cyl+".sf[0][3:4]");//sf[0][5:6]
		sets -e -forceElement asGreen2SG ($cyl+".sf[0][5:6]");//sf[0][7]
		connectAttr FitSkeleton.visCylinders ($cyl+".v");
		setAttr ($cyl+"Shape.overrideEnabled") 1;
		setAttr ($cyl+"Shape.overrideDisplayType") 2;
		parent $cyl ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($cyl+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($cyl+".cv[0:3][0:7]");	
		}

	//sphere
	$tempString=`polyCube -n ($fitJoints[$i]+"Sphere") -w 2.5 -h 2.5 -d 2.5 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
	$sphere=$tempString[0];
	sets -e -forceElement asRedSG ($sphere+".f[1]");
	sets -e -forceElement asRed2SG ($sphere+".f[3]");
	sets -e -forceElement asGreenSG ($sphere+".f[0]");
	sets -e -forceElement asGreen2SG ($sphere+".f[2]");
	sets -e -forceElement asBlueSG ($sphere+".f[4]");
	sets -e -forceElement asBlue2SG ($sphere+".f[5]");
	polySmooth  -mth 0 -dv 2 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 0 $sphere;
	connectAttr FitSkeleton.visSpheres ($sphere+".v");
	setAttr ($sphere+"Shape.overrideEnabled") 1;
	setAttr ($sphere+"Shape.overrideDisplayType") 2;
	parent $sphere ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($sphere+".s") 1 1 1;
	rotate -r -p 0 0 0 -os 0 -90 -90 ($sphere+".vtx[0:999]");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sy");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sz");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sx");

	//bones
	$bone=$fitJoints[$i]+"Bone";
	if (`objExists ($fitJoints[$i]+"Bone_template")`)
		duplicate -n $bone ($fitJoints[$i]+"Bone_template");
	else if ($fitJoints[$i]=="Root" || $fitJoints[$i]=="Chest" || `gmatch $fitJoints[$i] "Neck*"` || `gmatch $fitJoints[$i] "Spine*"`)
		duplicate -n $bone SpineBone_template;
	else if (`gmatch $fitJoints[$i] "*Finger*"`)
		duplicate -n $bone DigitBone_template;
	else
		duplicate -n $bone GenericBone_template;
	sets -e -forceElement asBonesSG $bone;
	parent $bone ($fitJoints[$i]+"Aim");
	connectAttr FitSkeleton.visBones ($bone+".v");
	connectAttr ($fitJoints[$i]+".fat") ($bone+".sy");
	connectAttr ($fitJoints[$i]+".fat") ($bone+".sz");

	//Flare
	select $geoObjs;
	$tempString=`nonLinear -type flare  -lowBound 0 -highBound 1 -startFlareX 1 -startFlareZ 1 -endFlareX 1 -endFlareZ 1 -curve 0`;
	string $flare=`rename $tempString[0] ($fitJoints[$i]+"Flare")`;
	string $flareHandle=`rename $tempString[1]  ($fitJoints[$i]+"FlareHandle")`;
	parent $flareHandle ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($flareHandle+".s") 1 1 1;
	setAttr -type float3 ($flareHandle+".t") 0 0 0;
	setAttr -type float3 ($flareHandle+".r") 0 0 -90;
	setAttr -l 1 ($flareHandle+".v") 0;
	
	connectAttr ($fitJoints[$i]+".fatYabs") ($flare+".startFlareX");
	connectAttr ($fitJoints[$i]+".fatZabs") ($flare+".startFlareZ");
	
	//Gap
	if (`objExists ($fitJoints[$i]+"GapBlenderA")`) delete ($fitJoints[$i]+"GapBlenderA");
	if (`objExists ($fitJoints[$i]+"GapBlenderB")`) delete ($fitJoints[$i]+"GapBlenderB");
	string $gapBlenderA=`createNode -n ($fitJoints[$i]+"GapBlenderA") blendTwoAttr`;
	string $gapBlenderB=`createNode -n ($fitJoints[$i]+"GapBlenderB") blendTwoAttr`;
	connectAttr FitSkeleton.visGap ($gapBlenderA+".attributesBlender");
	connectAttr FitSkeleton.visGap ($gapBlenderB+".attributesBlender");
	connectAttr ($fitJoints[$i]+".fatYabs") ($gapBlenderA+".input[0]");
	connectAttr ($fitJoints[$i]+".fatZabs") ($gapBlenderB+".input[0]");
	addAttr -k 0 -ln dummyInput1 -at double $gapBlenderA;
	addAttr -k 0 -ln dummyInput1 -at double $gapBlenderB;
	connectAttr ($rlaChild+".fatYabs") ($gapBlenderA+".dummyInput1");
	connectAttr ($rlaChild+".fatZabs") ($gapBlenderB+".dummyInput1");
	setAttr ($gapBlenderA+".input[1]") `getAttr ($rlaChild+".fatYabs")`;
	setAttr ($gapBlenderB+".input[1]") `getAttr ($rlaChild+".fatZabs")`;

	connectAttr ($gapBlenderA+".output") ($flare+".endFlareX");
	connectAttr ($gapBlenderB+".output") ($flare+".endFlareZ");

	//Distance
	if (`objExists ($fitJoints[$i]+"Distance")`) delete ($fitJoints[$i]+"Distance");
	createNode -n ($fitJoints[$i]+"Distance") distanceBetween;
	connectAttr ($fitJoints[$i]+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix1");
	connectAttr ($rlaChild+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix2");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv1")`) delete ($fitJoints[$i]+"ScaleYMultiDiv1");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv1") multiplyDivide;
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.operation") 2;
//	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y");

	addAttr -ln dummyInput1Y -at double ($fitJoints[$i]+"ScaleYMultiDiv1");
	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.dummyInput1Y");
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y") `getAttr ($fitJoints[$i]+"Distance.distance")`;

//	connectAttr FitSkeleton.sx ($fitJoints[$i]+"ScaleYMultiDiv1.input2Y");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv2")`) delete ($fitJoints[$i]+"ScaleYMultiDiv2");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv2") multiplyDivide;
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv2.input1Y");
	connectAttr FitSkeleton.visGap ($fitJoints[$i]+"ScaleYMultiDiv2.input2Y");
	
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($flareHandle+".sy");

	parentConstraint $fitJoints[$i] ($fitJoints[$i]+"Aim");

	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y) multiplyDivide;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input2Y") ($y*(1.0/($twistJoints+$inbetweenJoints+1)));
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo.tx");

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y) multiplyDivide;
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".operation") 2;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv2.outputY") ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input2Y") ($twistJoints+$inbetweenJoints+1);
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo"+".sx");
		}
	}

if (`objExists PelvisBone`)
	{
	parent PelvisBone FitSkeletonVisualizers;
	setAttr PelvisBone.tx 0;
	setAttr -type float3 PelvisBone.r 0 0 0;
	pointConstraint -skip x Hip PelvisBone;
	}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
asFitModeManualUpdate;
asUpdateButtonEnables;
asChangeVisGeoType;
catchQuiet (`select $sel`);
}

global proc asChangeVisGeoType ()
{
string $geoType=`optionMenu -q -v asVisGeoType`;
setAttr FitSkeleton.visCylinders 0;
setAttr FitSkeleton.visBoxes 0;
setAttr FitSkeleton.visSpheres 0;
setAttr FitSkeleton.visBones 0;
if ($geoType=="cylinders")
	setAttr FitSkeleton.visCylinders 1;
if ($geoType=="boxes")
	setAttr FitSkeleton.visBoxes 1;
if ($geoType=="spheres")
	setAttr FitSkeleton.visSpheres 1;
if ($geoType=="bones")
	setAttr FitSkeleton.visBones 1;
}

global proc asEnsureFitJointAttrs (string $fitJoint)
{
if (!`attributeExists fat $fitJoint`)
	{
	float $dv=1;
	string $rlaChild=`asRlaChild $fitJoint`;
	if ($rlaChild!="")
		{
		$dv=`getAttr ($rlaChild+".tx")`;
		$dv=`abs($dv)`;
		}
	else
		{
		string $tempString[]=`listRelatives -p -type joint $fitJoint`;
		if ($tempString[0]!="" && `attributeExists fat $tempString[0]`)
			$dv=`getAttr ($tempString[0]+".fat")`;
		}
	addAttr -k 1 -min 0 -dv $dv -ln fat -at double $fitJoint;
	}
if (!`attributeExists fatY $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatY -at double $fitJoint;
if (!`attributeExists fatZ $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatZ -at double $fitJoint;
if (!`attributeExists fatYabs $fitJoint`)
	addAttr -k 0 -ln fatYabs -at double $fitJoint;
if (!`attributeExists fatZabs $fitJoint`)
	addAttr -k 0 -ln fatZabs -at double $fitJoint;
if (`objExists ($fitJoint+"Fat")`) delete ($fitJoint+"Fat");
createNode -n ($fitJoint+"Fat") multiplyDivide;
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Y");
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Z");
connectAttr -f ($fitJoint+".fatY") ($fitJoint+"Fat.input2Y");
connectAttr -f ($fitJoint+".fatZ") ($fitJoint+"Fat.input2Z");
connectAttr -f ($fitJoint+"Fat.outputY") ($fitJoint+".fatYabs");
connectAttr -f ($fitJoint+"Fat.outputZ") ($fitJoint+".fatZabs");
}

global proc asRemoveUnusedfromBuildPose (string $uiName)
{
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	$buildPose="faceBuildPose";
string $newBuildPoseCmd;
string $cmds[],$tempString[];
string $buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $cmds;
for ($i=0;$i<size( $cmds);$i++)
	{
	tokenize $cmds[$i] $tempString;
	string $ctrl=$tempString[size($tempString)-1];
	if (`gmatch $cmds[$i] "*[.]*"`)
		$ctrl=$tempString[size($tempString)-2];
	if (`objExists $ctrl`)
		$newBuildPoseCmd+=$cmds[$i]+";";
	}
setAttr -type "string" ($buildPose+".udAttr") $newBuildPoseCmd;
}

global proc asUpdateASToolsProcsInSelectors ()
{
string $AdvancedSkeleton5File=`asGetScriptLocation`+"/AdvancedSkeleton5.mel";
string $fDet,$fDet2;
int $fileId=`fopen $AdvancedSkeleton5File "r"`;
string $nextLine = `fgetline $fileId`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId;

string $selectorsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/Selector/";
string $selectorFiles[]=`getFileList -fs "*.mel" -fld $selectorsDir`;
for ($i=0;$i<size($selectorFiles);$i++)
	{
	string $selectorFile=$selectorsDir+$selectorFiles[$i];
	int $fileId=`fopen $selectorFile "r"`;
	string $nextLine = `fgetline $fileId`;
	int $copyLines=0;
	$fDet2="";
	while (size($nextLine)>0)
		{
		$fDet2+=$nextLine;
		$nextLine=`fgetline $fileId`;
		if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
			break;
		}
	fclose $fileId;

	int $fileId2=`fopen $selectorFile "w"`;
	fprint $fileId2 ($fDet2+$fDet);
	fclose $fileId2;
print ("// Updated:"+$selectorFiles[$i]+"\n");
	}
}

global proc float asRoundOff (float $value, int $decimals)
{
float $rounded;
if ($value>=0) $rounded=(trunc($value*`pow 10 $decimals`+0.5)/`pow 10 $decimals`);
else $rounded=(trunc(abs($value)*`pow 10 $decimals`+0.5)/`pow 10 $decimals`)*-1;
return $rounded;
}

global proc asSetFixedWrapOptions ()
{
optionVar -intValue autoWeightThreshold 1;
optionVar -intValue exclusiveBind 0;
optionVar -intValue renderInfl 1;
optionVar -stringValue falloffMode "volume";
}

global proc asSwapCurve ()
{
string $side,$oppositeSide;
string $tempString[];
string $sel[]=`ls -sl`;
int $last=`size($sel)`-1;
string $selShapes[];
if (size($sel)<2)
	error "Selected both controls to replace, and the new curve to use";
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	$selShapes[$i]=$tempString[0];
	if (!`objExists $selShapes[$i]`)
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objectType $selShapes[$i]`!="nurbsCurve")
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	if ($i==$last && `sets -im ControlSet $sel[$i]`)
		error ("\""+$sel[$i]+"\" is a control. The new curve must be select last, and must not be a existing control");
	}
select $sel[$last];
DeleteHistory;
//flip around the replacememnt curve, to make the orientation more intuitive
string $offset=$sel[$last]+"Offset";
if(!(`gmatch $sel[0] "IK*"` || `gmatch $sel[0] "Pole*"`))
	if (!`objExists $offset`)
		{
		$tempString=`listRelatives -s $sel[$last]`;
		for ($y=0;$y<size($tempString);$y++)
			if(!(`gmatch $sel[0] "IK*"` || `gmatch $sel[0] "Pole*"`))
				rotate -r -os -90 -90 0 ($tempString[$y]+".cv[0:99]");
		createNode -n $offset transform;
		asAlign $offset $sel[$last] 1 1 0 0;
		parent $sel[$last] $offset;
		rotate -r -os 90 0 90 $offset;
		}
		
for ($i=0;$i<size($sel)-1;$i++)
	{
	$tempString=`listRelatives -s $sel[$last]`;
	for ($y=0;$y<size($tempString);$y++)
		parent -add -s $tempString[$y] $sel[$i];
	delete $selShapes[$i];
	if (`gmatch $sel[$i] "*_R"` || `gmatch $sel[$i] "*_L"`)
		{
		if (!`objExists ($sel[$last]+"Mirrored")`)
			{
			duplicate -n ($sel[$last]+"Mirrored") $sel[$last];
			setAttr ($sel[$last]+"Mirrored.v") 0;
			int $numCv;
			$form=`getAttr ($sel[$last]+".form")`;
			$spans=`getAttr ($sel[$last]+".spans")`;
			$degrees=`getAttr ($sel[$last]+".degree")`;
			if ($form==2)
				$numCv=$spans;
			else
				$numCv=$spans+$degrees;
			for ($y=0;$y<$numCv;$y++)
				{
				createNode -n ($sel[$last]+"MirroredMultiplyDivide"+$y) multiplyDivide;
				connectAttr ($sel[$last]+".cv["+$y+"]")  ($sel[$last]+"MirroredMultiplyDivide"+$y+".input1");
				setAttr -type float3 ($sel[$last]+"MirroredMultiplyDivide"+$y+".input2") -1 -1 -1;
				connectAttr ($sel[$last]+"MirroredMultiplyDivide"+$y+".output") ($sel[$last]+"Mirrored.cv["+$y+"]");
				}
			}

		if (`gmatch $sel[$i] "*_R"`) {$side="_R";$oppositeSide="_L";}
		if (`gmatch $sel[$i] "*_L"`) {$side="_L";$oppositeSide="_R";}
		if(`gmatch $sel[$i] "IK*"` || `gmatch $sel[$i] "Pole*"`)
			$tempString=`listRelatives -s $sel[$last]`;
		else
			$tempString=`listRelatives -s ($sel[$last]+"Mirrored")`;
		for ($y=0;$y<size($tempString);$y++)
			parent -add -s $tempString[$y] `substitute $side $sel[$i] $oppositeSide`;
		delete `substitute $side $selShapes[$i] $oppositeSide`;
		}
	}
	dgdirty -a;
}

global proc asSetBuildPose (string $uiName)
{
string $controlsSet="ControlSet";
string $fitSkeleton="FitSkeleton";
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	{
	$controlsSet="FaceControlSet";
	$fitSkeleton="FaceFitSkeleton";
	$buildPose="faceBuildPose";
	}
string $controlSetMembers[]=`sets -q $controlsSet`;
string $objAttr,$runCmd,$buildPoseCmd,$newRunCmds;
float $poseValue,$currentValue;
float $runValues[];
string $tempString[],$tempString2[],$runObjAttrs[],$checkObjAttr[];
if (`objExists $fitSkeleton`)
	if (`attributeExists run $fitSkeleton`)
		{
		$runCmd=`getAttr ($fitSkeleton+".run")`;
		$runCmd=`substituteAllString $runCmd "\"" ""`;
		}
if ($runCmd!="")
	tokenize $runCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
	$runValues[size($runValues)]=$tempString2[2];
	}

$buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	int $loopTimes=0;
	if ($tempString2[0]=="setAttr")
		{
		$objAttr=$tempString2[1];
		$poseValue=$tempString2[2];
		$loopTimes=1;
		$checkObjAttr[0]=$objAttr;
		}
	else if ($tempString2[0]=="xform")
		{
		$loopTimes=9;
		$obj=$tempString2[size($tempString2)-1];
		$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
		$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
		$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
		$poseValue=0;
		}
	for ($z=0;$z<$loopTimes;$z++)
		{
		$currentValue=`getAttr $checkObjAttr[$z]`;
		if($z>5) $poseValue=1;//scale
		//actual poseValue might come from the run attribute//
		for ($y=0;$y<size($runObjAttrs);$y++)
			if ($checkObjAttr[$z]==$runObjAttrs[$y])
				$poseValue=$runValues[$y];

		if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
			$newRunCmds+="setAttr "+$checkObjAttr[$z]+" "+$currentValue+";";
		}
	}

if ($newRunCmds=="")
	{
	print "// No changes to the build pose detected\n";
	return;
	}

string $m="Set the following as default values ?\n\n"+`substituteAllString $newRunCmds ";" "\n"`;
string $confirmResult=`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Ok")
	return;
if (!`attributeExists run $fitSkeleton`)
	addAttr -ln run -dt "string" $fitSkeleton;
setAttr -type "string" ($fitSkeleton+".run") ($runCmd+";"+$newRunCmds);
}

global proc asfileBrowse (string $tool, string $action)
{
string $fc,$ft;
int $mode=0;
if ($action=="Open")
	{
	$fc="asOpen "+$tool;
	$ft="mel";
	}
if ($action=="SaveAs")
	{
	$fc="asSaveAs "+$tool;
	$ft="mel";
	$mode=1;
	}
if ($action=="Import")
	{
	$fc="as"+$tool+"BackgroundImport";
	$ft="*";
	}
if (`asMayaVersionAsFloat`>=2011)
	eval ($fc+" \""+`fileDialog -dm ("*."+$ft) -m $mode`+"\" "+"fileType");
else
	{
	if (`about -win`)
		fileBrowserDialog -m $mode -fc $fc -ft $ft -an $action;
	else
		fileBrowser $fc $action $ft $mode;
	}
}

global proc astoShelf (string $tool)
{
global string $gShelfTopLevel;
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
if ($projectName=="untitled")
	error "Can not put \"untitled\" on shelf, save your project first\n";

string $cmd="source \""+$projectPath+$projectName+".mel\";";
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -mac`)
	$ext=".iff";
$icon=$projectPath+$projectName+"/"+$projectName+"_background32"+$ext;
string $setParent=`setParent -q`;
if (`tabLayout -exists $gShelfTopLevel`)
	{
	string $currentShelf=`tabLayout -query -selectTab $gShelfTopLevel`;
	setParent $currentShelf;
	shelfButton -c $cmd -ann ($tool+":"+$projectName) -label ($tool+":"+$projectName) -i1 $icon
		-st`shelfLayout -query -style $currentShelf`
		-width `shelfLayout -query -cellWidth $currentShelf`
		-height `shelfLayout -query -cellHeight $currentShelf`;
	}
setParent $setParent;
}

global proc string asUniqueFile (string $file)
{
// Copies given file to a random named file, to avoid fileNode cache
string $buffer[];
int $numTok=`tokenize $file "/" $buffer`;
string $path="";
if (`gmatch $file "/*"`)
	$path="/";
for ($i=0;$i<($numTok-1);$i++)
	$path+=$buffer[$i]+"/";
$numTok=`tokenize $file "." $buffer`;
string $ext=$buffer[$numTok-1];
string $randNumber=`rand 42`;
string $uniqueFile=$path+"unique"+`substituteAllString $randNumber "." ""`+"."+$ext;
sysFile -cp $uniqueFile $file;
return $uniqueFile;
}

global proc string[] asGetControlSets ()
{
string $controlSets[];
string $sets[]=`ls -type objectSet`;
for ($i=0;$i<size($sets);$i++)
	{
	if (!`sets -q -r $sets[$i]` && !`sets -q -v $sets[$i]` && !`sets -q -eg $sets[$i]` && !`sets -q -fc $sets[$i]` && !`sets -q -ep $sets[$i]`)
		if (`gmatch $sets[$i] "*[c-C]ontrol[s-S]et*"`)
			$controlSets[size($controlSets)]=$sets[$i];
	}
return $controlSets;
}

//-- AS IO Procedures (for tools) Starts Here --//
global proc int asOpen (string $tool, string $fileName, string $fileType)
{
global int $asfileLoading;
string $sel[]=`ls -sl`;
select -cl;
string $projectName=`basename $fileName ".mel"`;
string $projectPath=`dirname $fileName`+"/";
string $asIconLocation=$projectPath+$projectName+"/";
int $anim;
string $bgExt=".tga";
if (`about -mac`)
	$bgExt=".iff";

if ($tool=="Poser")
	asPoserDesigner;

evalEcho ("source \""+$fileName+"\";\n"
	+"as"+$tool+$projectName);
window -e -i 1 ("as"+$tool+$projectName);

if ($tool=="Poser")
	{
	$asfileLoading=1;
	string $gridOrder[]=`gridLayout -q -go ("asPoser"+$projectName+"GridLayout")`;
	int $nc=`gridLayout -q -nc ("asPoser"+$projectName+"GridLayout")`;
	int $nr=`gridLayout -q -nr ("asPoser"+$projectName+"GridLayout")`;
	intField -e -v $nc asPoserNc;
	intField -e -v $nr asPoserNr;
	asPoserUpdateGrid;
	int $childNum,$lenght;
	string $uiName="asPoserDefault";
	string $loadData[];
	$loadData[0]=$uiName;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] ("asPoser"+$projectName+"ColumnLayout*")`)
			{
			$image=`iconTextButton -q -i ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$loadData[1]=$image;
//			$label=`iconTextButton -q -l ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$label=`text -q -l ("asPoser"+$projectName+"Text"+$childNum)`;
			$loadData[2]=$label;
			$cmd=`iconTextButton -q -c ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$cmd=`substitute ("asPoser"+$projectName)  ("\""+$cmd+"\"") $uiName`;
			$lenght=size($cmd);
			$loadData[3]=`substring $cmd 2 ($lenght-1)`;
			$loadData[4]=$childNum;
			$anim=0;
			if (!`gmatch $cmd "*asSetAttrs *"`)
				$anim=1;
			$loadData[5]=$anim;
			asNewPose $loadData $anim;
			}
		}
	}
if ($tool=="Selector")
	{
	asSelectorDesigner;
	$asfileLoading=1;
	
	window -e -w `window -q -w ("asSelector"+$projectName)` -h `window -q -h ("asSelector"+$projectName)` asSelectorDefault;
	asSelectorBackgroundImport ($asIconLocation+$projectName+"_background"+$bgExt) "image";
	
	int $width,$height,$msg0AsInt,$msg1AsInt;
	string $iol;
	string $buffer[],$msgs[];
	//restore controlSets
	string $controlSetsText,$controlSets[];
	if (`text -q -ex ("asSelector"+$projectName+"ControlSetsText")`)
		{
		$controlSetsText=`text -q -l ("asSelector"+$projectName+"ControlSetsText")`;
		$controlSets=`stringToStringArray $controlSetsText " "`;
		if (`menuItem -q -ex ControlSet`)
			menuItem -e -cb 0 ControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if (`menuItem -q -ex $controlSets[$i]`)
				menuItem -e -cb 1 $controlSets[$i];
		}

	string $ctls[]=`formLayout -q -ca ("asSelector"+$projectName+"FormLayout")`;
	int $mirrorButtons=`optionVar -q asSelectorMirrorButtons`;
	optionVar -iv asSelectorMirrorButtons 0;
	for ($ctl in $ctls)
		if (`iconTextButton -q -ex $ctl` && !`gmatch $ctl "*BGPicture"`)
			{
			tokenize $ctl ":" $buffer;
			$msg0AsInt=$msgs[0]=$buffer[size($buffer)-2];
			$msg1AsInt=$msgs[1]=$buffer[size($buffer)-1];
			$width=`iconTextButton -q -w $ctl`;
			$height=`iconTextButton -q -h $ctl`;
			$iol=`iconTextButton -q -iol $ctl`;
			$cmd=`iconTextButton -q -c $ctl`;
			$cmd=`substitute ("\""+$projectName+"\"") (""+$cmd) "\"Default\""`;
			$buttonName=`substitute $projectName $ctl ""`;
			$ann=`iconTextButton -q -ann $ctl`;
			$msgs[2]=$iol;
			$msgs[3]=$cmd;
			$msgs[4]=$buttonName;
			$msgs[6]=$ann;
			renameUI $ctl ("deleteMeUI"+$ctl);
			asSelectorDpc "asSelectorBGImage"  "asSelectorBGImage" $msgs ($msg0AsInt+$width-4) ($msg1AsInt+$height-5) 2;
			}
	optionVar -iv asSelectorMirrorButtons $mirrorButtons;
	evalDeferred -lp asSelectorRefresh;
	}

//evalDeferred ("deleteUI as"+$tool+$projectName);
text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");
$asfileLoading=0;
select $sel;

return 1;
}

global proc int asSaveAs (string $tool, string $fileName, string $fileType)
{
if ($fileName=="")
	return 0;
string $sel[]=`ls -sl`;
string $projectName;
string $buffer[];
int $numFileNameChar=size ($fileName);
tokenize $fileName "/" $buffer;
string $file=$buffer[size($buffer)-1];
int $numFileChar=size ($file);
tokenize $file "." $buffer;
$projectName=$buffer[0];
string $tempTrn=`createNode transform`;
$projectName=`createNode -p $tempTrn -n $projectName transform`;
delete $tempTrn;
tokenize $projectName "|" $buffer;
$projectName=$buffer[size($buffer)-1];
string $projectPath=`substring $fileName 1 ($numFileNameChar-$numFileChar)`;

string $previousProjectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $previousProjectName=`text -q -l ("as"+$tool+"ProjectName")`;

text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
asSave $tool;

select $sel;
return 1;
}

global proc asSave (string $tool)
{
if (`text -q -l ("as"+$tool+"ProjectName")`=="untitled")
	{
	asfileBrowse $tool "SaveAs";
	return;
	}
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
string $projectFile=$projectPath+$projectName+".mel";
string $installFile=$projectPath+$projectName+"/install.mel";
string $asIconLocation=$projectPath+$projectName+"/";
string $ext=".xpm";
string $bgExt=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=$bgExt=".png";
if (`about -linux`)
	$ext=".xpm";
string $tmpDir=`internalVar -utd`;
string $tmpIconDir=$tmpDir+"AdvancedSkeleton/"+$tool+"/untitled/";
string $uiName="as"+$tool+$projectName;
string $bgc;
string $buffer[];
string $fDet="";
$fDet+="//This file has been generated by AdvancedSkeleton"+$tool+"//\n";
$fDet+="//Using AdvancedSkeleton Version: "+`asGetScriptVersion`+"//\n";
$fDet+="\n";
$fDet+="global proc "+$uiName+" ()\n";
$fDet+="{\n";
$fDet+="if (`window -q -ex "+$uiName+"`)\n";
$fDet+="\tdeleteUI "+$uiName+";\n";
$fDet+="\n";
$fDet+="string $asSelectorScriptLocation=`asSelectorScriptLocation`;\n";
$fDet+="string $asIconLocation=$asSelectorScriptLocation+\""+$projectName+"/\";\n";
$fDet+="window -rtf 1 -mb 1 -t "+$projectName+" "+$uiName+";\n";
$fDet+="menu -l Edit;\n";
$fDet+="\tmenuItem -l Refresh -c \"asPopulateNameSpaceMenu "+$uiName+"\";\n";
$fDet+="\tmenuItem -l Filter -c \"asFilterNameSpaceMenuUI "+$uiName+"\";\n";
$fDet+="\tsetParent..;\n";
if ($tool=="Selector")
	{
	$fDet+="menu -l Display;\n";
	$fDet+="\tmenuItem -l Controls -c asControlsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l \"Set HotKey\" -c asSetupControlVisibilityHotKeyDialog;\n";
	$fDet+="\tmenuItem -l Joints -c asJointsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l GimbalLock -c \"asVisualizeGimbalLock "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Pose -aob 1;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"PosePaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Reset -c \"asGoToBuildPose "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l Mirror -c \"asMirror "+$uiName+"\";\n";
	$fDet+="\tmenuItem -optionBox 1 -c \"asMirrorOptions "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Anim;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 1\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"AnimPaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Clean -c \"asDeleteStaticChannels "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asAnimBake "+$uiName+"\";\n";
	$fDet+="menu -l Dynamics;\n";
	$fDet+="\tmenuItem -l \"Add to selected\" -c \"asDynAdd "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Remove from selected\" -c \"asDynRemove "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Set Initial State\" -c \"evalEcho saveInitialState -all\";\n";
	$fDet+="\tmenuItem -l \"Interactive Playback\" -c \"evalEcho InteractivePlayback\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asDynBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l UnBake -c \"asDynUnBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	}
$fDet+="\n";

//controlsets
string $controlSetsText;
string $menuItems[];
if (`menu -q -ex ("as"+$tool+"ControlSetsMenu")`)
	{
	$menuItems=`menu -q -ia ("as"+$tool+"ControlSetsMenu")`;
	for ($i=0;$i<size($menuItems);$i++)
		if (`menuItem -q -cb $menuItems[$i]`)
			$controlSetsText+=$menuItems[$i]+" ";
	}

//remove old files & copy files from `untitled`
string $fileList[];
if (`file -q -ex ($projectPath+$projectName)`)
	{
	$fileList=`getFileList -fld ($projectPath+$projectName+"/")`;
	for ($file in $fileList)
		sysFile -del ($projectPath+$projectName+"/"+$file);
	}
else
	sysFile -md ($projectPath+$projectName);
$fileList=`getFileList -fld $tmpIconDir`;
for ($file in $fileList)
	if (!`gmatch $file "*.tif"`)
		sysFile -cp ($projectPath+$projectName+"/"+`substitute ("untitled_") $file ($projectName+"_")`) ($tmpIconDir+$file);

window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");

if ($tool=="Poser")
	{
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="optionMenu -cc \"asCharChange "+$uiName+"\" "+$uiName+"OptionMenu;\n";
	$fDet+="scrollLayout "+$uiName+"ScrollLayout;\n";
	int $cw=`gridLayout -q -cw asPoserDefaultGridLayout`;
	int $ch=`gridLayout -q -ch asPoserDefaultGridLayout`;
	int $nc=`intField -q -v asPoserNc`;
	int $nr=`intField -q -v asPoserNr`;
	$fDet+="gridLayout -cw "+$cw+" -ch "+$ch+" -nc "+$nc+" -nr "+$nr+" "+$uiName+"GridLayout;\n";


	$fDet+="formLayout -e\n";
	$fDet+="	-af "+$uiName+"OptionMenu \"top\" 0\n";
	$fDet+="	-ac "+$uiName+"ScrollLayout \"top\" 0 "+$uiName+"OptionMenu\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"bottom\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"left\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"right\" 0\n";
	$fDet+="	"+$uiName+"FormLayout;\n";
	$fDet+="\n";
	$fDet+="\n";

	string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
	int $childNum,$doConnectControl;
	string $cmd,$label,$ann,$animAnn;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] "asPoser*"`)
			{
			$iconTextButton=("asPoserDefaultIconTextButton"+$childNum);
			$floatSlider=("asPoserDefaultFloatSlider"+$childNum);
			$text=("asPoserDefaultText"+$childNum);
			$label=`text -q -l $text`;
			$doConnectControl=`floatSlider -q -m $floatSlider`;
			$ann=`floatSlider -q -ann $floatSlider`;
			$cmd=`iconTextButton -q -c $iconTextButton`;
			$cmd=`substitute  "asPoserDefault" $cmd $uiName`;
			$cmd=`substitute  "untitled_" $cmd ($projectName+"_")`;
			$cmd=`encodeString $cmd`;
			$bgc="";
			if (!`gmatch $cmd "asSetAttrs *"`)
				$bgc=" -bgc 1 0 0";
			$fDet+="string $cmd=\""+$cmd+"\";\n";
			$image=`iconTextButton -q -i $iconTextButton`;
			tokenize ("\""+$image+"\"") "/" $buffer;
			tokenize $buffer[size($buffer)-1] "." $buffer;
			$imageNr=`match "[0-9]+$" $buffer[0]`;
			$animAnn=`rowColumnLayout -q -ann ("asPoserDefaultRowColumnLayout"+$childNum)`;

			$fDet+="setParent "+$uiName+"GridLayout;\n";
			$fDet+="columnLayout "+$uiName+"ColumnLayout"+$childNum+";\n";
			$fDet+="rowColumnLayout -ann "+$animAnn+" -nc 2 -cw 1 100 -cw 2 15 "+$uiName+"RowColumnLayout"+$childNum+";\n";
			$fDet+="iconTextButton -w 100 -h 75 -i ($asIconLocation+\""+$projectName+"_"+$imageNr+$ext+"\") -c $cmd "+$uiName+"IconTextButton"+$childNum+";\n";
			float $min=`floatSlider -q -min $floatSlider`;
			float $max=`floatSlider -q -max $floatSlider`;
			$fDet+="floatSlider -ann \""+$ann+"\" -m "+$doConnectControl+" -min "+$min+" -max "+$max+" -w 10 -h 75 -hr 0 "+$uiName+"FloatSlider"+$childNum+";\n";
			$fDet+="text -h 15 -al \"center\" -fn \"smallBoldLabelFont\" -l \""+$label+"\""+$bgc+" "+$uiName+"Text"+$childNum+";\n";

			//place it
			$fDet+="gridLayout -e -pos "+$uiName+"ColumnLayout"+$childNum+" "+$childNum+" "+$uiName+"GridLayout;\n";

			//popups
			$fDet+="asPoserupdateGridBlock "+$uiName+" "+$childNum+";\n";

			$fDet+="\n";
			}
		}

	$fDet+="\n";
	$fDet+="asPopulateNameSpaceMenu as"+$tool+$projectName+";\n";
	$fDet+="asCharChange "+$uiName+";\n";
	$fDet+="evalDeferred \"showWindow;\";\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}
if ($tool=="Selector")
	{
	int $pictureWidth=`text -q -l asSelectorBackgroundWidth`;
	int $pictureHeight=`text -q -l asSelectorBackgroundHeight`;
	
	string $allCtls[]=`formLayout -q -ca asSelectorDefaultFormLayout`;
	string $ctlName[],$ctlType[],$ctlWidth[],$ctlHeight[],$ctlLeft[],$ctlTop[],$ctlImage[],$ctlCmd[],$ctlIol[],$ctlAnn[];
	string $ctlKeyCmd[],$ctlLinearKeyCmd[];
	string $ctlAlignFK2IKCmd[],$ctlAlignIK2FKCmd[],$ctlSwitchFK2IKCmd[],$ctlSwitchIK2FKCmd[];
	string $buffer[],$tempString[],$menuItems[];
	int $numTok;
	string $shortImageFileName,$oldProjectName;
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$ctlName[$i]=`substitute "asSelector" $allCtls[$i] $uiName`;
		if (`image -q -ex $allCtls[$i]`)
			$ctlType[$i]="image";
		if (`iconTextButton -q -ex $allCtls[$i]`)
			$ctlType[$i]="iconTextButton";
		$ctlWidth[$i]=`control -q -w $allCtls[$i]`;
		$ctlHeight[$i]=`control -q -h $allCtls[$i]`;
		$numTok=`tokenize $allCtls[$i] ":" $buffer`;
		$ctlLeft[$i]=$buffer[$numTok-2];
		$ctlTop[$i]=$buffer[$numTok-1];
		if ($ctlType[$i]=="iconTextButton")
			{
			$ctlImage[$i]=`eval ($ctlType[$i]+" -q -i \""+$allCtls[$i]+"\"")`;
			tokenize $ctlImage[$i] "/" $buffer;
			$shortImageFileName=$buffer[size($buffer)-1];
			tokenize $shortImageFileName "_" $buffer;
			$oldProjectName=$buffer[0];
			for ($b=1;$b<size($buffer)-3;$b++)
				$oldProjectName+="_"+$buffer[$b];
			$ctlImage[$i]=`substitute ($oldProjectName+"_") $shortImageFileName ($projectName+"_")`;
			$ctlCmd[$i]=`eval ($ctlType[$i]+" -q -c \""+$allCtls[$i]+"\"")`;
			$ctlCmd[$i]=`substitute "\"Default\"" $ctlCmd[$i] ("\""+$projectName+"\"")`;
			$ctlCmd[$i]="\""+`encodeString $ctlCmd[$i]`+"\"";
			$ctlAnn[$i]=`eval ($ctlType[$i]+" -q -ann \""+$allCtls[$i]+"\"")`;
			$ctlIol[$i]=`eval ($ctlType[$i]+" -q -iol \""+$allCtls[$i]+"\"")`;
			$tempString=`eval ($ctlType[$i]+" -q -pma \""+$allCtls[$i]+"\"")`;
			$menuItems=`popupMenu -q -ia $tempString[0]`;
			$ctlKeyCmd[$i]=`menuItem -q -c $menuItems[0]`;
			$ctlKeyCmd[$i]=`substitute "\"Default\"" $ctlKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlKeyCmd[$i]="\""+`encodeString $ctlKeyCmd[$i]`+"\"";
			$ctlLinearKeyCmd[$i]=`menuItem -q -c $menuItems[1]`;
			$ctlLinearKeyCmd[$i]=`substitute "\"Default\"" $ctlLinearKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlLinearKeyCmd[$i]="\""+`encodeString $ctlLinearKeyCmd[$i]`+"\"";
			if (size($menuItems)>6)
				{
				$subMenuItems=`menu -q -ia $menuItems[6]`;
				$ctlAlignFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlAlignFK2IKCmd[$i]=`substitute "\"Default\"" $ctlAlignFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignFK2IKCmd[$i]="\""+`encodeString $ctlAlignFK2IKCmd[$i]`+"\"";
				$ctlAlignIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlAlignIK2FKCmd[$i]=`substitute "\"Default\"" $ctlAlignIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignIK2FKCmd[$i]="\""+`encodeString $ctlAlignIK2FKCmd[$i]`+"\"";
				$subMenuItems=`menu -q -ia $menuItems[7]`;
				$ctlSwitchFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlSwitchFK2IKCmd[$i]=`substitute "\"Default\"" $ctlSwitchFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchFK2IKCmd[$i]="\""+`encodeString $ctlSwitchFK2IKCmd[$i]`+"\"";
				$ctlSwitchIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlSwitchIK2FKCmd[$i]=`substitute "\"Default\"" $ctlSwitchIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchIK2FKCmd[$i]="\""+`encodeString $ctlSwitchIK2FKCmd[$i]`+"\"";
				}
			}
		}

	$fDet+="columnLayout -adj 1;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="rowLayout -nc 4 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 80 -cw 4 60;\n";
	$fDet+="optionMenu -cc asSelChange "+$uiName+"OptionMenu;\n";
	$fDet+="button -l set -c \"asSetNameSpaceFromSelection "+$uiName+"\";\n";
	$fDet+="checkBox -v `optionVar -q asShowSelection` -onc \"asSelChangeToggle;optionVar -iv asShowSelection 1\" -ofc \"asSelChangeToggle;optionVar -iv asShowSelection 0\" -l Selection "+$uiName+"SelectionCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowKeyed` -onc \"asSelChangeToggle;optionVar -iv asShowKeyed 1\" -ofc \"asSelChangeToggle;optionVar -iv asShowKeyed 0\" -l Keyed "+$uiName+"KeyedCheckBox;\n";
	$fDet+="setParent..;\n";
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="\n";

	$fDet+="//Controls Begin//\n";
	if (`about -mac` || `about -linux`)
		$fDet+="iconTextButton -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	else
		$fDet+="image -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+=$ctlType[$i]+" -w "+$ctlWidth[$i]+" -h "+$ctlHeight[$i];
		if ($ctlImage[$i]!="")
			$fDet+=" -i ($asIconLocation+\""+$ctlImage[$i]+"\")";
		if ($ctlImage[$i]!="")
			$fDet+=" -iol \""+$ctlIol[$i]+"\"";
		if ($ctlCmd[$i]!="")
			$fDet+=" -c "+$ctlCmd[$i];
		if ($ctlAnn[$i]!="")
			$fDet+=" -ann \""+$ctlAnn[$i]+"\"";
		$fDet+=" \""+$ctlName[$i]+"\";\n";
		$fDet+="popupMenu;\n";
		$fDet+="\tmenuItem -l Key -c "+$ctlKeyCmd[$i]+";\n";
		$fDet+="\tmenuItem -l LinearKey -c "+$ctlLinearKeyCmd[$i]+";\n";
		if ($ctlAlignFK2IKCmd[$i]!="")
			{
			$fDet+="\tmenuItem -d 1;\n";
			$fDet+="\tmenuItem -l Align -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlAlignFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlAlignIK2FKCmd[$i]+";\n";
			$fDet+="\t\tsetParent -menu ..;\n";
			$fDet+="\tmenuItem -l Switch -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlSwitchFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlSwitchIK2FKCmd[$i]+";\n";
			}
		}
	$fDet+="//Controls End//\n";
	$fDet+="\n";
	$fDet+="formLayout -e\n";
	for ($i=0;$i<size($ctlType);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+="\t-af \""+$ctlName[$i]+"\" left "+$ctlLeft[$i]+"\n";
		$fDet+="\t-af \""+$ctlName[$i]+"\" top "+$ctlTop[$i]+"\n";
		}
	$fDet+="\t"+$uiName+"FormLayout;\n";
	
	$fDet+="\n\n\n\n";
	
	$fDet+="asPopulateNameSpaceMenu \"asSelector"+$projectName+"\";\n";
	$fDet+="asShowSelJob;\n";
	$fDet+="asSelChange;\n";
	$fDet+="showWindow;\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}

string $AdvancedSkeleton5File=`asGetScriptLocation`+"/AdvancedSkeleton5.mel";
int $fileId2=`fopen $AdvancedSkeleton5File "r"`;
string $nextLine = `fgetline $fileId2`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId2`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId2;

int $fileId=`fopen $projectFile "w"`;
fprint $fileId $fDet;
fclose $fileId;

//$installFile
$fDet="";
string $AdvancedSkeletonInstallFile=`asGetScriptLocation`+"/install.mel";
if (!`file -q -ex $AdvancedSkeletonInstallFile`)
	return;
$fileId=`fopen $AdvancedSkeletonInstallFile "r"`;
$nextLine = `fgetline $fileId`;
int $installTemplatePause;
while ( size( $nextLine ) > 0 )
	{
	$nextLine = `fgetline $fileId`;
	if ($nextLine=="//--installTemplate pause--//\n")
		$installTemplatePause=1;
	if ($nextLine=="//--installTemplate resume--//\n")
		{
		$installTemplatePause=0;
		continue;
		}
	if ($installTemplatePause)
		continue;
	if (`gmatch $nextLine "string $scriptName=*"`)
		{
		$fDet+=("string $scriptName=\""+$projectName+"\";\n");
		}
	else if (`gmatch $nextLine "string $sourceFile=*"`)
		{
		$fDet+=("string $sourceFile=$asInstallScriptLocation+\"../\"+$scriptName+\".mel\";\n");
		}
	else if (`gmatch $nextLine "string $icon=*"`)
		{
		$fDet+=("string $icon=$asInstallScriptLocation+\""+$projectName+"_background32.png\";\n");
		}
	else if (`gmatch $nextLine "string $command=*"`)
		{
		$fDet+=("string $command=\"source \\\"\"+$sourceFile+\"\\\"\";\n");
		}
	else
		$fDet+=$nextLine;
	}
fclose $fileId;

$fileId=`fopen $installFile "w"`;
fprint $fileId $fDet;
fclose $fileId;
}
//-- AS IO Procedures (for tools) Ends Here --//


//-- ASTools Procedures Starts Here --//
global proc asSelChange ()
{
global int $asfileLoading;
global int $asSelChangeSwitching;
if ($asfileLoading)
	return;
if (!`optionVar -q asShowSelection` && !`optionVar -q asShowKeyed`)
	return;
string $sel[]=`ls -sl`;
string $name,$obj,$nodeType,$projectName,$ann;
string $ctls[],$buffer[],$connections[];
int $numLetters,$numTok,$keyed;
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -mac`)
	$ext=".iff";
if (`about -linux`)
	$ext=".xpm";
string $currImage,$buttonImageFile,$buttonImageFileOnK0,$buttonImageFileOnK1,$buttonImageFileOffK0,$buttonImageFileOffK1;
string $windows[]=`lsUI -windows`;
string $layout;
for ($window in $windows)
	{
	$layout="";
	if (size($window)>11)
		$layout="asSelector"+`substring $window 11 999`+"FormLayout";
	if (!`formLayout -q -ex $layout`)
		continue;
	$numLetters=size($layout);
	$name=`substring $layout 11 ($numLetters-10)`;
	$ctls=`formLayout -q -ca $layout`;
	for ($ctl in $ctls)
		{
		if (!`iconTextButton -q -ex $ctl`)
			continue;
		if (`optionVar -q asShowSelection` && !$asSelChangeSwitching)
			$selState="On";
		else
			$selState="Off";
		$keyed=0;
		$ann=`iconTextButton -q -ann $ctl`;
		$numTok=`tokenize $ann ";" $buffer`;
		for ($i=0;$i<$numTok;$i++)
			{
			$obj=`asSelectorResolveNameSpace $name $buffer[$i]`;
			if (!`stringArrayCount $obj $sel`)
				$selState="Off";
			if (`optionVar -q asShowKeyed` && !$asSelChangeSwitching && `objExists $obj`)
				{
				$connections=`listConnections -s 1 -d 0 $obj`;
				for ($node in $connections)
					{
					$nodeType=`objectType $node`;
					if (`gmatch $nodeType "animCurve*"`)
						$keyed=1;
					}
				}
			}

		$currImage=`iconTextButton -q -i1 $ctl`;
		if ($currImage=="")
			return;
		$numTok=`tokenize $currImage "_" $buffer`;
		$projectName=$buffer[0];
		for ($b=1;$b<size($buffer)-3;$b++)
			$projectName+="_"+$buffer[$b];
		$buttonImageFile=$projectName+"_"+$buffer[$numTok-3]+"_"+$buffer[$numTok-2]+"_"+$selState+"K"+$keyed+$ext;

		if ($buttonImageFile!=$currImage)
			iconTextButton -e -i $buttonImageFile $ctl;		
		}
	}
}

global proc float asMayaVersionAsFloat ()
{
float $version=2012;
if (`exists getApplicationVersionAsFloat`)
	return `getApplicationVersionAsFloat`;
string $versionString=`about -v`;
string $tempString[];
string $char;
tokenize $versionString $tempString;
//default to 2012, if versionString is not all numbers
for ($i=0;$i<size($tempString[0]);$i++)
	{
	$char=`substring $tempString[0] ($i+1) ($i+1)`;
	if (!`gmatch $char "[0-9]"`)
		return 2012;
	}
$version=$tempString[0];
return $version;
}

global proc asSelChangeToggle ()
{
global int $asSelChangeSwitching;
$asSelChangeSwitching=1;
string $sel[]=`ls -sl`;
select -cl;
asSelChange;
$asSelChangeSwitching=0;
select $sel;
}

global proc asCharChange (string $uiName)
{
string $gridOrder[];
if (`gridLayout -q -ex ($uiName+"GridLayout")`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`floatSlider -q -ex ($uiName+"FloatSlider"+$i)`)
			{
			$ann=`floatSlider -q -ann ($uiName+"FloatSlider"+$i)`;
			$resolvedName=`asPoserResolveNameSpace $uiName $ann`;
			if (`objExists $resolvedName`)
				connectControl ($uiName+"FloatSlider"+$i) $resolvedName;
			}
	}
asSelChange;
}

global proc asShowSelJob ()
{
global int $asSelChangeScripJobNr;
if ($asSelChangeScripJobNr)
	return;
$asSelChangeScripJobNr=`scriptJob -e "SelectionChanged" "asSelChange"`;
}

global proc string asSelectorResolveNameSpace (string $name, string $obj)
{
string $nameSpace=`optionMenu -q -v ("asSelector"+$name+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asSelect (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

int $modifier=`getModifiers`;
if (($modifier %  2)==0)
	select -cl;
if ($objs[0]=="")
	{
	select -cl;
	return;
	}
for ($obj in $objs)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
for ($obj in $objs)
	select -tgl $obj;		
}

global proc asKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe $obj;
select `ls -sl`;
asSelChange;
}

global proc asLinearKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe -itt linear -ott linear $obj;
select `ls -sl`;
asSelChange;
}

global proc asAlignIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "IK2FK";
}

global proc asAlignFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "FK2IK";
}

global proc asSwitchIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "IK2FK";
}

global proc asSwitchFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "FK2IK";
}

global proc asAssembleAlignSwitchCmd (string $name, string $objs[], string $alignSwitchCmd, string $W2K)
{
int $numLetters=size($objs[0]);
string $IK=`substring $objs[0] 5 ($numLetters-2)`;
string $side=`substring $objs[0] ($numLetters-1) $numLetters`;
eval ($alignSwitchCmd+" "+$name+" "+$IK+" "+$side+" "+$W2K);
}

global proc asAlignFKIK (string $name, string $IK, string $side, string $W2K)
{
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $tempLoc1[],$tempLoc2[],$tempConstraint[];
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$endJoint+$side),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"FKX"+$endJoint+$side),
	($nameSpace+"Pole"+$IK+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
float $charsize=`getAttr ($nameSpace+"Main.height")`;
float $tempFloat[],$alignIkToFloat[];
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;

if ($W2K=="FK2IK")
	{
	$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$endJoint+$side)`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	$tempLoc1=`spaceLocator`;
	$tempConstraint=`pointConstraint ($nameSpace+"FKX"+$startJoint+$side) ($nameSpace+"FKX"+$endJoint+$side) $tempLoc1[0]`;
	delete $tempConstraint[0];
	$tempConstraint=`aimConstraint -aimVector 1 0 0 ($nameSpace+"FKX"+$middleJoint+$side) $tempLoc1[0]`;
	$tempLoc2=`spaceLocator`;
	parent $tempLoc2[0] $tempLoc1[0];
	setAttr -type float3 ($tempLoc2[0]+".translate") ($charsize/3.333) 0 0;
	$tempFloat=`xform -q -ws -t $tempLoc2[0]`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"Pole"+$IK+$side);
	delete $tempLoc1;
	$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
			setAttr ($nameSpace+"IK"+$IK+$side+".roll") 0;
	}
else
	{
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$startJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$startJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$middleJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$middleJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$endJoint+$side);
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		{
		$tempFloat=`xform -q -ws -ro ($nameSpace+"IKXToes"+$side)`;
		xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FKToes"+$side);
		}
	}

if ($autoKey)
	autoKeyframe -st 1;
select $sel;
}

global proc asSwitchFKIK (string $name, string $IK, string $side, string $W2K)
{
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
string $poleCurve=$nameSpace+"Pole"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$endJoint+$side),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"FKX"+$endJoint+$side),
	($nameSpace+"Pole"+$IK+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
int $Blend;
int $BlendInverse=10;
int $onOff;
if ($W2K=="FK2IK")
	{
	$Blend=10;
	$BlendInverse=0;
	$onOff=1;
	}

if ($W2K=="FK2IK" && `getAttr ($controlCurve+".FKIKBlend")`>0)
	{
	warning ("Could not switch FK2IK, because \"FKIKBlend\" is not \"0\"\n");
	return;
	}
if ($W2K=="IK2FK" && `getAttr ($controlCurve+".FKIKBlend")`<10)
	{
	warning ("Could not switch IK2FK, because \"FKIKBlend\" is not \"10\"\n");
	return;
	}

int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;

currentTime (`currentTime -q` -1);
setAttr ($controlCurve+".FKIKBlend") $BlendInverse;
setKeyframe ($controlCurve+".FKIKBlend");
setKeyframe ($poleCurve+".follow");	

setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");

if (`objExists ($nameSpace+"IKXToes"+$side)`)
	{
	setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
	if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
		setKeyframe ($nameSpace+"IK"+$IK+$side+".roll");
	}

currentTime (`currentTime -q` +1);


asAlignFKIK $name $IK $side $W2K;


setAttr ($controlCurve+".FKIKBlend") $Blend;
setAttr ($poleCurve+".follow") 0;

setKeyframe ($controlCurve+".FKIKBlend");
setKeyframe ($poleCurve+".follow");

setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");
if (`objExists ($nameSpace+"IKXToes"+$side)`)
	{
	setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
	if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
		setKeyframe ($nameSpace+"IK"+$IK+$side+".roll");
	}

if ($autoKey)
	autoKeyframe -st 1;
select $sel;
}

global proc asPopulateNameSpaceMenu (string $name)
{
string $optionMenu=$name+"OptionMenu";
string $nameSpacesList[]=`namespaceInfo -lon`;
$nameSpacesList=`stringArrayRemove {"UI"} $nameSpacesList`;
$nameSpacesList[size($nameSpacesList)]="";
string $itemList[]=`optionMenu -q -ils $optionMenu`;
$nameSpacesList=`sort $nameSpacesList`;
for ($item in $itemList)
	deleteUI $item;

for ($nameSpace in $nameSpacesList)
	if (`objExists ($nameSpace+":Main")`)
		if (`attributeExists "version" ($nameSpace+":Main")`)
			if (`asFilterCheck $name $nameSpace`)
				menuItem -p $optionMenu -l ($nameSpace+":");

if (!`optionMenu -q -ni ($name+"OptionMenu")`)
	{
	if ($name=="bodySetup" || `gmatch $name "asPoser*"`)
		menuItem -p $optionMenu -l "None";
	else
		menuItem -p $optionMenu -l ":";
	}
}

global proc int asFilterCheck (string $name, string $nameSpace)
{
int $result=0;
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="" || $filterString=="0")
	return 1;
string $references[]=`file -q -r`;
for ($i=0;$i<size($references);$i++)
	{
	$refNameSpace=`file -q -ns $references[$i]`;
	if ($refNameSpace==$nameSpace)
		if (`gmatch $references[$i] $filterString`)
			$result=1;
	}
return $result;
}

global proc asFilterNameSpaceMenuUI (string $name)
{
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="0")
	$filterString="";
if (`window -q -ex ("SelectorFilter_"+$name)`)
	deleteUI ("SelectorFilter_"+$name);
window ("SelectorFilter_"+$name);
columnLayout;
textFieldGrp -tx $filterString -cc ("asSetFilterNameSpaceMenu "+$name) -l "Reference File Filter. (e.g. *characters*)" -cw 1 200 ("asSelectorFilterTextFieldGrp_"+$name);
showWindow;
}

global proc asSetFilterNameSpaceMenu (string $name)
{
string $filterString=`textFieldGrp -q -tx ("asSelectorFilterTextFieldGrp_"+$name)`;
optionVar -sv ("asSelectorFilter_"+$name) $filterString;
asPopulateNameSpaceMenu $name;
}

global proc asSetNameSpaceFromSelection (string $uiName)
{
asPopulateNameSpaceMenu $uiName;
string $sel[]=`ls -sl`;
string $tempString[],$ils[];
if (size($sel))
	{
	tokenize $sel[0] ":" $tempString;
	$ils=`optionMenu -q -ils ($uiName+"OptionMenu")`;
	for ($i=0;$i<size($ils);$i++)
		if (`menuItem -q -l $ils[$i]`==($tempString[0]+":"))
			{
			optionMenu -e -sl ($i+1) ($uiName+"OptionMenu");
			asSelChange;
			}
	}
print "// Setting nameSpace from selected object\n";
}

global proc asCopyToClipBoard (string $uiName, int $anim)
{
string $cmd=`asPoserGetCmd $uiName $anim`;
if (!$anim)
	menuItem -e -en 1 -c $cmd ($uiName+"PosePaste");
else
	menuItem -e -en 1 -c ($cmd+" 0") ($uiName+"AnimPaste");
}

global proc string[] asGetControlSetsFromUI (string $uiName)
{
string $controlSets[];
string $tempString[];
string $controlSetsText;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (`text -q -ex ($uiName+"ControlSetsText")`)
	{
	$controlSetsText=`text -q -l ($uiName+"ControlSetsText")`;
	tokenize $controlSetsText $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists ($nameSpace+$tempString[$i])`)
			$controlSets[size($controlSets)]=$nameSpace+$tempString[$i];
	}
else if ($uiName=="asPoserDefault" && `menuItem -q -ex asPoserControlSetsMenu`)
	{
	$tempString=`menu -q -ia asPoserControlSetsMenu`;
	for ($i=0;$i<size($tempString);$i++)
		if (`menuItem -q -cb $tempString[$i]`)
			$controlSets[size($controlSets)]=$nameSpace+`menuItem -q -l $tempString[$i]`;
	}
else
	$controlSets[0]=$nameSpace+"ControlSet";

return $controlSets;
}

global proc asDeleteStaticChannels (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Clean animation ?\n"
	+"This will delete static channels,\n"
	+"which means remove all animation where the value is not changing")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
select $controlSets;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
print ("// Static channels cleaned\n");
select $sel;
}
	
global proc string asPoserGetCmd (string $uiName, int $anim)
{
global string $gChannelBoxName;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $selectedMainAttrs[]=`channelBox -q -sma $gChannelBoxName`;
string $selectedShapeAttrs[]=`channelBox -q -ssa $gChannelBoxName`;
string $selectedHistoryAttrs[]=`channelBox -q -sha $gChannelBoxName`;
string $selectedOutputAttrs[]=`channelBox -q -soa $gChannelBoxName`;
string $selectedAttrs[];
$selectedAttrs=`stringArrayCatenate $selectedMainAttrs $selectedShapeAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedHistoryAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedOutputAttrs`;
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
int $onlySel;
if ($uiName=="asPoserDefault")
	{
	if (`checkBox -q -ex asPoserOnlySel`)
		$onlySel=`checkBox -q -v asPoserOnlySel`;
	}
else if ($altButton || $ctrlButton)
	$onlySel=1;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $cmd;
string $controls[],$buffer[];
int $weightedTangents[];
int $onlyOneObj,$onlyOneAttr;
string $connectObj;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
if (!$onlySel && !size($controlSets))
	error "No ControlSets";

//determine the name for poserAnimFile
string $animationFile,$animationFilePath;
string $gridOrder[];
int $childNum;
if (`gmatch $uiName "asPoser*"`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`gmatch $gridOrder[$i-1] "asPoser*"`)
			$childNum=$i;
	$childNum++;

	$animationFile="untitled_"+$childNum;
	$animationFilePath=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
	}
else
	{
	$animationFile="ClipBoard";
	$animationFilePath=`internalVar -utd`+"AdvancedSkeleton/Selector/";
	}

string $animCurves[];

if ($onlySel)
	{
	for ($i=$y=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] ($nameSpace+"*")`)
			{
			tokenize $sel[$i] ":" $buffer;
			$controls[$y]=$buffer[size($buffer)-1];
			$y++;
			}
		}
	}
else
	{
	if (!`objExists $controlSets[0]`)
		error ("Object :\""+$controlSets[0]+"\" does not exists !\n");
	$controls=`sets -q $controlSets`;
	for ($i=0;$i<size($controls);$i++)
		$controls[$i]=`substitute  $nameSpace $controls[$i] ""`;
	}
string $attrs[];
if (size($controls)<1)
	error "No Controls Available!";
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Storing Data" -bp -ii 1 -min 0 -max (size($controls)) $gMainProgressBar;
select -cl;

if ($anim)
	{
	createNode -n poserAnimationInfo transform;
	addAttr -ln "cmd" -dt "string" poserAnimationInfo;
	select poserAnimationInfo;
	}

	{
for ($obj in $controls)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	$allKeyableAttrs=`listAttr -k -m -sn ($nameSpace+$obj)`;
	if ($onlySel && (size($selectedAttrs)>0))
		$attrs=$selectedAttrs;
	else
		$attrs=$allKeyableAttrs;
	for ($attr in $attrs)
		for ($allKeyableAttr in $allKeyableAttrs)
			if ($attr==$allKeyableAttr)
				{
				if (!$anim)
					$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+";";
				else
					{
					//Animation
					$animCurves=`listConnections -type animCurve -s 1 -d 0 ($nameSpace+$obj+"."+$attr)`;
					for ($y=0;$y<size($animCurves);$y++)
						{
						select -add $animCurves[$y];
						$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+" "+$animCurves[$y]+";";
						}
					}
				}
		}
	}

if ($anim)
	{
	setAttr -type "string" poserAnimationInfo.cmd $cmd;
	file -f -op "v=0" -typ "mayaAscii" -es ($animationFilePath+$animationFile+".ma");
	delete poserAnimationInfo;
	}

if ($cmd!="")
	{
	if (!$anim)
		$cmd="asSetAttrs "+$uiName+" \""+$cmd+"\"";
	else
		$cmd="asLoadAttrs "+$uiName;
	}

select $sel;
return $cmd;
}

global proc asSetAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[];
string $objAttr;
float $value;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";

for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asLoadAttrs (string $uiName, int $childNum)
{
string $sel[]=`ls -sl`;
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -e -st 0;
createNode -n tempXform transform;
int $shiftButton,$ctrlButton,$altButton;
if (`getModifiers` %  2)
	$shiftButton=1;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
float $timeOffset=0;
if ($shiftButton)
	$timeOffset=`currentTime -q`;
string $buffer[],$buffer2[],$buffer3[],$tempString[];
string $obj,$attr,$objAttr,$animCurve,$newAnimCurve;
float $value;

string $animationFile,$projectName;

if ($childNum==0)
	{
	$projectName="Selector";
	$animationFile=`internalVar -utd`+"AdvancedSkeleton/Selector/ClipBoard.ma";
	}
else
	{
	string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
	string $tempString[];
	tokenize $icon "/" $tempString;
	$projectName=$tempString[size($tempString)-2];
	$animationFile=`substitute "[.][a-z][a-z][a-z]" $icon ".ma"`;
	}
file -r -type "mayaAscii" -namespace $projectName -options "v=0;p=17" $animationFile;

string $cmds=`getAttr ($projectName+":poserAnimationInfo.cmd")`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	tokenize $objAttr "." $buffer3;
	$obj=$buffer3[0];
	$attr=$buffer3[1];
	$value=$buffer2[1];
	$animCurve=$buffer2[2];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		{
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
		if (!`attributeExists $attr tempXform`)
			addAttr -k 1 -ln $attr -at double tempXform;
		connectAttr -f ($projectName+":"+$animCurve+".output") ("tempXform."+$attr);
		copyKey -time ":" -hierarchy none -at $attr tempXform;
		pasteKey -option merge -copies 1 -connect 0 -timeOffset $timeOffset -floatOffset 0 -valueOffset 0 {$obj};
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;

if (`objExists tempXform`)
	delete tempXform;
file -rr  $animationFile;
select $sel;
if ($autoKey)
	autoKeyframe -e -st 1;
}

global proc asKeyAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[],$spaceBuffer[];
string $objAttr,$previousObjAttr,$restOfBuffers;
float $time,$value,$currentValue;
float $currentTime=`currentTime -q`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning,$firstValueSet;
string $warningMsg="The following attributes can not be keyed:";
float $firstValue;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	$restOfBuffers="";
	if ($objAttr!=$previousObjAttr)
		$firstValueSet=0;
	$previousObjAttr=$objAttr;
	for ($y=1;$y<size($buffer2);$y++)
		$restOfBuffers+=$buffer2[$y]+" ";
	if (`objExists $objAttr`)
		{
		tokenize $restOfBuffers $spaceBuffer;
		for ($y=0;$y<size($spaceBuffer);$y++)
			{
			//TimeOffset
			if ($spaceBuffer[$y]=="-t" && ($ctrlButton||$altButton))
				{
				$time=$spaceBuffer[$y+1];
				$spaceBuffer[$y+1]=$time+$currentTime;
				}
			//ValueOffset
			if ($spaceBuffer[$y]=="-v" && $ctrlButton)
				{
				$value=$spaceBuffer[$y+1];
				$currentValue=`getAttr $objAttr`;
				if (!$firstValueSet)
				$firstValue=$value;
				$firstValueSet=1;
				$spaceBuffer[$y+1]=$value+$currentValue-$firstValue;
				}
			}
		$restOfBuffers="";
		for ($y=0;$y<size($spaceBuffer);$y++)
			$restOfBuffers+=$spaceBuffer[$y]+" ";
		eval ($restOfBuffers+$objAttr);
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asPoseView (string $uiName, int $childNum)
{
string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $tempString[];
tokenize $icon "/" $tempString;
string $projectName=$tempString[size($tempString)-2];

string $mediaFile;
if ($anim)
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".avi"`;
else
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".jpg"`;
print ("// "+$mediaFile+"\n");
system ("load "+$mediaFile);
}

global proc asPoseObjects (string $uiName, string $button,string $action)
{
string $cmd=`iconTextButton -q -c $button`;
string $buffer[],$buffer2[];
string $objAttr,$value;
tokenize $cmd "\"" $buffer;
$cmd=$buffer[1];
int $numTok=`tokenize $cmd ";" $buffer`;
int $showWarning;
string $warningMsg="The following objects can not be found:";
if ($action==" select -add")
select -cl;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	tokenize $objAttr "." $buffer2;
	$obj=$buffer2[0];
	if ($action!=" select -add")
		$obj=$objAttr;
	$obj=`asPoserResolveNameSpace $uiName $obj`;
	if (`objExists $obj`)
		eval ($action+" "+$obj);
	else
		{
		$showWarning=1;
		$warningMsg+=$obj+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asMirrorOptions (string $uiName)
{
if (`window -q -ex asMirrorOptions`)
	deleteUI asMirrorOptions;
window -t "Mirror Options" asMirrorOptions;
columnLayout -adj 1;
	separator -h 25 -st "none";
	rowLayout -nc 4 -cw 1 40;
		text -l "side:";
		radioCollection asMOSideRadioCollection;
		radioButton -label "Swap" asMOSideFlip;
		radioButton -label "Right To Left" asMOSideR2L;
		radioButton -label "Left To Right" asMOSideL2R;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "axis:";
		radioCollection asMOAxisRadioCollection;
		radioButton -label "X" asMOAxisX;
		radioButton -label "Y" asMOAxisY;
		radioButton -label "Z" asMOAxisZ;
		radioCollection -e -sl "asMOAxisX" asMOAxisRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "space:";
		radioCollection asMOSpaceRadioCollection;
		radioButton -label "World" asMOSpaceWorld;
		radioButton -label "Main" asMOSpaceMain;
		radioButton -label "RootX_M" asMOSpaceCenter;
		radioCollection -e -sl "asMOSpaceWorld" asMOSpaceRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "control:";
		radioCollection asMOSelOnlyRadioCollection;
		radioButton -label "All" asMOSelOnlyAll;
		radioButton -label "Selected" asMOSelOnlySel;
		radioCollection -e -sl "asMOSelOnlyAll" asMOSelOnlyRadioCollection;
		setParent..;

separator -st "none" -h 25;
button -w 100 -l "Mirror" -c ("asMirror "+$uiName);
showWindow;

string $optionVars[]={"asMOSide","asMOSpace","asMOAxis","asMOSelOnly"};
string $cia[];
string $radioCollection,$selected,$optionVarString;
for ($i=0;$i<size($optionVars);$i++)
	{
	$radioCollection=$optionVars[$i]+"RadioCollection";
	$cia=`radioCollection -q -cia $radioCollection`;
	$selected=$cia[0];
	if (`optionVar -ex $optionVars[$i]`)
		{
		$optionVarString=`optionVar -q $optionVars[$i]`;
		for ($y=0;$y<size($cia);$y++)
			if (`gmatch $cia[$y] ("*"+$optionVarString)`)
				$selected=`optionVar -q $optionVars[$i]`;
		}
	radioCollection -e -sl $selected $radioCollection;
	}
}

global proc asMirror (string $uiName)
{
if (!`window -q -ex $uiName`)
	error ("Window : "+$uiName+" not found !");
string $side="asMOSideR2L";
string $space="asMOSpaceMain";
string $axis="asMOAxisX";
string $selOnly="asMOSelOnlyAll";
if (`window -q -ex asMirrorOptions`)
	{
	$side=`radioCollection -q -sl asMOSideRadioCollection`;
	$space=`radioCollection -q -sl asMOSpaceRadioCollection`;
	$axis=`radioCollection -q -sl asMOAxisRadioCollection`;
	$selOnly=`radioCollection -q -sl asMOSelOnlyRadioCollection`;
	optionVar -sv asMOSide $side;
	optionVar -sv asMOSpace $space;
	optionVar -sv asMOAxis $axis;
	optionVar -sv asMOSelOnly $selOnly;
	}
if (`optionVar -ex asMOSide`)
	$side=`optionVar -q asMOSide`;
if (`optionVar -ex asMOSpace`)
	$space=`optionVar -q asMOSpace`;
if (`optionVar -ex asMOAxis`)
	$axis=`optionVar -q asMOAxis`;
if (`optionVar -ex asMOSelOnly`)
	$selOnly=`optionVar -q asMOSelOnly`;
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $sortedControls[];
if (`stringArrayCount "Main" $controlSets`)
	$sortedControls={"Main","RootX_M","CenterExtra_M"};

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Spine*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Leg_*")` || `gmatch $controls[$i] ($nameSpace+"IK*Arm_*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (!`stringArrayCount $controls[$i] $sortedControls`)
		$sortedControls[size($sortedControls)]=$controls[$i];
$controls=$sortedControls;
if ($selOnly=="asMOSelOnlySel")
	$controls=$sel;
string $allKeyableAttrs[],$tempString[];
string $source,$dest,$cmd,$loc1,$loc2;
float $pos[3],$rot[3];
int $wsXform[];
int $flip;
int $isFaceControl;
string $flipAxis,$t0;
if ($axis=="asMOAxisX")
	{$flipAxis="X";$t0="tx";}
if ($axis=="asMOAxisY")
	{$flipAxis="Y";$t0="ty";}
if ($axis=="asMOAxisZ")
	{$flipAxis="Z";$t0="tz";}

createNode -n flipGroup transform;
if ($space=="asMOSpaceCenter")
	parent flipGroup ($nameSpace+"RootX_M");
if ($space=="asMOSpaceMain")
	parent flipGroup ($nameSpace+"Main");
xform -os -t 0 0 0 -ro 0 0 0 flipGroup;
if ($space=="asMOSpaceCenter" || $space=="asMOSpaceMain")
	parent -w flipGroup;
for ($i=0;$i<size($controls);$i++)
	{
	if ($side!="asMOSideFlip")
		if (`gmatch $controls[$i] "*_M"` || `gmatch $controls[$i] "*Main"`)
			continue;
	if ($side=="asMOSideR2L")
		{
		if (`gmatch $controls[$i] "*_L"`)
			continue;
		$dest=`substitute "_R" $controls[$i] "_L"`;
		}
	else if ($side=="asMOSideL2R")
		{
		if (`gmatch $controls[$i] "*_R"`)
			continue;
		$dest=`substitute "_L" $controls[$i] "_R"`;
		}
	else if ($side=="asMOSideFlip")
		{
		if (!`gmatch $controls[$i] "*_L"` && !`gmatch $controls[$i] "*_R"` && !`gmatch $controls[$i] "*_M"`)
			continue;
		if (`gmatch $controls[$i] "*FKExtraSpine1_M"`)
			continue;
		if (`gmatch $controls[$i] "*_L"`)
			$dest=`substitute "_L" $controls[$i] "_R"`;
		if (`gmatch $controls[$i] "*_R"`)
			$dest=`substitute "_R" $controls[$i] "_L"`;
		if (`gmatch $controls[$i] "*_M"`)
			$dest=$controls[$i];
		}
	if (!`objExists $dest`)
		continue;
	$isFaceControl=0;
	if (`objExists ($nameSpace+"FaceControlSet")`)
		if (`sets -im ($nameSpace+"FaceControlSet") $controls[$i]`)
			$isFaceControl=1;
	$source=$controls[$i];
	$allKeyableAttrs=`listAttr -k -m -sn $controls[$i]`;
	for ($y=0;$y<size($allKeyableAttrs);$y++)
		{
		$flip=1;
		if (`gmatch $controls[$i] ($nameSpace+"FK*_L")` || `gmatch $controls[$i] ($nameSpace+"FK*_R")`
		 || `gmatch $controls[$i] ($nameSpace+"Bend*_L")` || `gmatch $controls[$i] ($nameSpace+"Bend*_R")`)
		 	{
		 	if ($allKeyableAttrs[$y]=="tx" || $allKeyableAttrs[$y]=="ty" || $allKeyableAttrs[$y]=="tz")
		 		$flip=-1;
		 	}
		else
			if ($allKeyableAttrs[$y]=="tz" || $allKeyableAttrs[$y]=="rx" || $allKeyableAttrs[$y]=="ry")
				$flip=-1;
		if ($isFaceControl && !`gmatch $controls[$i] ($nameSpace+"ctrl*")`)
			{
			if ($allKeyableAttrs[$y]=="tx" || $allKeyableAttrs[$y]=="ry" || $allKeyableAttrs[$y]=="rz")
				$flip=-1;
			else
				$flip=1;
			}
		if (`gmatch $controls[$i] ($nameSpace+"Aim*")` || `gmatch $controls[$i] ($nameSpace+"IK*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")` || `gmatch $controls[$i] ($nameSpace+"RootX_M*")`)
			$wsXform[$i]=1;
		if (!$wsXform[$i])
			if (`getAttr -se ($dest+"."+$allKeyableAttrs[$y])`)
				$cmd+="setAttr "+$dest+"."+$allKeyableAttrs[$y]+" "+(`getAttr ($source+"."+$allKeyableAttrs[$y])`*$flip)+";";
		}

	if ($wsXform[$i])
		{
		$tempString=`spaceLocator`;
		$loc1=$tempString[0];
		$tempString=`spaceLocator`;
		$loc2=$tempString[0];
		parent $loc2 $loc1;
		parent $loc1 $source;
		xform -os -t 0 0 0 -ro 0 0 0 $loc1;
		setAttr ($loc1+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ($loc2+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ("flipGroup.scale"+$flipAxis) 1;
		parent $loc1 flipGroup;
		setAttr ("flipGroup.scale"+$flipAxis) -1;
		setAttr ($loc1+".scaleX") -1;
		$pos=`xform -q -ws -t $loc2`;
		$rot=`xform -q -ws -ro $loc2`;
		$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" -ro "+$rot[0]+" "+$rot[1]+" "+$rot[2]+" "+$dest+";";
		}

	if (`attributeExists "mirror" $controls[$i]`)
		setAttr ($controls[$i]+".mirror") 0;
	}
delete flipGroup;
if ($cmd!="")
	eval ($cmd);
select $sel;
}

global proc asGoToBuildPose (string $uiName)
{
int $ctrlButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
string $nameSpace;
string $controlSets[];
if ($uiName=="bodySetup")
	{
	$nameSpace="";
	$controlSets[0]="ControlSet";
	}
else if ($uiName=="faceSetup")
	{
	$nameSpace="";
	$controlSets[0]="FaceControlSet";
	}
else
	{
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
	$controlSets=`asGetControlSetsFromUI $uiName`;
	}
if ($nameSpace==":")
	$nameSpace="";

string $buildPose="buildPose";
if (`gmatch $controlSets[0] "*FaceControlSet"`)
    $buildPose="faceBuildPose";

string $tempString[],$tempString2[],$buffer[];
string $setAttrCmd,$cmd;


$setAttrCmd=`getAttr ($nameSpace+$buildPose+".udAttr")`;
tokenize $setAttrCmd ";" $tempString;
for ($y=0;$y<size($tempString);$y++)
	{
	$cmd=$tempString[$y];
	if ($cmd=="")
		continue;
	if ($nameSpace!="")
		{
		tokenize $cmd $buffer;
		if (`gmatch $cmd "xform*"`)
			$substituteWordNr=size($buffer)-1;
		else
			$substituteWordNr=1;
		$cmd="";
		for ($z=0;$z<size($buffer);$z++)
			{
			if ($z==$substituteWordNr)
				$cmd+=$nameSpace;
			$cmd+=$buffer[$z]+" ";
			}
		}
	if ($ctrlButton)
		if (`gmatch $cmd "*Main.*"`)
			continue;
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
	}

//run
string $run,$fitTopNode,$objAttr;
for ($i=0;$i<size($controlSets);$i++)
	{
	if (`gmatch $controlSets[$i] "*ControlSet"`)
		if (`objExists ($nameSpace+"FitSkeleton")`)
			$fitTopNode=$nameSpace+"FitSkeleton";
	if (`gmatch $controlSets[$i] "*FaceControlSet"`)
		$fitTopNode=($nameSpace+"FaceFitSkeleton");
	}

if (`objExists $fitTopNode`)
	if (`attributeExists "run" $fitTopNode`)
		{
		$run=`getAttr ($fitTopNode+".run")`;
		if ($nameSpace=="")
			catch (`eval ($run)`);
		else
			{
			tokenize $run ";" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				tokenize $tempString[$i] $tempString2;
				$objAttr=`substitute "\"" $tempString2[1] ""`;
				$objAttr=`substitute "\"" $objAttr ""`;
				$cmd=$tempString2[0]+" "+$nameSpace+$objAttr+" "+$tempString2[2]+";";
				catch (`eval ($cmd)`);
				}
			}
		}
}

global proc asPoserupdateGridBlock (string $uiName, int $childNum)
{
string $existingPopUpMenus[]=`control -q -pma ($uiName+"IconTextButton"+$childNum)`;
for ($pop in $existingPopUpMenus)
	deleteUI $pop;

int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $button=$uiName+"IconTextButton"+$childNum;
string $viewCmd="asPoseView "+$uiName+" "+$childNum;
string $selectCmd="asPoseObjects "+$uiName+" "+$button+"\" select -add\"";
string $keyCmd="asPoseObjects "+$uiName+" "+$button+" setKeyframe";
string $linearKeyCmd="asPoseObjects "+$uiName+" "+$button+" \"setKeyframe -itt linear -ott linear\"";

popupMenu -p ($uiName+"IconTextButton"+$childNum);
	menuItem -l "View" -c $viewCmd;
	if (!$anim)
		{
		menuItem -d 1;
		menuItem -l "Select" -c $selectCmd;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		}
	if ($uiName=="asPoserDefault")
		{
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asPoserRename "+$childNum);
		menuItem -l "Remove Button" -c ("asPoserDeletePose "+$uiName+" "+$childNum);
		menuItem -l "Update icon" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 1 0");
		if ($anim)
			menuItem -l "Update movie" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 0 1");
		}
}

global proc string asPoserResolveNameSpace (string $uiName, string $obj)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asDynRemove (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
for ($i=0;$i<size($sel);$i++)
	{
	string $dynObj="dynamics"+`substitute ($nameSpace+"FK") $sel[$i] ""`;
	if(`objExists $dynObj`)
		{
		delete $dynObj;
		print ("// Dynamics for "+$sel[$i]+" removed\n");
		}
	else
		print ("// No dynamics for "+$sel[$i]+" found\n");
	}
}

global proc asDynAdd (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
global string $gSelect;
setToolTo $gSelect;

string $deformJoints[];
for ($i=0;$i<size($sel);$i++)
	{
	$deformJoints[$i]=`substitute ($nameSpace+"FK") $sel[$i] ($nameSpace+"")`;
	if (`objExists ("dynamics"+$deformJoints[$i])`)
		error ("dynamics for "+$deformJoints[$i]+" already exists");
	}
$dynSortedDeformJoints=`asResolveDynJoints $nameSpace $deformJoints`;
asDynAddChain $nameSpace $dynSortedDeformJoints;
}

global proc asDynAddChain (string $nameSpace, string $dynSortedDeformJoints[])
{
string $dynJoints[],$tempString[];
string $name;
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	select $dynSortedDeformJoints[$i];
	$dynJoints[$i]="dyn"+`substitute $nameSpace $dynSortedDeformJoints[size($dynSortedDeformJoints)-1] ""`+$i;
	joint -n $dynJoints[$i];
	}
string $startJoint=$dynJoints[0];
string $endJoint=$dynJoints[size($dynJoints)-1];

string $dynTopNode="dynamics"+`substitute $nameSpace $dynSortedDeformJoints[size($dynSortedDeformJoints)-1] ""`;
if (!`objExists "Dynamics"`)
	createNode -n Dynamics transform;
createNode -n ($dynJoints[0]+"Offset") transform;
int $foundParentFK;
string $parentFK,$fk;
string $joint=$dynSortedDeformJoints[0];
while($parentFK=="")
	{
	$tempString=`listRelatives -type joint -p $joint`;
	if ($tempString[0]=="")
		$parentFK=$nameSpace+"RootX_M";
	else
		{
		$joint=$tempString[0];
		if ($nameSpace=="")
			$fk="FK"+$joint;
		else
			$fk=`substitute $nameSpace $joint ($nameSpace+"FK")`;
		if (`objExists $fk`)
			$parentFK=$fk;
		}
		
	}
parentConstraint $parentFK ($dynJoints[0]+"Offset");
createNode -n $dynTopNode transform;
parent ($dynJoints[0]+"Offset") $dynTopNode;
parent $dynTopNode Dynamics;
setAttr ($dynTopNode+".overrideEnabled") 1;
setAttr ($dynTopNode+".overrideDisplayType") 2;

for ($i=1;$i<size($dynJoints);$i++)
	parent $dynJoints[$i] $dynJoints[$i-1];
$tempString=`ikHandle -n ("DynIKHandle"+$endJoint) -ns 2 -sol ikSplineSolver -sj $startJoint -ee $endJoint`;
rename $tempString[1] ("DynIKEffector"+$endJoint);
string $ikCurve=`rename $tempString[2] ("DynIKCurve"+$endJoint)`;
parent ("DynIKHandle"+$endJoint) $dynTopNode;

parent $dynJoints[0] ($dynJoints[0]+"Offset");

//remove existing
string $dynNodes[]={("DynParticle"+$endJoint),("DynIKCurveSoft"+$endJoint),("DynParticleArrayMapper"+$endJoint),("DynParticleRamp"+$endJoint)};
for ($node in $dynNodes)
	if (`objExists $node`)
		delete $node;

//$numCv
int $numCv;
$form=`getAttr ($ikCurve+".form")`;
$spans=`getAttr ($ikCurve+".spans")`;
$degrees=`getAttr ($ikCurve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

//soft
$tempString=`soft -d -g 1 -c ("DynIKCurve"+$endJoint)`;
rename $tempString[0] ("DynParticle"+$endJoint);
$tempString=`listRelatives -p ("DynParticle"+$endJoint)`;
rename $tempString[0] ("DynIKCurveSoft"+$endJoint);
rename ("copyOfDynIKCurve"+$endJoint)  ("copyOfDynIKCurveDeform"+$endJoint);
parent ("DynIKCurveSoft"+$endJoint) ("copyOfDynIKCurveDeform"+$endJoint) $dynTopNode;

//mass
for ($i=0;$i<$numCv;$i++)
	{
	float $massPP=($i+0.00)/$numCv;
	if ($massPP==0)
		$massPP=0.01;
	particle -e -or $i -at mass -fv $massPP ("DynParticle"+$endJoint);
	}

//arrayMapper
$tempString=`arrayMapper -target ("DynParticle"+$endJoint) -destAttr goalPP -inputV mass -type ramp`;
rename $tempString[0] ("DynParticleArrayMapper"+$endJoint);

$tempString=`listConnections -s 1 -d 0 ("DynParticleArrayMapper"+$endJoint+".computeNodeColor")`;
rename $tempString[0] ("DynParticleRamp"+$endJoint);
removeMultiInstance -break true ("DynParticleRamp"+$endJoint+".colorEntryList[1]");
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[0].position") 0;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[2].position") 1;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[0].color") -type double3 1 1 1 ;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[2].color") -type double3 0 0 0;

string $fkEnd;
int $arrayNr=size($dynSortedDeformJoints)-1;
if ($nameSpace=="")
	$fkEnd="FK"+$dynSortedDeformJoints[$arrayNr];
else
	$fkEnd=`substitute $nameSpace $dynSortedDeformJoints[$arrayNr] ($nameSpace+"FK")`;
if (!`attributeExists blend $fkEnd`)
	addAttr -k 1 -ln blend -at double -min 0 -max 1 -dv 1 $fkEnd;
if (!`attributeExists baseGoal $fkEnd`)
	addAttr -k 1 -ln baseGoal -at double -min 0 -max 1 -dv 1 $fkEnd;
if (!`attributeExists tipGoal $fkEnd`)
	addAttr -k 1 -ln tipGoal -at double -min 0 -max 1 -dv 0.6 $fkEnd;
if (!`attributeExists conserve $fkEnd`)
	addAttr -k 1 -ln conserve -at double -min 0 -max 1 -dv 0.75 $fkEnd;
connectAttr ($fkEnd+".baseGoal") ("DynParticleArrayMapper"+$endJoint+".maxValue");
connectAttr ($fkEnd+".tipGoal") ("DynParticleArrayMapper"+$endJoint+".minValue");
connectAttr ($fkEnd+".conserve") ("DynParticle"+$endJoint+".conserve");

//skinCurve
select -cl;
string $fkx;
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	if ($nameSpace=="")
		$fkx="FKX"+$dynSortedDeformJoints[$i];
	else
		$fkx=`substitute $nameSpace $dynSortedDeformJoints[$i] ($nameSpace+"FKX")`;
	if (`objExists $fkx`)
		select -add $fkx;
	}
select -add ("copyOfDynIKCurveDeform"+$endJoint);
newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false";

//pairBlend
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	if ($i>0)
		{
		$tempString[0]=`pairBlend -nd $dynSortedDeformJoints[$i] -at tx -at ty -at tz`;
		rename $tempString[0] ("parBlendT"+$dynJoints[$i]);
		connectAttr -f ($dynJoints[$i]+".translate") ("parBlendT"+$dynJoints[$i]+".inTranslate2");
		}
	$tempString[0]=`pairBlend -nd $dynSortedDeformJoints[$i] -at rx -at ry -at rz`;
	rename $tempString[0] ("parBlendR"+$dynJoints[$i]);
	connectAttr -f ($dynJoints[$i]+".rotate") ("parBlendR"+$dynJoints[$i]+".inRotate2");
	connectAttr ($fkEnd+".blend") ("parBlendR"+$dynJoints[$i]+".weight");
	}

setAttr -l 1 ($startJoint+"Offset.v") 0;
setAttr -l 1 ("DynIKHandle"+$endJoint+".v") 0;
setAttr -l 1 ("copyOfDynIKCurveDeform"+$endJoint+".v") 0;

select $fkEnd;
}

global proc string[] asResolveDynJoints (string $nameSpace, string $joints[])
{
string $dynJoints[];
string $jointLongNames[],$tempStringA[],$tempStringB[];
for ($i=0;$i<size($joints);$i++)
	{
	$tempStringA=`ls -l $joints[$i]`;
	$jointLongNames[$i]=$tempStringA[0];
	}
string $sorted[]=`sort $jointLongNames`;
for ($i=1;$i<size($sorted);$i++)
	{
	$tempStringA=`ls $sorted[$i]`;
	$tempStringB=`ls $sorted[$i-1]`;
	if (!`gmatch $sorted[$i] ($sorted[$i-1]+"*")`)
	error ("\""+$tempStringA[0]+"\" is not a child of \""+$tempStringB[0]+"\", select controls in same hiarchy");
	}

string $dynEndJointLongName=$sorted[size($sorted)-1];
$tempStringA=`ls -sn $dynEndJointLongName`;
$dynJoints[0]=$tempStringA[0];
string $joint=$dynJoints[0];
int $reachedStartJoint,$reachedParentOfStartJoint;
while (!$reachedStartJoint)
	{
	$tempStringA=`listRelatives -p -f -type joint $joint`;
	if (!size($tempStringA))
		break;
	$jointLongName=$tempStringA[0];
	$tempStringA=`ls -sn $tempStringA[0]`;
	$joint=$tempStringA[0];
	if (size($joints)==1)
		{
		//single control selected
		if (!`stringArrayCount $jointLongName $sorted`)
			if (!`gmatch $joint "*Part[0-9]*"`)
				$reachedStartJoint=1;
		}
	else
		{
		//several controls selected
		if ($jointLongName==$sorted[0])
			$reachedStartJoint=1;
		}
	$dynJoints[size($dynJoints)]=$joint;
	}
string $dynJointReverse[];
for ($i=size($dynJoints)-1;$i>-1;$i--)
	$dynJointReverse[size($dynJointReverse)]=$dynJoints[$i];
return $dynJointReverse;
}

global proc asAnimBake (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Bake character ?\n"
	+"This creates a single joint chain for game engine export\n"
	+"The rig controllers will no longer work")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $name=`substitute ":" $nameSpace ""`;
string $bakeNameSpace=$name+"Bake:";
namespace -add ($name+"Bake");
namespace -set ($name+"Bake");
$tempString=`listRelatives -c ($nameSpace+"DeformationSystem")`;
$tempString=`duplicate $tempString[0]`;
string $topBakeJoint=$tempString[0];
parent -w $topBakeJoint;
$tempString=`listRelatives -ad $topBakeJoint`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`!="joint")
		delete $tempString[$i];
string $allBakeJoints[]=`listRelatives -ad -type joint $topBakeJoint`;
$allBakeJoints[size($allBakeJoints)]=$topBakeJoint;
sets -rm ($nameSpace+"DeformSet") $allBakeJoints;
//Disable Skincluster
string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 1;
//Constraint bakeSkeleton
string $deformJoints[]=`listRelatives -ad -type joint ($nameSpace+"DeformationSystem")`;
for ($i=0;$i<size($deformJoints);$i++)
    {
		if ($nameSpace=="")
			$bakeDeformJoint=$bakeNameSpace+$deformJoints[$i];
		else
			$bakeDeformJoint=`substitute $nameSpace $deformJoints[$i] $bakeNameSpace`;
    parentConstraint $deformJoints[$i] $bakeDeformJoint;
//    scaleConstraint $deformJoints[$i] $bakeDeformJoint;//caues issues with overall scale
    }
//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $allBakeJoints;
//Transfer deformation to bake skeleton
for ($i=0;$i<size($deformJoints);$i++)
{
    $tempString=`listConnections -s 0 -d 1 -p 1 -c 1 $deformJoints[$i]`;
    for ($y=0;$y<size($tempString);$y=$y+2)
        {        
        if ($nameSpace=="")
        	$newSource=$bakeNameSpace+$tempString[$y];
				else
	        $newSource=`substitute $nameSpace $tempString[$y] $bakeNameSpace`;
        catch (`connectAttr -f $newSource $tempString[$y+1]`);
        }
}
//Enable Skincluster
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 0;

namespace -set ":";
select $allBakeJoints;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
select $topBakeJoint;
print ("// Selected joint chain is ready for export, add geometry to selection and export\n");
}

global proc asDynBake (string $uiName)
{
if (`confirmDialog -title "Confirm" -message "Bake all dynamics ?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
asDynUnBake $uiName;
string $softDynCurves[]=`ls -type nurbsCurve "DynIKCurveSoftdyn*"`;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 0 -sparseAnimCurveBake false -controlPoints true -shape false $softDynCurves;
}

global proc asDynUnBake (string $uiName)
{
string $softDynCurves[]=`ls -type nurbsCurve "DynIKCurveSoftdyn*"`;
string $particles;
int $spans,$degrees,$numCv;
for ($i=0;$i<size($softDynCurves);$i++)
	{
	$particles=`substitute "DynIKCurveSoft" $softDynCurves[$i] "DynParticle"`;
	$particles=`substitute "Shape" $particles ""`;
	if (!`isConnected ($particles+".targetGeometry") ($softDynCurves[$i]+".create")`)
		connectAttr ($particles+".targetGeometry") ($softDynCurves[$i]+".create");
	if (size(`listConnections -type animCurve $softDynCurves[$i]`))
		delete `listConnections -type animCurve $softDynCurves[$i]`;
	$spans=`getAttr ($softDynCurves[$i]+".spans")`;
	$degrees=`getAttr ($softDynCurves[$i]+".degree")`;
	$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv;$y++)
		setAttr ($softDynCurves[$i]+".cv["+$y+"]") 0 0 0;
	}
}

global proc asJointsVisibilityToggle ()
{
int $vis;
int $firstModelEditor=0;
string $editors[]=`lsUI -editors`;
for ($i=0;$i<size($editors);$i++)
    if (`modelEditor -q -ex $editors[$i]`)
        {
        if (!$firstModelEditor)
            $vis=!(`modelEditor -q -joints $editors[$i]`);
        $firstModelEditor=1;
        modelEditor -e -joints $vis $editors[$i];
        }
}

global proc asControlsVisibilityToggle ()
{
int $vis;
string $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;
for ($i=0;$i<size($motionSystems);$i++)
    {
    if ($i==0)
        $vis=!(`getAttr ($motionSystems[$i]+".v")`);
    setAttr ($motionSystems[$i]+".v") $vis;
    }
}

global proc asSetupControlVisibilityHotKeyDialog ()
{
if (`confirmDialog -title "Confirm"
	-message ("Add toggle of control-visibility to the \"~\" hotkey.\n"
	+"For easy toggling visibility of controls.\n"
	+"Holding down the \"~\" key (next to the \"number 1\" on the keyboard) to see and select controls.\n"
	+"As you let go, controls will again be hidden.\n"
	+"The idea is to work without the `visual clutter` of the controls.\n"
	+"Tip: Ctrl+\"\~\" will leave the controls visible")
	-button "Confirm" -button "Cancel" -defaultButton "Confirm"
	-cancelButton "Cancel" -dismissString "Cancel"`!="Confirm")
	return;
asSetupControlVisibilityHotKey;
}

global proc asSetupControlVisibilityHotKey ()
{
if (`runTimeCommand -q -ex advancedSkeletonVisibilitySwitch`)
	return;
nameCommand -ann "advancedSkeletonVisibilitySwitch" -c "advancedSkeletonVisibilitySwitch" advancedSkeletonVisibilitySwitchNameCommand;
runTimeCommand -annotation "switches the visibility of controls" -category "User"
	-command ("int $vis;\nstring $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;\nfor ($i=0;$i<size($motionSystems);$i++)\n    {\n    if ($i==0)\n        $vis=!(`getAttr ($motionSystems[$i]+\".v\")`);\n    setAttr ($motionSystems[$i]+\".v\") $vis;\n    }")
	advancedSkeletonVisibilitySwitch;
hotkey -keyShortcut "`" -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "`" -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
}

global proc asVisualizeGimbalLock (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
int $fromSelection;
int $buildGimbal[];
float $scale;
float $bb[];
string $name,$lookForVisConnectionOnObject;
string $tempString[];
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;

if (`objExists GimbalLockVisualizers`)
	{
	delete GimbalLockVisualizers;
	return;
	}
createNode -n GimbalLockVisualizers transform;
if ($sel[0]!="")
	if (`stringArrayCount $sel[0] $controls`)
		$fromSelection=1;
for ($i=0;$i<size($controls);$i++)
	{
	if ($controls[$i]==$nameSpace+"Main")
		continue;
	$tempString=`listRelatives -s $controls[$i]`;
	if ($tempString[0]!="")
		if (`objectType $tempString[0]`=="nurbsCurve")
			{
			if ($fromSelection)
				if (`stringArrayCount $controls[$i] $sel`)
					$buildGimbal[$i]=1;
			if (!$fromSelection)
				$buildGimbal[$i]=1;
			}
	}
for ($i=0;$i<size($controls);$i++)
	{
	if (!$buildGimbal[$i])
		continue;
	$name=$controls[$i];
	createNode -n ($name+"Constraint") -p GimbalLockVisualizers transform;
	createNode -n ($name+"Offset") -p ($name+"Constraint") transform;

	polyCylinder -n ($name+"Cones") -r 0.3 -h 2.5 -sx 10 -sy 2 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	scale -r -p 0 0 0 0 0 0 ($name+"Cones.vtx[10:19]");
	parent ($name+"Cones") ($name+"Offset");
	if (`objExists asGreenSG`)
		sets -e -forceElement asGreenSG ($name+"Cones");

	polyTorus -n ($name+"Torus") -r 1 -sr 0.03 -tw 0 -sx 30 -sy 6 -ax 0 1 0 -cuv 1 -ch 0;
	parent ($name+"Torus") ($name+"Offset");
	if (`objExists asRedSG`)
		sets -e -forceElement asRedSG ($name+"Torus");

	polyCylinder -n ($name+"Arrow") -r 0.06 -h 2 -sx 10 -sy 3 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	rotate -r 0 0 90 ($name+"Arrow.vtx[0:41]");
	move -r 1 0 0 ($name+"Arrow.vtx[0:41]");
	scale -r -p 0 0 0 1 0 0 ($name+"Arrow.vtx[0:9]") ($name+"Arrow.vtx[40]");
	move -r 0.35 0 0 ($name+"Arrow.vtx[10:19]");
	scale -r -p 0 0 0 1 1.75 1.75 ($name+"Arrow.vtx[10:19]");
	move -r 1 0 0 ($name+"Arrow.vtx[20:29]");
	parent ($name+"Arrow") ($name+"Offset");
	if (`objExists asGreen2SG`)
		sets -e -forceElement asGreen2SG ($name+"Arrow");
	orientConstraint $name ($name+"Arrow");

	$tempString=`listRelatives -p $name`;
	parentConstraint $tempString[0] ($name+"Constraint");
	$tempString=`listRelatives -s $name`;
	$bb=`xform -q -bb ($tempString[0]+".cv[0:999]")`;
	$scale=(($bb[3]-$bb[0])+($bb[4]-$bb[1])+($bb[5]-$bb[2]))/5.0;
	setAttr -type float3 ($name+"Offset.s") $scale $scale $scale;
	$lookForVisConnectionOnObject=$name;
	$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
	for ($y=0;$y<20;$y++)
		{
		if ($tempString[0]!="")
			{
			connectAttr $tempString[0] ($name+"Offset.v");
			break;
			}
		$tempString=`listRelatives -p $lookForVisConnectionOnObject`;
		if ($tempString[0]=="")
			break;
		$lookForVisConnectionOnObject=$tempString[0];
		$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	}
select $sel;
}

global proc string asSelectorScriptLocation ()
{
string $whatIs=`whatIs asSelectorScriptLocation`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
if ($numTok<2)
	if (`about -win`)
		$numTok=`tokenize $fullPath "\\" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;
return $scriptLocation;
}
//-- ASTools Procedures Ends Here --//

//-- ASSelector Procedures Starts Here --//
global proc asSelectorDesigner ()
{
asShowSelJob;
string $controlSets[]=`asGetControlSets`;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");

if (`window -q -ex asSelectorDefault`)
	deleteUI asSelectorDefault;
window -w 640 -h 480 -mb 1 -t "SelectorDesigner :untitled" asSelectorDefault;

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`internalVar -utd`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	intField -v 640 asSelectorWidth;
	intField -v 480 asSelectorHeight;
	setParent..;

menu "File";
	menuItem -c "asSave Selector" "Save";
	menuItem -c "asfileBrowse Selector SaveAs" "Save As";
	menuItem -c "astoShelf Selector" "Put on shelf";

menu "Edit";
	menuItem -sm 1 "Colors";
		menuItem -c "asSelectorBackgroundSetColor asSelectorSelColor" "set Selected Color";
		menuItem -c "asSelectorBackgroundSetColor asSelectorKeyColor" "set Keyed Color";

menu "Layout";
	menuItem -c "asSDNewLayout 0" -l "New Empty Layout";
	menuItem -c "asSDNewLayout 1" -l "New Biped Layout";
	menuItem -c "asSDNewLayout 2" -l "New Face Layout";

menu "Buttons";
	menuItem -c "asSDNewButtton Object 50 50 100 100" -l "Create New Button";

menu "Render";
	menuItem -c "asSDRender 1" -l "Render Background";
	menuItem -c "asfileBrowse Selector Import" -l "Import  Background";
	menuItem -d 1;
	menuItem -c "asSDRender 0" -l "Render Buttons";

columnLayout -adj 1;
rowLayout -nc 4 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 80 -cw 4 60;
optionMenu -cc asSelChange asSelectorDefaultOptionMenu;
button -l "set" -c "asSetNameSpaceFromSelection asSelectorDefault";
checkBox -v `optionVar -q asShowSelection` -onc "asSelChangeToggle;optionVar -iv asShowSelection 1;" -ofc "asSelChangeToggle;optionVar -iv asShowSelection 0;" -l Selection asSelectorSelectionCheckBox;
checkBox -v `optionVar -q asShowKeyed` -onc "asSelChangeToggle;optionVar -iv asShowKeyed 1;" -ofc "asSelChangeToggle;optionVar -iv asShowKeyed 0;" -l Keyed asSelectorKeyedCheckBox;
setParent..;

formLayout asSelectorDefaultFormLayout;
setParent..;
asPopulateNameSpaceMenu "asSelectorDefault";

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`internalVar -utd`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	text -l "640" asSelectorBackgroundWidth;
	text -l "480" asSelectorBackgroundHeight;

showWindow;
}

global proc asSDNewLayout (int $LayoutType)
{
if (`objExists SelectorLayout`)
	if (`confirmDialog -t "Confirm"
	-m "SelectorLayout already exists, this will replace the current Layout"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;

float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $tempString[];

select -cl;
string $deleteObjs[]={"SelectorLayout","Template","SelectorLayoutShader","SelectorLayoutSG","SelectorIcons"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

createNode -n SelectorLayout transform;
polyCube -n Button_Template -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
addAttr -ln label -dt "string" Button_Template;
addAttr -ln multiObjs -dt "string" Button_Template;
polyProjection -ch 0 -type Planar -ibd on -md z Button_Template.f[0];
setAttr Button_Template.sz 0.001;
parent Button_Template SelectorLayout;
setAttr SelectorLayout.tz ($height/2);
setAttr -l 1 -k 0 Button_Template.tz;
setAttr -l 1 -k 0 Button_Template.rx;
setAttr -l 1 -k 0 Button_Template.ry;
setAttr -l 1 -k 0 Button_Template.rz;
setAttr -l 1 -k 0 Button_Template.sz;
//setAttr -l 1 -k 0 Button_Template.v;

shadingNode -n SelectorLayoutShader -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name SelectorLayoutSG;
connectAttr -f SelectorLayoutShader.outColor SelectorLayoutSG.surfaceShader;
setAttr SelectorLayoutShader.transparency -type double3 0.8 0.8 0.8; 
sets -e -forceElement SelectorLayoutSG Button_Template;

setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.overrideColor 15;
setAttr Button_TemplateShape.primaryVisibility 0;
//setAttr Button_TemplateShape.overrideShading 0;
setAttr Button_TemplateShape.castsShadows 0;
setAttr Button_TemplateShape.receiveShadows 0;
setAttr Button_TemplateShape.visibleInReflections 0;
setAttr Button_TemplateShape.visibleInRefractions 0;
setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.motionBlur 0;
setAttr Button_TemplateShape.smoothShading 0;
//setAttr Button_TemplateShape.doubleSided 0;

//SelectorWindow
duplicate -n SelectorWindow Button_Template;
setAttr SelectorWindowShape.overrideShading 0;
setAttr SelectorWindow.sx 640;
setAttr SelectorWindow.sy 480;
move -r 0 240 0 SelectorWindow.vtx[0:7];
setAttr -type float3 SelectorLayout.s ($height*0.002083) ($height*0.002083) ($height*0.002083);

//WindowCorner
createNode -n WindowCorner -p SelectorWindow transform;
setAttr -type float3 WindowCorner.t -0.5 1 0;
setAttr -type float3 WindowCorner.s (1.0/640) (-1.0/480) 1;

//Prep Button_Template
move -r (`getAttr SelectorLayout.sx`/2.0) (`getAttr SelectorLayout.sy`/2.0) 0 Button_Template.vtx[0:7];
parent Button_Template WindowCorner;
setAttr Button_Template.tx -150;
setAttr Button_Template.ty 50;
setAttr Button_Template.sx 100;
setAttr Button_Template.sy 100;
setAttr Button_Template.v 0;

select -cl;
if ($LayoutType==1)
	{
	asSDNewButtton FKElbow_R 136 78 72 27;
	asSDNewButtton FKShoulder_R 210 75 64 32;
	asSDNewButtton FKWrist_R 92 68 43 43;
	asSDNewButtton RootX_M 188 228 70 24;
		$tempString=`listConnections -p 1 Button_RootX_M.tx`;disconnectAttr $tempString[0] Button_RootX_M.tx;
		setAttr Button_RootX_M.tx 188;
		setAttr -type "string" Button_RootX_M.label Root;
	asSDNewButtton FKRoot_M 270 190 100 38;
	asSDNewButtton FKSpine1_M 270 149 100 38;
	asSDNewButtton FKChest_M 270 108 100 38;
	asSDNewButtton FKHip_R 267 234 48 106;
	asSDNewButtton FKKnee_R 275 346 39 104;
	asSDNewButtton FKAnkle_R 275 451 39 26;
	asSDNewButtton FKToes_R 243 461 30 14;
	asSDNewButtton FKScapula_R 277 67 25 41;
	asSDNewButtton FKNeck_M 304 79 30 26;
	asSDNewButtton FKHead_M 291 3 56 56;

	asSDNewButtton IKArm_R 92 10 43 43;
	asSDNewButtton PoleArm_R 160 22 30 30;
	asSDNewButtton FKIKArm_R 216 21 30 30;
	asSDNewButtton IKLeg_R 205 405 43 43;
	asSDNewButtton PoleLeg_R 210 333 30 30;
	asSDNewButtton FKIKLeg_R 210 261 30 30;
	asSDNewButtton RollHeelLeg_R 215 452 24 24;
	asSDNewButtton RollToes_R 188 452 24 24;
	asSDNewButtton RollToesEnd_R 160 452 24 24;

	asSDNewButtton HipSwinger_M 205 161 43 43;
		$tempString=`listConnections -p 1 Button_HipSwinger_M.tx`;disconnectAttr $tempString[0] Button_HipSwinger_M.tx;
		setAttr Button_HipSwinger_M.tx 205;

	asSDNewButtton Main 20 10 43 20;
		setAttr -type "string" Button_Main.label Main;

	asSDNewButtton FKWrist_R 6 330 140 100;
	asSDNewButtton FKIndexFinger1_R 114 268 32 58;
	asSDNewButtton FKMiddleFinger1_R 78 268 32 58;
	asSDNewButtton FKRingFinger1_R 43 268 32 58;
	asSDNewButtton FKPinkyFinger1_R 6 268 32 58;
	asSDNewButtton FKIndexFinger2_R 114 211 32 52;
	asSDNewButtton FKMiddleFinger2_R 78 211 32 52;
	asSDNewButtton FKRingFinger2_R 43 211 32 52;
	asSDNewButtton FKPinkyFinger2_R 6 211 32 52;
	asSDNewButtton FKIndexFinger3_R 114 167 32 40;
	asSDNewButtton FKMiddleFinger3_R 78 167 32 40;
	asSDNewButtton FKRingFinger3_R 43 167 32 40;
	asSDNewButtton FKPinkyFinger3_R 6 167 32 40;
	asSDNewButtton FKThumbFinger1_R 149 330 32 66;
	asSDNewButtton FKThumbFinger2_R 149 272 32 52;
	asSDNewButtton FKThumbFinger3_R 149 225 32 41;
	asSDNewButtton Fingers_R 31 436 91 24;
		setAttr -type "string" Button_Fingers_R.label Fingers;

	asSDNewButtton FKSpine 188 129 70 24;
		setAttr -type "string" Button_FKSpine.label Spine;
		setAttr -type "string" Button_FKSpine.multiObjs "FKChest_M FKSpine1_M FKRoot_M";
	asSDNewButtton IKSpine1_M 390 204 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine1_M.tx`;disconnectAttr $tempString[0] Button_IKSpine1_M.tx;
		setAttr Button_IKSpine1_M.tx 390;
	asSDNewButtton IKSpine2_M 390 164 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine2_M.tx`;disconnectAttr $tempString[0] Button_IKSpine2_M.tx;
		setAttr Button_IKSpine2_M.tx 390;
	asSDNewButtton IKSpine3_M 390 127 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine3_M.tx`;disconnectAttr $tempString[0] Button_IKSpine3_M.tx;
		setAttr Button_IKSpine3_M.tx 390;
	asSDNewButtton FKIKSpine_M 425 163 30 30;
		$tempString=`listConnections -p 1 Button_FKIKSpine_M.tx`;disconnectAttr $tempString[0] Button_FKIKSpine_M.tx;
		setAttr Button_FKIKSpine_M.tx 425;
	}
if ($LayoutType==2)
	{
	asSDNewButtton browOuter_R 143 20 33 33;
	asSDNewButtton browHalf_R 192 20 33 33;
	asSDNewButtton browInner_R 246 20 33 33;

	asSDNewButtton LidCorner2_R 150 103 33 33;
	asSDNewButtton upperLid1_R 208 67 33 33;
	asSDNewButtton LidCorner1_R 269 103 33 33;
	asSDNewButtton lowerLid1_R 208 139 33 33;
	asSDNewButtton upperLid3_R 178 74 25 25;
	asSDNewButtton upperLid2_R 243 75 25 25;
	asSDNewButtton lowerLid3_R 179 137 25 25;
	asSDNewButtton lowerLid2_R 244 137 25 25;

	asSDNewButtton noseCorner_R 253 251 33 33;
	asSDNewButtton cheek_R 187 311 33 33;

	asSDNewButtton Lip6_R 231 335 33 33;
	asSDNewButtton upperLip0_M 303 306 33 33;
	asSDNewButtton lowerLip0_M 303 358 33 33;
	asSDNewButtton upperLip3_R 271 320 25 25;
	asSDNewButtton lowerLip3_R 271 355 25 25;

	asSDNewButtton ctrlBrow_R 547 30 40 40;
	asSDNewButtton ctrlBrow_L 597 30 40 40;
	asSDNewButtton ctrlEye_R 547 104 40 40;
	asSDNewButtton ctrlEye_L 597 104 40 40;
	asSDNewButtton ctrlCheek_R 547 183 40 20;
	asSDNewButtton ctrlCheek_L 597 183 40 20;
	asSDNewButtton ctrlNose_R 547 245 40 20;
	asSDNewButtton ctrlNose_L 597 245 40 20;
	asSDNewButtton ctrlMouth_M 561 293 65 65;
		$tempString=`listConnections -p 1 Button_ctrlMouth_M.tx`;disconnectAttr $tempString[0] Button_ctrlMouth_M.tx;
		setAttr Button_ctrlMouth_M.tx 561;
	asSDNewButtton ctrlMouthCorner_R 547 377 40 40;
	asSDNewButtton ctrlMouthCorner_L 597 377 40 40;
	asSDNewButtton ctrlTongue_M 561 431 65 15;
		$tempString=`listConnections -p 1 Button_ctrlTongue_M.tx`;disconnectAttr $tempString[0] Button_ctrlTongue_M.tx;
		setAttr Button_ctrlTongue_M.tx 561;
	asSDNewButtton ctrlBox 520 299 13 159;

	asSDNewButtton lips 18 72 71 30;
		setAttr -type "string" Button_lips.label lips;
		setAttr -type "string" Button_lips.multiObjs "Lip6_R upperLip0_M Lip6_L lowerLip0_M";
	asSDNewButtton FKJaw_M 231 411 177 43;
	}

//SelectorIcons
asFitModeEnsureShaders;
createNode -n SelectorIcons transform;
setAttr SelectorIcons.tz ($height/2.2);
connectAttr SelectorLayout.s SelectorIcons.s;
createNode -n SelectorIconsWindow -p SelectorIcons transform;
connectAttr SelectorWindow.t SelectorIconsWindow.t;
connectAttr SelectorWindow.s SelectorIconsWindow.s;
createNode -n WindowIconsCorner -p SelectorIconsWindow transform;
connectAttr WindowCorner.t WindowIconsCorner.t;
connectAttr WindowCorner.s WindowIconsCorner.s;
createNode -n MirroredIcons -p WindowIconsCorner transform;
setAttr MirroredIcons.tx `getAttr SelectorWindow.sx`;
setAttr MirroredIcons.sx -1;

if ($LayoutType==1)
	{
	asSDNewIcon IKArm_R asRedSG sphere;
	asSDNewIcon PoleArm_R asRedSG cross;
	asSDNewIcon FKIKArm_R asBlueSG cross;
	asSDNewIcon IKLeg_R asRedSG sphere;
	asSDNewIcon PoleLeg_R asRedSG cross;
	asSDNewIcon FKIKLeg_R asBlueSG cross;
	asSDNewIcon RollHeelLeg_R asRedSG torus;
	asSDNewIcon RollToes_R asRedSG torus;
	asSDNewIcon RollToesEnd_R asRedSG torus;
	asSDNewIcon HipSwinger_M asGreen2SG torus;
	asSDNewIcon IKSpine1_M asRedSG sphere;
	asSDNewIcon IKSpine2_M asRedSG sphere;
	asSDNewIcon IKSpine3_M asRedSG sphere;
	asSDNewIcon FKIKSpine_M asBlueSG cross;
	}
if ($LayoutType==2)
	{
	asSDNewIcon browOuter_R asBlueSG sphere;
	asSDNewIcon browHalf_R asGreen2SG sphere;
	asSDNewIcon browInner_R asBlueSG sphere;
	asSDNewIcon LidCorner2_R asGreenSG sphere;
	asSDNewIcon upperLid1_R asGreenSG sphere;
	asSDNewIcon LidCorner1_R asGreenSG sphere;
	asSDNewIcon lowerLid1_R asGreenSG sphere;
	asSDNewIcon upperLid3_R asGreen2SG sphere;
	asSDNewIcon upperLid2_R asGreen2SG sphere;
	asSDNewIcon lowerLid2_R asGreen2SG sphere;
	asSDNewIcon lowerLid3_R asGreen2SG sphere;
	asSDNewIcon noseCorner_R asBlue2SG sphere;
	asSDNewIcon cheek_R asBlue2SG sphere;
	asSDNewIcon Lip6_R asGreenSG sphere;
	asSDNewIcon upperLip0_M asGreenSG sphere;
	asSDNewIcon lowerLip0_M asGreenSG sphere;
	asSDNewIcon upperLip3_R asGreen2SG sphere;
	asSDNewIcon lowerLip3_R asGreen2SG sphere;
	
	}
select SelectorLayout;
}

global proc asSDNewIcon (string $name, string $shader, string $shape)
{
string $buttonIcon="ButtonIcon_"+$name;
int $numLetters=`size($buttonIcon)`;
string $buttonIconLeft=`substring $buttonIcon 1 ($numLetters-2)`+"_L";
if ($shape=="sphere")
	polySphere -n $buttonIcon -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
if ($shape=="cross")
	{
	polyCube -n $buttonIcon -w 1 -h 1 -d 1 -sx 3 -sy 3 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	scale -r -p 0 0 0 0.333 0.333 0.333 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3]") ($buttonIcon+".vtx[12]")
		($buttonIcon+".vtx[15:16]") ($buttonIcon+".vtx[19]") ($buttonIcon+".vtx[28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 2.5 2.5 2.5 ($buttonIcon+".vtx[0:99]");
	scale -r -p 0 0 0 1 0.5 1 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3:12]") ($buttonIcon+".vtx[15:16]")
		($buttonIcon+".vtx[19:28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 0.5 1 1 ($buttonIcon+".vtx[0:3]") ($buttonIcon+".vtx[5:6]") ($buttonIcon+".vtx[9:10]")
		($buttonIcon+".vtx[12:19]") ($buttonIcon+".vtx[21:22]") ($buttonIcon+".vtx[25:26]") ($buttonIcon+".vtx[28:31]");
	}
if ($shape=="torus")
	polyTorus -n $buttonIcon -r 1 -sr 0.1 -tw 0 -sx 20 -sy 20 -ax 0 0 1 -cuv 1 -ch 0;
parent $buttonIcon WindowIconsCorner;
sets -e -forceElement $shader $buttonIcon;
move -r 1 -1 0 ($buttonIcon+".vtx[0:999]");
scale -r -p 0 0 0 0.5 0.5 0.5 ($buttonIcon+".vtx[0:999]");
scale -r -p 0.5 -0.5 0 0.75 0.75 0.75 ($buttonIcon+".vtx[0:999]");
connectAttr ("Button_"+$name+".t") ($buttonIcon+".t");
connectAttr ("Button_"+$name+".sx") ($buttonIcon+".sx");
connectAttr ("Button_"+$name+".sy") ($buttonIcon+".sy");
setAttr ($buttonIcon+".sz") 1000;
if (`gmatch $buttonIcon "*_R"`)
	{
	instance -n $buttonIconLeft $buttonIcon;
	parent $buttonIconLeft MirroredIcons;
	connectAttr ($buttonIcon+".t") ($buttonIconLeft+".t");
	connectAttr ($buttonIcon+".sy") ($buttonIconLeft+".sy");
	connectAttr ($buttonIcon+".sz") ($buttonIconLeft+".sz");
	createNode -n ($buttonIcon+"Reverse") reverse;
	connectAttr ($buttonIcon+".sx") ($buttonIcon+"Reverse.inputX");
	connectAttr ($buttonIcon+"Reverse.outputX") ($buttonIconLeft+".sx");
	}
	
}

global proc asSDNewButtton (string $name,int $x, int $y, int $width, int $height)
{
if (!`objExists Button_Template`)
	error "\"Button_Template\" Not found";
string $multiObjString;
string $sel[]=`ls -sl`;
string $buttonName="Button_"+$name;
if ($sel[0]!="" && !`gmatch $sel[0] "Button*"` && $sel[0]!="SelectorWindow" && $sel[0]!="SelectorLayout")
	{
	string $nameSpace=`optionMenu -q -v asSelectorDefaultOptionMenu`;
	if ($nameSpace==":")
		$buttonName="Button_"+$sel[0];
	else
		$buttonName="Button_"+`substitute $nameSpace $sel[0] ""`;
	createNode -n SelectorSampler -p WindowCorner transform;
	pointConstraint $sel[0] SelectorSampler;
	dgdirty -a;
	$x=`getAttr SelectorSampler.tx`-($width/2);
	$y=`getAttr SelectorSampler.ty`-($height/2);
	delete SelectorSampler;
	if (size($sel)>1)
		for ($i=0;$i<size($sel);$i++)
			$multiObjString+=$sel[$i]+" ";
	}
//unique buttonName
if (`objExists $buttonName`)
	for ($i=1;$i<10;$i++)
		{
		$buttonName=`substitute "Button" $buttonName ""`;
		if (`gmatch $buttonName "[1-9]*"`)
			$buttonName=`substring $buttonName 2 99`;
		$buttonName="Button"+$i+$buttonName;
		if (!`objExists $buttonName`)
			break;
		}

string $tempString[]=`duplicate -n $buttonName Button_Template`;
$buttonName=$tempString[0];
setAttr ($buttonName+".v") 1;
setAttr ($buttonName+".tx") $x;
setAttr ($buttonName+".ty") $y;
setAttr ($buttonName+".sx") $width;
setAttr ($buttonName+".sy") $height;
if ($multiObjString!="")
	setAttr -type "string" ($buttonName+".multiObjs") $multiObjString;

//Middle Constraint
if (`gmatch $buttonName "*_M"`)
	{
	if (`objExists ($buttonName+"MultiplyDivide")`) delete ($buttonName+"MultiplyDivide");
	if (`objExists ($buttonName+"PlusMinusAverage")`) delete ($buttonName+"PlusMinusAverage");
	createNode -n ($buttonName+"MultiplyDivide") multiplyDivide;
	createNode -n ($buttonName+"PlusMinusAverage") plusMinusAverage;
	setAttr ($buttonName+"PlusMinusAverage.operation") 2;
	connectAttr ($buttonName+".scale.scaleX") ($buttonName+"MultiplyDivide.input1Y");
	setAttr -type float3 ($buttonName+"MultiplyDivide.input2") 2 2 2;
	setAttr ($buttonName+"MultiplyDivide.operation") 2;
	connectAttr ($buttonName+"MultiplyDivide.outputY") ($buttonName+"PlusMinusAverage.input1D[1]");
	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") (`getAttr SelectorWindow.scale.scaleX`/2.0);
	connectAttr ($buttonName+"PlusMinusAverage.output1D") ($buttonName+".tx");
	}

select $buttonName;
}

global proc int asSelectorBackgroundImport (string $fileName, string $fileType)
{
eval ("renderWindowEditor -e -loadImage \""+$fileName+"\" renderView");
asSDRender 2;
return 1;
}

global proc asSDRender (int $background)
{
global string $gMove;
setToolTo $gMove;
if (!`objExists SelectorWindow`)
	{
	if (`confirmDialog -t "Confirm"
	-m "No Layout found. Create New one ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
	asSDNewLayout 0;
	}
if (`objExists SelectorCamera`)
	delete SelectorCamera;
int $renderViewIconized=1;
if (`window -q -ex renderViewWindow`)
	$renderViewIconized=`window -q -i renderViewWindow`;
else if ($background)
	RenderViewWindow;
int $x,$y,$width,$height,$numLetters;
int $windowWidth=`getAttr SelectorWindow.sx`;
int $windowHeight=`getAttr SelectorWindow.sy`;
float $windowCornerWidth=`getAttr WindowCorner.sx`;
float $windowCornerHeight=`getAttr WindowCorner.sy`;
$windowCornerHeight=`abs($windowCornerHeight)`;
int $doMirrorBox[];
float $pos[];
string $sel[]=`ls -sl`;
string $projectName=`text -q -l asSelectorProjectName`;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/untitled/";
//string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/"+$projectName+"/";
//string $iconDir=`text -q -l asSelectorProjectPath`+$projectName+"/";
string $bgImageFile=$iconDir+"untitled_background.png";
string $bgImageFile32=$iconDir+"untitled_background32.png";
string $cmd,$keyCmd,$linearKeyCmd,$labelAttr,$iol,$multiObjAttr,$ann,$fileName;
string $alignFK2IKCmd,$alignIK2FKCmd,$switchFK2IKCmd,$switchIK2FKCmd;
string $annBuffer[];
string $renderBoxes[]=`listRelatives -c WindowCorner`;
string $renderBoxObjs[]=$renderBoxes;
for ($i=0;$i<size($renderBoxes);$i++)
	{
	if (`gmatch $renderBoxes[$i] "Button_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 8 999`;
	if (`gmatch $renderBoxes[$i] "Button?_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 9 999`;
	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<$windowWidth/2)
		{
		$numLetters=`size($renderBoxes[$i])`;
		$mirrorBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_L";
		if (!`objExists $mirrorBox`)
			{
			$doMirrorBox[$i]=1;
			$doMirrorBox[size($renderBoxes)]=1;
			$renderBoxes[size($renderBoxes)]=$mirrorBox;
			}
		}
	}

string $deleteObjs[]={"SelectorScaleSampler","SelectorCamera","SelectorFileNode","SelectorFilePlace",
	"SelectorRampU","SelectorRampV","SelectorLayeredTexture"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

float $color[3]=`displayRGBColor -q "background"`;
if (!`optionVar -ex asSelectorBGColor`)
	{
	optionVar -fv asSelectorBGColor $color[0];
	optionVar -fva asSelectorBGColor $color[1];
	optionVar -fva asSelectorBGColor $color[2];
	}
if (!`optionVar -ex asSelectorDefaultColor`)
	{
	optionVar -fv asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	}
if (!`optionVar -ex asSelectorSelColor`)
	{
	optionVar -fv asSelectorSelColor 0.2;
	optionVar -fva asSelectorSelColor 0.8;
	optionVar -fva asSelectorSelColor 0.2;
	}
if (!`optionVar -ex asSelectorKeyColor`)
	{
	optionVar -fv asSelectorKeyColor 1;
	optionVar -fva asSelectorKeyColor 0.4;
	optionVar -fva asSelectorKeyColor 0.4;
	}
float $bgColor[3]=`optionVar -q asSelectorBGColor`;
float $selColor[3]=`optionVar -q asSelectorSelColor`;
float $keyColor[3]=`optionVar -q asSelectorKeyColor`;

$tempString=`formLayout -q -ca asSelectorDefaultFormLayout`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!$background && $tempString[$i]=="asSelectorDefaultBGPicture")
		continue;
	deleteUI $tempString[$i];
	}

if ($background)
	{
	createNode -n SelectorScaleSampler transform;
	string $tempString[]=`camera -centerOfInterest 5 -focalLength 35 -lensSqueezeRatio 1 -cameraScale 1 -horizontalFilmAperture 1.4173 -horizontalFilmOffset 0 -verticalFilmAperture 0.9449 -verticalFilmOffset 0 -filmFit Fill -overscan 1 -motionBlur 0 -shutterAngle 144 -nearClipPlane 0.1 -farClipPlane 10000 -orthographic 1 -orthographicWidth 30 -panZoomEnabled 0 -horizontalPan 0 -verticalPan 0 -zoom 1`;
	rename $tempString[0] SelectorCamera;
	float $restoreRenderWidth=`getAttr defaultResolution.width`;
	float $restoreRenderHeight=`getAttr defaultResolution.height`;
	float $restoreRenderAspectLock=`getAttr defaultResolution.aspectLock`;
	int $restoreFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
	setAttr defaultRenderGlobals.imageFormat 32;
	
	setAttr "defaultResolution.aspectLock" 0;
	setAttr defaultResolution.width $windowWidth;
	setAttr defaultResolution.height $windowHeight;
	setAttr "defaultResolution.aspectLock" 1;
	setAttr defaultResolution.deviceAspectRatio ($windowWidth/($windowHeight+0.00));
	
	select SelectorWindow.vtx[0:99];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] SelectorCamera;
	move -r 0 0 1.1 SelectorCamera;
	delete `scaleConstraint SelectorWindow SelectorScaleSampler`;
	setAttr SelectorCameraShape.orthographicWidth `getAttr SelectorScaleSampler.sx`;
	if ($background==1)
		renderWindowRenderCamera render renderView SelectorCamera;
	eval ("renderWindowEditor -e -wi \""+$bgImageFile+"\" renderView");
	setParent asSelectorDefaultFormLayout;

	image -en 0 -w $windowWidth -h $windowHeight -i $bgImageFile asSelectorDefaultBGPicture;
	reloadImage $bgImageFile asSelectorDefaultBGPicture;
	formLayout -e -af asSelectorDefaultBGPicture "left" 0 -af asSelectorDefaultBGPicture "top" 0 asSelectorDefaultFormLayout;
	//32
	string $fileNode=`createNode file`;
	setAttr -type "string" ($fileNode+".fileTextureName") $bgImageFile;
	select $fileNode;
	eval ("convertSolidTx -sp 1 -al 1 -rx 32 -ry 32 -n asTempSolidTx32 -fil \"png\" -fin \""+$bgImageFile32+"\"");
	delete $fileNode asTempSolidTx32;
	evalDeferred -lp ("window -e -w "+$windowWidth+" -h "+$windowHeight+" asSelectorDefault");
	
	setAttr defaultResolution.width $restoreRenderWidth;
	setAttr defaultResolution.height $restoreRenderHeight;
	setAttr defaultResolution.aspectLock $restoreRenderAspectLock;
	setAttr defaultRenderGlobals.imageFormat $restoreFormat;
	delete SelectorCamera SelectorScaleSampler;
	if ($renderViewIconized)
		window -e -i 1 renderViewWindow;
	}

for ($i=0;$i<size($renderBoxes);$i++)
	{
	$guiBox=$renderBoxes[$i];
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		{
		$numLetters=`size($renderBoxes[$i])`;
		$guiBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_R";
		}
	$x=`getAttr ($guiBox+".tx")`*$windowWidth*$windowCornerWidth;
	$y=`getAttr ($guiBox+".ty")`*$windowHeight*$windowCornerHeight;
	$width=`getAttr ($guiBox+".sx")`*$windowWidth*$windowCornerWidth;
	$height=`getAttr ($guiBox+".sy")`*$windowHeight*$windowCornerHeight;
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		$x=$windowWidth-$x-$width;
	if ($x<0 || $x>$windowWidth || $y<0 || $y>$windowHeight)
		continue;
	if ($background)
		continue;
	if ($bgImageFile=="" || !`file -q -ex $bgImageFile`)
		error "No background image, Render a background first";
	$iol="";
	$labelAttr=`getAttr ($guiBox+".label")`;
	if ($labelAttr!="")
		$iol=$labelAttr;
	$ann=$renderBoxObjs[$i];
	$fileName=$ann;
	$multiObjAttr=`getAttr ($guiBox+".multiObjs")`;
	if ($multiObjAttr!="")
		{
		$ann=$multiObjAttr;
		$fileName="combo"+$x+$y;
		}

	createNode -n SelectorFileNode file;
	setAttr -type "string" SelectorFileNode.fileTextureName $bgImageFile;
	float $pictureWidth=`getAttr SelectorFileNode.outSizeX`;
	float $pictureHeight=`getAttr SelectorFileNode.outSizeY`;
	createNode -n SelectorFilePlace place2dTexture;
	connectAttr SelectorFilePlace.outUV SelectorFileNode.uvCoord; connectAttr -f SelectorFilePlace.outUvFilterSize SelectorFileNode.uvFilterSize; 
	connectAttr -f SelectorFilePlace.coverage SelectorFileNode.coverage; connectAttr -f SelectorFilePlace.translateFrame SelectorFileNode.translateFrame; 
	connectAttr -f SelectorFilePlace.rotateFrame SelectorFileNode.rotateFrame; connectAttr -f SelectorFilePlace.mirrorU SelectorFileNode.mirrorU; 
	connectAttr -f SelectorFilePlace.mirrorV SelectorFileNode.mirrorV; connectAttr -f SelectorFilePlace.stagger SelectorFileNode.stagger; 
	connectAttr -f SelectorFilePlace.wrapU SelectorFileNode.wrapU; connectAttr -f SelectorFilePlace.wrapV SelectorFileNode.wrapV; 
	connectAttr -f SelectorFilePlace.repeatUV SelectorFileNode.repeatUV; connectAttr -f SelectorFilePlace.vertexUvOne SelectorFileNode.vertexUvOne; 
	connectAttr -f SelectorFilePlace.vertexUvTwo SelectorFileNode.vertexUvTwo; connectAttr -f SelectorFilePlace.vertexUvThree SelectorFileNode.vertexUvThree; 
	connectAttr -f SelectorFilePlace.vertexCameraOne SelectorFileNode.vertexCameraOne; connectAttr -f SelectorFilePlace.noiseUV SelectorFileNode.noiseUV; 
	connectAttr -f SelectorFilePlace.offset SelectorFileNode.offset; connectAttr -f SelectorFilePlace.rotateUV SelectorFileNode.rotateUV;
	setAttr SelectorFilePlace.offsetU (($x+1)/$pictureWidth);
	setAttr SelectorFilePlace.offsetV (($pictureHeight-($y-1+$height))/$pictureHeight);
	setAttr SelectorFilePlace.repeatV (($height-2)/$pictureHeight);
	setAttr SelectorFilePlace.repeatU (($width-2)/$pictureWidth);

	createNode -n SelectorRampU ramp;
	createNode -n SelectorRampV ramp;
	setAttr SelectorRampU.type 1;
	setAttr SelectorRampU.interpolation 0;
	setAttr SelectorRampU.colorEntryList[1].color -type double3 0.75 0.75 0.75;
//	if ($width>2)
		setAttr SelectorRampU.colorEntryList[1].position (1-(1.00000/$width));
	setAttr SelectorRampU.colorEntryList[0].color -type double3 0 0 0;
	setAttr SelectorRampV.type 0;
	setAttr SelectorRampV.interpolation 0;
	setAttr SelectorRampV.colorEntryList[0].color -type double3 0.75 0.75 0.75;
//	if ($height>2)
		setAttr SelectorRampV.colorEntryList[1].position (1.00000/$height);
	connectAttr SelectorRampU.outColor SelectorRampV.colorEntryList[1].color;
	setAttr SelectorRampU.colorEntryList[0].position (1.00000/$width);
	setAttr SelectorRampU.colorEntryList[2].color -type double3 0.75 0.75 0.75;
	setAttr SelectorRampV.colorEntryList[0].position (1-(1.00000/$height));
	setAttr SelectorRampV.colorEntryList[2].color -type double3 0.75 0.75 0.75;


	createNode -n SelectorLayeredTexture layeredTexture;
	setAttr SelectorLayeredTexture.inputs[0].color -type double3 1 1 1 ;
	connectAttr SelectorRampV.outColorR SelectorLayeredTexture.inputs[0].alpha;
	connectAttr -f SelectorFileNode.outAlpha SelectorLayeredTexture.inputs[1].alpha;
	connectAttr -f SelectorFileNode.outColor SelectorLayeredTexture.inputs[1].color;

	string $buttonImageFileOffK0=$iconDir+$projectName+"_"+$fileName+"_OffK0.png";
	string $buttonImageFileOffK1=$iconDir+$projectName+"_"+$fileName+"_OffK1.png";
	string $buttonImageFileOnK0=$iconDir+$projectName+"_"+$fileName+"_OnK0.png";
	string $buttonImageFileOnK1=$iconDir+$projectName+"_"+$fileName+"_OnK1.png";
	
	//Off K0 version
	select SelectorLayeredTexture;
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK0+"\"");
	delete asTempSolidTx;

	//add tint now, so that selection/keyed buttons (with blank space background) are also visible
	setAttr SelectorLayeredTexture.inputs[2].alpha 0.3;
	
	//Off K1 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK1+"\"");
	delete asTempSolidTx;
	
	//On K0 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $selColor[0] $selColor[1] $selColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK0+"\"");
	delete asTempSolidTx;
	
	//On K1 version
	setAttr SelectorFileNode.colorOffset -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 ($selColor[0]+$keyColor[0]) ($selColor[1]+$keyColor[1]) ($selColor[2]+$keyColor[2]);
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK1+"\"");
	delete asTempSolidTx;
	for ($q=0;$q<size($deleteObjs);$q++)
		if (`objExists $deleteObjs[$q]`)
			delete $deleteObjs[$q];


	if (`control -q -ex $renderBoxes[$i]`)
		deleteUI $renderBoxes[$i];
	setParent asSelectorDefaultFormLayout;

	//Update cmd, popUp
	$alignFK2IKCmd=$alignIK2FKCmd=$switchFK2IKCmd=$switchIK2FKCmd="";
	if (`gmatch $renderBoxObjs[$i] "FKIK*"` && !`gmatch $renderBoxObjs[$i] "FKIKSp*ine*"`)
		{
		$alignFK2IKCmd="asAlignFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$alignIK2FKCmd="asAlignIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchFK2IKCmd="asSwitchFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchIK2FKCmd="asSwitchIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		}
	$cmd="asSelect \"Default\" {\""+$ann+"\"};";
	if (`gmatch $ann "* *"`)
		{
		tokenize $ann $annBuffer;
		$cmd="asSelect \"Default\" {";
		for ($q=0;$q<size($annBuffer);$q++)
			{
			$cmd+="\""+$annBuffer[$q]+"\"";
			if ($q<size($annBuffer)-1)
				$cmd+=",";
			}
		$cmd+="};";
		}
	$keyCmd="asKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";
	$linearKeyCmd="asLinearKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";

	$buttonName=$renderBoxObjs[$i]+":"+$x+":"+$y;
	iconTextButton -w $width -h $height -i $buttonImageFileOffK0 -iol $iol -c $cmd -ann $ann $buttonName;
	reloadImage $buttonImageFileOffK0 $buttonName;
	formLayout -e -af $buttonName "left" $x -af $buttonName "top" $y asSelectorDefaultFormLayout;

	popupMenu -p $buttonName;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asLabelButton \""+$buttonName+"\"");
		menuItem -l "Remove Button" -c ("asDeleteButton \""+$buttonName+"\"");
		if ($alignFK2IKCmd!="")
			{
			menuItem -d 1;
			menuItem -sm 1 -l "Align";
				menuItem -l "FK2IK" -c $alignFK2IKCmd;
				menuItem -l "IK2FK" -c $alignIK2FKCmd;
				setParent -menu ..;
			menuItem -sm 1 -l "Switch";
				menuItem -l "FK2IK" -c $switchFK2IKCmd;
				menuItem -l "IK2FK" -c $switchIK2FKCmd;
			}
	}


select $sel;
}

global proc asLabelButton (string $button)
{
string $result=`promptDialog -t "Label" -b "Ok"  -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($result!="Ok")
	return;
iconTextButton -e -iol (`promptDialog -q -tx`) $button;
if (`promptDialog -q -tx`=="All")
	iconTextButton -e -ann "ControlSet" $button;
//asSelectorRefresh;
}
//-- ASSelectorDesigner Procedures Ends Here --//

//-- ASPoserDesigner Procedures Starts Here --//
global proc asPoserDesigner ()
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
int $nc=`optionVar -q asPoserNc`;
if ($nc<1)
	$nc=4;
int $nr=`optionVar -q asPoserNr`;
if ($nr<1)
	$nr=2;
string $poserText=`optionVar -q asPoserText`;
if ($poserText=="0")
	$poserText="Pose";
int $onlySel=`optionVar -q asPoserOnlySel`;
int $anim=`optionVar -q asPoserAnim`;
int $renderView=`optionVar -q asPoserRenderView`;
string $controlSets[]=`asGetControlSets`;

if (`window -q -ex asPoserDefault`)
	deleteUI asPoserDefault;
window -mb 1 -t "PoserDesigner :untitled" asPoserDefault;
menu "File";
	menuItem -c asPoserDesigner "New";
	menuItem -c "asfileBrowse Poser Open" "Open";
	menuItem -sm 1 -l "ControlSets" asPoserControlSetsMenu;
		menuItem -cb 1 -l ControlSet asPoserControlSetsMenuItemControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if ($controlSets[$i]!="ControlSet")
				menuItem -cb 0 -l $controlSets[$i] ("asPoserControlSetsMenuItem"+$controlSets[$i]);
		setParent -menu ..;
	menuItem -d 1;
	menuItem -c "asSave Poser" "Save";
	menuItem -c "asfileBrowse Poser SaveAs" "Save As";
	menuItem -c "astoShelf Poser" "Put on shelf";
	setParent -menu ..;
	menuItem -d 1;
	menuItem -c "deleteUI asPoserDefault" "Close";
	setParent -menu ..;
formLayout asPoserDefaultFormLayout;
	text -vis 0 -l (`internalVar -utd`+"AdvancedSkeleton/Poser/") asPoserProjectPath;
	text -vis 0 -l ("untitled") asPoserProjectName;
	rowLayout -adj 1 -nc 8 -cw 2 90 -cw 3 80 -cw 4 90 -cw 5 50 -cw 6 20 -cw 7 25 asPoserDefaultRowLayout;
		optionMenu asPoserDefaultOptionMenu;
		button -l "    New Pose    " -c "asNewPose {} 0";
		textField -w 70 -tx $poserText -cc asPoserUpdateGrid asPoserTextField;
		checkBox -v $onlySel -l "only selected" -cc asPoserUpdateGrid asPoserOnlySel;
		checkBox -v $anim -l "anim" -cc asPoserUpdateGrid asPoserAnim;
		intField -w 20 -v $nc -cc asPoserUpdateGrid asPoserNc;
		intField -w 20 -v $nr -cc asPoserUpdateGrid asPoserNr;
		checkBox -v $renderView -l "renderView" -cc asPoserUpdateGrid asPoserRenderView;
		setParent..;
//	scrollLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
//	cannot use scrollLayout cause it returns incorrect drop coordinates when scrolled.
	columnLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
		gridLayout -h (90*$nr) -nc $nc -nr $nr -cw 110 -ch 90 asPoserDefaultGridLayout;

formLayout -e
	-af asPoserDefaultRowLayout "top" 0
	-ac asPoserDefaultScrollayout "top" 0 asPoserDefaultRowLayout
	-af asPoserDefaultScrollayout "bottom" 0
	-af asPoserDefaultScrollayout "left" 0
	-af asPoserDefaultScrollayout "right" 0
	asPoserDefaultFormLayout;

asPopulateNameSpaceMenu "asPoserDefault";

//Remove Old Icons
string $oldFilesList[]=`getFileList -fld $iconDir`;
for ($file in $oldFilesList)
	sysFile -del ($iconDir+$file);

showWindow asPoserDefault;
}

global proc asNewPose (string $loadData[], int $anim)
{
global int $asfileLoading;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $setParent=`setParent -q`;
string $uiName,$image,$label,$cmd,$mayaFile,$loadingMayaFile;
int $nc,$nr,$numTok,$singleAttr;
float $range[2]={0,1};
string $buffer[];
if ($loadData[0]=="" || $asfileLoading)
	{
	$nc=`intField -q -v asPoserNc`;
	$nr=`intField -q -v asPoserNr`;
	$uiName="asPoserDefault";
	}
else
	$uiName=$loadData[0];
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
string $gridOrder[]=`gridLayout -q -go ($uiName+"GridLayout")`;
int $lastFilled,$childNum;
//Find Last filled
for ($i=1;$i<size($gridOrder)+1;$i++)
	if (`gmatch $gridOrder[$i-1] "asPoser*"`)
		$lastFilled=$i;
$childNum=$lastFilled+1;

//Total full
if ($childNum>($nc*$nr) && $loadData[0]=="")
	error "Grid is full, extend rows or columns !\n";

if ($loadData[0]=="")
	{
	if (`optionMenu -q -v asPoserDefaultOptionMenu`=="None")
		error "No Character In The Scene\n";
	$anim=`checkBox -q -v asPoserAnim`;
	$cmd=`asPoserGetCmd $uiName $anim`;
	if ($cmd=="")
		error "No valid objects !\n";
	$image=`asPoserSnapShoot $uiName $childNum $anim 1 1`;
	if ($anim && $cmd!="")
		$cmd+=" "+$childNum;
	if (`about -mac`)
		showWindow asPoserDefault;
	$label=`textField -q -tx asPoserTextField`;
	}
else
	{
	$childNum=$loadData[4];
	$numTok=`tokenize $loadData[1] "/" $buffer`;
	$image=$iconDir+"untitled_"+$childNum+"."+$ext;
	sysFile -cp $image $loadData[1];
	$mayaFile=`substitute "[.][a-z][a-z][a-z]" $image ".ma"`;
	$loadingMayaFile=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".ma"`;
	if (`file -q -ex $loadingMayaFile`)
		sysFile -cp $mayaFile $loadingMayaFile;
	$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
	$loadingJpg=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".jpg"`;
	if (`file -q -ex $loadingJpg`)
		sysFile -cp $jpg $loadingJpg;
	$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
	$loadingAvi=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".avi"`;
	if (`file -q -ex $loadingAvi`)
		sysFile -cp $avi $loadingAvi;
	$label=$loadData[2];
	$cmd=$loadData[3];
	if ($asfileLoading)
		$cmd=`substitute $loadData[0] $cmd $uiName`;
	$anim=$loadData[5];
	}
$numTok=`tokenize $cmd ";" $buffer`;
if ($numTok==2)
	$singleAttr=1;
setParent ($uiName+"GridLayout");
columnLayout ($uiName+"ColumnLayout"+$childNum);
gridLayout -e -pos ($uiName+"ColumnLayout"+$childNum) $childNum ($uiName+"GridLayout");
rowColumnLayout -ann $anim -nc 2 -cw 1 100 -cw 2 15 ($uiName+"RowColumnLayout"+$childNum);
	iconTextButton -w 100 -h 75 -i $image -c $cmd ($uiName+"IconTextButton"+$childNum);
	floatSlider -m 0 -w 10 -h 75 -hr 0 ($uiName+"FloatSlider"+$childNum);
	text -h 15 -al "center" -fn "smallBoldLabelFont" -l $label ($uiName+"Text"+$childNum);
if ($anim)
	text -e -bgc 1 0 0 ($uiName+"Text"+$childNum);
if ($loadData[0]=="" || $asfileLoading)
	{
	asPoserupdateGridBlock $uiName $childNum;
	iconTextButton -e -dgc asPoserDgc -dpc asPoserDpc ($uiName+"IconTextButton"+$childNum);
	}

//connectControl
string $connectToObj,$connectToAttr,$resolvedDestination;
string $allKeyableAttrs[];
if ($singleAttr)
	{
	tokenize $cmd "\"" $buffer;
	tokenize $buffer[1]  $buffer;
	tokenize $buffer[0] "." $buffer;
	$connectToObj=$buffer[0];
	$connectToAttr=$buffer[1];
	$resolvedObj=`asPoserResolveNameSpace $uiName $connectToObj`;
	if (`objExists $resolvedObj`)
		$allKeyableAttrs=`listAttr -k -m -sn $resolvedObj`;

	for ($allKeyableAttr in $allKeyableAttrs)
		if ($connectToAttr==$allKeyableAttr)
			if (`getAttr -se ($resolvedObj+"."+$connectToAttr)`)
					{
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						if (!`attributeQuery -n $resolvedObj -re $connectToAttr`)
							break;
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						$range=`attributeQuery -n $resolvedObj -r $connectToAttr`;
					else
						//probably a muli attr  e.g. blenShape target..using range 0->1
						$range={0,1};
					floatSlider -ann ($connectToObj+"."+$connectToAttr) -e -m 1 -min $range[0] -max $range[1] ($uiName+"FloatSlider"+$childNum);
					connectControl ($uiName+"FloatSlider"+$childNum) ($resolvedObj+"."+$connectToAttr);
					text -e -l $connectToAttr ($uiName+"Text"+$childNum);
					}
	}
setParent $setParent;
}

global proc asPoserUpdateGrid ()
{
int $nc=`intField -q -v asPoserNc`;
optionVar -iv asPoserNc $nc;
int $nr=`intField -q -v asPoserNr`;
optionVar -iv asPoserNr $nr;
string $poserText=`textField -q -tx asPoserTextField`;
optionVar -sv asPoserText $poserText;
int $onlySel=`checkBox -q -v asPoserOnlySel`;
optionVar -iv asPoserOnlySel $onlySel;
int $anim=`checkBox -q -v asPoserAnim`;
optionVar -iv asPoserAnim $anim;
int $renderView=`checkBox -q -v asPoserRenderView`;
optionVar -iv asPoserRenderView $renderView;

if ($nc<1)
	{
	intField -e -v 1 asPoserNc;
	asPoserUpdateGrid;
	return;
	}
if ($nr<1)
	{
	intField -e -v 1 asPoserNr;
	asPoserUpdateGrid;
	return;
	}
gridLayout -e -nc $nc -nr $nr -w (110*$nc) -h (90*$nr) asPoserDefaultGridLayout;
}

global proc asPoserRename (int $childNum)
{
if (!`text -q -ex ("asPoserDefaultText"+$childNum)`)
	error "Cant find `text` uiElement\n";
string $oldname=`text -q -l ("asPoserDefaultText"+$childNum)`;
string $result=`promptDialog -m "Name:" -tx $oldname -t ("AdvancedSkeleton") -b "Ok" -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($result=="Cancel")
	return;
string $newName=`promptDialog -q -tx`;
text -e -l $newName ("asPoserDefaultText"+$childNum);
}

global proc asPoserDeletePose (string $uiName, int $num)
{
string $image=`iconTextButton -q -i ($uiName+"IconTextButton"+$num)`;
$jpgImage=`substitute "[.]png" $image ".jpg"`;
$jpgImage=`substitute "[.]xpm" $jpgImage ".jpg"`;
sysFile -del $image;
sysFile -del $jpgImage;

evalDeferred ("deleteUI "+$uiName+"ColumnLayout"+$num);
}

global proc string asPoserSnapShoot (string $uiName, int $childNum, int $anim, int $updateIcon, int $updateMovie)
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
int $renderView=`checkBox -q -v asPoserRenderView`;
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;

int $curFrame=`currentTime -q`;
int $startFrame=$endFrame=$curFrame;
int $currFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
string $huds[]=`headsUpDisplay -listHeadsUpDisplays`;
int $hudStates[];
for ($i=0;$i<size($huds);$i++)
	{
	$hudStates[$i]=`headsUpDisplay -q -vis $huds[$i]`;
	headsUpDisplay -e -vis 0 $huds[$i];
	}
string $ext;
if (`asMayaVersionAsFloat`>=2011)
	{
	$ext="png";
	setAttr "defaultRenderGlobals.imageFormat" 32;
	}
else
	{
	$ext="xpm";
	setAttr -type "string" defaultRenderGlobals.imfPluginKey "xpm";
	setAttr defaultRenderGlobals.imageFormat 50;
	}
string $fileName=$iconDir+"untitled_"+$childNum;
string $iconImage=$fileName+"."+$ext;
string $blastImage=$fileName+"."+`asDoPadd $curFrame 4`;
string $blastMovie=$fileName+".avi";
string $largeImage=$fileName+".jpg";
string $bgImageFile32=$iconDir+"untitled_background32."+$ext;
int $iconExists;
if (`file -q -ex $iconImage`)
	$iconExists=1;
		
if ($renderView && $updateIcon)
	{
	if (`renderWindowEditor -q -nim renderView`<0)
		error ("No Image In RenderView\n");
	eval ("renderWindowEditor -e -wi \""+$iconImage+"\" renderView");
	asPoserResizeImage 100 75 $iconImage $iconImage;
	setAttr defaultRenderGlobals.imageFormat 8;
	evalEcho ("renderWindowEditor -e -wi \""+$largeImage+"\" renderView");
	}
if (!$renderView && $updateIcon)
	{
	playblast -w 100 -h 75 -compression "png" -p 100 -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $iconImage ($blastImage+"."+$ext);
	}

setAttr defaultRenderGlobals.imageFormat 8;

if ($anim && $updateMovie)
	playblast -p 100 -st `playbackOptions -q -min` -et `playbackOptions -q -max` -f $fileName -fmt movie -fo -clearCache 0 -viewer 0 -showOrnaments 0;
else if ($updateIcon)
	{
	playblast -p 100 -compression "png" -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $largeImage ($blastImage+".jpg");
	}
setAttr defaultRenderGlobals.imageFormat $currFormat;
for ($i=0;$i<size($huds);$i++)
	headsUpDisplay -e -vis $hudStates[$i] $huds[$i];


if (`about -linux`)
	$iconImage=`asConvertToXpm $iconImage`;

//32x32
if (!`file -q -ex $bgImageFile32`)
	{
	asPoserResizeImage 32 32 $iconImage $bgImageFile32;
	if (`about -linux`)
		asConvertToXpm $bgImageFile32;
	}

if ($iconExists)
	reloadImage $iconImage ($uiName+"IconTextButton"+$childNum);
return $iconImage;
}

global proc asPoserResizeImage (int $x, int $y, string $inputImage, string $outputImage)
{
string $sel[]=`ls -sl`;
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
string $uniqueFileName=`asUniqueFile $inputImage`;
string $fileNode=`createNode file`;
setAttr -type "string" ($fileNode+".fileTextureName") $uniqueFileName;
eval ("convertSolidTx -sp 1 -al 1 -rx "+$x+" -ry "+$y+" -n asTempSolidTx32 -fil \""+$buttonImageFileExt+"\" -fin \""+$outputImage+"\"");
delete $fileNode asTempSolidTx32;
sysFile -del $uniqueFileName;
select $sel;
}

global proc string asDoPadd (int $frameNr,int $padding)
{
string $frameName;
string $padd="";
string $neg="";
string $frameNrAsString=$frameNr;
for ($i=0;$i<$padding;$i++)
	$padd=$padd+"0";
//move the negative symbol to start of string//
if ($frameNr<0)
	$neg="-";
int $nr=`size ($frameNrAsString)`;
if ($padding>$nr)
	$frameName=$neg+`substring $padd ($nr+1) 999`+abs($frameNr);
else
	$frameName=$frameNr;
return $frameName;
}

global proc string[] asPoserDgc (string $dragControl, int $x, int $y, int $mods) 
{
string $return[];
$return[0]=$x;
$return[1]=$y;
$return[2]=$mods;
return $return;
}

global proc asPoserDpc (string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) 
{
//print ("$dragControl="+$dragControl+" $dropControl="+$dropControl+" $msgs[3]="+$msgs[3]+" $msgs[1]="+$msgs[1]+" $x="+$x+" $y="+$y+" $type="+$type+"\n");
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (`gmatch $dropControl "*IconTextButton*"`)
	return;
int $left=$msgs[0];
int $top=$msgs[1];

int $nc=`intField -q -v asPoserNc`;
int $nr=`intField -q -v asPoserNr`;
	
string $match=`match "[0-9]+$" $dragControl`;
int $oldChildNum=$match;
int $newRowNum=ceil(($x+0.00)/110);
int $newColNum=ceil(($y+0.00)/90);
int $newChildNum=$newRowNum+(($newColNum-1)*$nc);
if ($newChildNum==$oldChildNum)
	return;
if ($newChildNum>($nc*$nr))
	error "out of grid, extend rows or columns !\n";
string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
if (`gmatch $gridOrder[$newChildNum-1] "asPoser*"`)
	error "grid position is occupied !\n";
gridLayout -e -pos ("asPoserDefaultColumnLayout"+$oldChildNum) $newChildNum asPoserDefaultGridLayout;

//rename UI elements
string $children[]=`layout -q -ca ("asPoserDefaultColumnLayout"+$oldChildNum)`;
$children[size($children)]="asPoserDefaultColumnLayout"+$oldChildNum;
string $grandChildren[]=`layout -q -ca $children[0]`;
string $allChildren[]=`stringArrayCatenate $children $grandChildren`;
string $tempString[];
string $cmd;
int $numDigitsInIldChildNum=size($match);
int $numDigitsInChild;
int $numDigitsInImage;
string $newChildName,$image,$animFile,$newAnimFile;
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
for ($child in $allChildren)
	{
	$numDigitsInChild=size($child);
	string $newChildName=`substring $child 1 ($numDigitsInChild-$numDigitsInIldChildNum)`+$newChildNum;
	renameUI $child $newChildName;

	//rename bitmaps
	if (!`iconTextButton -q -ex $newChildName`)
		continue;
	$image=`iconTextButton -q -i $newChildName`;
	$numDigitsInImage=size($image);
	$newImage=`substring ("\""+$image+"\"") 2 ($numDigitsInImage-3-$numDigitsInIldChildNum)`+$newChildNum+"."+$ext;
	if (`file -q -ex $image` && $newImage!=$image)
		{
		eval ("sysFile -ren \""+$newImage+"\"  \""+$image+"\"");
		iconTextButton -e -i $newImage $newChildName;
		reloadImage $newImage $newChildName;
		$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		if (`file -q -ex $jpg`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".jpg"` `substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		if (`file -q -ex $avi`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".avi"` `substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		}
	//rename anim files
	$animFile=$iconDir+"untitled_"+$oldChildNum+".ma";
	$newAnimFile=$iconDir+"untitled_"+$newChildNum+".ma";
	if (`file -q -ex $animFile` && $newAnimFile!=$animFile)
		eval ("sysFile -ren \""+$newAnimFile+"\"  \""+$animFile+"\"");
	//update animation command
	$cmd=`iconTextButton -q -c $newChildName`;
	tokenize $cmd $tempString;
	if ($tempString[0]=="asLoadAttrs")
		{
		$cmd=$tempString[0]+" "+$tempString[1]+" "+$newChildNum;
		iconTextButton -e -c $cmd $newChildName;
		}
	}
string $uiName="asPoserDefault";
asPoserupdateGridBlock $uiName $newChildNum;
}
//-- ASPoserDesigner Procedures Ends Here --//
//-- ASWalkDesigner Procedures Start Here --//
global proc asWalkDesigner ()
{
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
//create, connectControl, and delete, to disable.
int $mixerExisted=1;
if (!`objExists WalkDesignerMotionMixer`)
	{
	createNode -n WalkDesignerMotionMixer transform;
	addAttr -k 1 -dv 1 -ln "speed" -at double WalkDesignerMotionMixer;
	$mixerExisted=0;
	}
if (`window -q -ex asWalkDesigner`)
	deleteUI asWalkDesigner;
window -mb 1 -t WalkDesigner asWalkDesigner;
formLayout asWDFormLayout;
columnLayout;
optionMenu -w 200 asWalkDesignerOptionMenu;
button -l "Start" -c asWDStart;
columnLayout asWDMixerColumnLayout;
for($i=0;$i<size($motions);$i++)
	{
	if(!$mixerExisted)
		addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	rowLayout -nc 2 -cw2 240 100;
		floatSliderGrp -label $motions[$i] -field true -cw 1 80 -cw 2 50 -cw 3 100 -min 0 -max 1 ("asWDField"+$i);
		connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
		button -l "solo" -c ("asWDSolo "+$i);
		setParent..;
	}
floatSliderGrp -cc asWDSpeedChange -pre 2 -v 1 -label "speed" -field true -cw 1 40 -cw 2 40 -cw 3 180 -min 0.01 -max 2 asWDSpeedField;
connectControl asWDSpeedField WalkDesignerMotionMixer.speed;
if (`asIsMayaLT`)
	floatSliderGrp -e -en 0 asWDSpeedField;
setParent..;

frameLayout -w 279 -cll 1 -cl 1 -l "Baking";
columnLayout;
//text -l "baking:";
checkBox -cc asWDSpeedChange -l "loop animation (curves > post infinity > cycle)" -v 1 -onc "intField -e -en 0 asWDLoopsIntField" -ofc "intField -e -en 1 asWDLoopsIntField" asWDLoopCheckBox;
text -l "or";
rowLayout -nc 3;
	text -l "loop animation";
	intField -cc asWDSpeedChange -en 0 -w 30 -min 1 -v 1 asWDLoopsIntField;
	text -l "times";
	setParent..;
button -l "Ok, Bake keys onto character" -c asWDBake;
setParent..;
setParent..;
setParent..;
button -l "Cancel and Close" -c asWDFinish asWDClose;
formLayout -e 
	-attachForm asWDClose "bottom" 0
	-attachForm asWDClose "left" 0
	-attachForm asWDClose "right" 0
	asWDFormLayout;

asPopulateNameSpaceMenu "asWalkDesigner";
if(!$mixerExisted)
	delete WalkDesignerMotionMixer;
showWindow;
}

global proc asWDBake ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
select -cl;
string $allFkControls[];
for($i=0;$i<size($consts);$i++)
	{
	string $fkControl=$nameSpace+"FK"+$consts[$i];
	if ($consts[$i]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	$allFkControls[size($allFkControls)]=$fkControl;
	select -add $fkControl;
	}

if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}

bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "rx" -at "ry" -at "rz";
select ($nameSpace+"RootX_M");
bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "tx" -at "ty" -at "tz";
if (`checkBox -q -v asWDLoopCheckBox`)
	{
	select $allFkControls;
	setInfinity -poi cycle;
	}
asWDFinish;
}

global proc asWDSpeedChange ()
{
if (!`objExists WalkDesignerMotionMixer` || !`objExists walkDesignerClip`)
	return;
float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);
if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr walkDesignerClip.scale (1.0/$speed);
}

global proc asWDStart ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";
if (!`objExists ($nameSpace+"Main")`)
	error ("AdvancedSkeleton not found in your scene");
float $charHeight=`getAttr ($nameSpace+"Main.height")`;

string $motionFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asMotion.ma";
if (!`file -q -ex $motionFile`)
	error ("Not found:"+$motionFile);
if (`objExists WalkDesignerMotionMixer`)
	error ("\"WalkDesignerMotionMixer\", already exists, delete this object, before starting again");
if (!`file -q -ex $motionFile`)
	error ("Required motion file not found:\""+$motionFile+"\"");
string $tempString[]=`ls "asMotion:*"`;
if (size($tempString))
	delete $tempString;
if (`namespace -ex "asMotion"`)
	if (catchQuiet (`namespace -dnc -rm "asMotion"`))
		{ 
		//Maya2012 and older dont have namespace -dnc, so we work around the problems of empty nameSpaces not agknowlowdge their empty
		for($i=0;$i<99;$i++)
			if (!`namespace -ex ("tempNameSpace"+$i)`)
				break;
		namespace -ren asMotion ("tempNameSpace"+$i);
		}
if (`namespace -ex "asMotion"`)
	error "Unable to remove namespace \"asMotion\", try restarting Maya";
$tempString=`listConnections time1.timewarpIn_Raw`;
if (size($tempString))
	delete $tempString;
if (!`asIsMayaLT`)
	AddTimeWarp;

file -ns "asMotion" -i $motionFile;
setAttr asMotion:Group.v 0;
setAttr -type float3 asMotion:Group.s ($charHeight/12.0) ($charHeight/12.0) ($charHeight/12.0);

createNode -n WalkDesignerMotionMixer transform;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.tx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ty;setAttr -l 1 -k 0 WalkDesignerMotionMixer.tz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.rx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ry;setAttr -l 1 -k 0 WalkDesignerMotionMixer.rz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.sx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sy;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.v;
addAttr -k 1 -ln "speed" -dv 1 -at double WalkDesignerMotionMixer;
addAttr -k 0 -ln defaultEndTime -at double WalkDesignerMotionMixer;
parent "asMotion:Group" WalkDesignerMotionMixer;

select -hi "asMotion:Group";
select -d "asMotion:Group";
if (!`asIsMayaLT`)
	{
	character -name walkDesignerSet -excludeVisibility -excludeScale;
	clip -name walkDesignerClip -sc 1 -allAbsolute -animCurveRange walkDesignerSet;
	setAttr walkDesignerClip.postCycle 9999;
	}

if (`objExists ($nameSpace+"FKIKLeg_R")`) setAttr ($nameSpace+"FKIKLeg_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKLeg_L")`) setAttr ($nameSpace+"FKIKLeg_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_R")`) setAttr ($nameSpace+"FKIKArm_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_L")`) setAttr ($nameSpace+"FKIKArm_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKSpine_M")`) setAttr ($nameSpace+"FKIKSpine_M.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKShoulder_R")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_R")`) setAttr ($nameSpace+"FKShoulder_R.Global") 0;
if (`objExists ($nameSpace+"FKShoulder_L")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_L")`) setAttr ($nameSpace+"FKShoulder_L.Global") 0;
if (`objExists ($nameSpace+"FKWrist_R")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_R")`) setAttr ($nameSpace+"FKWrist_R.Global") 0;
if (`objExists ($nameSpace+"FKWrist_L")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_L")`) setAttr ($nameSpace+"FKWrist_L.Global") 0;
if (`objExists ($nameSpace+"FKHead_M")`) if (`attributeExists "Global"  ($nameSpace+"FKHead_M")`) setAttr ($nameSpace+"FKHead_M.Global") 0;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
string $orientConstraint,$pointConstraint;

for($i=0;$i<size($motions);$i++)
	{
	addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	for($y=0;$y<size($consts);$y++)
		{
		$fkControl=$nameSpace+"FK"+$consts[$y];
		if ($consts[$y]=="Root_M")
			{
			$fkControl=$nameSpace+"RootX_M";
			$tempString=`pointConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
			$pointConstraint=$tempString[0];
			}
		if (!`objExists $fkControl`)
			continue;
		$tempString=`orientConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
		$orientConstraint=$tempString[0];
		setAttr ($orientConstraint+".interpType") 2;

		if ($consts[$y]=="Root_M")
			{
			setAttr RootX_M_orientConstraint1.offsetX -90;
			setAttr RootX_M_orientConstraint1.offsetY -90;
			connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($pointConstraint+"."+$consts[$y]+"W"+$i);
			}
		connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($orientConstraint+"."+$consts[$y]+"W"+$i);
		}
	connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";
	setAttr ("FKHip"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKKnee"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKAnkle"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKToes"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKShoulder"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKElbow"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKWrist"+$side+"_orientConstraint1.offsetX") -90;
	}

connectControl asWDSpeedField WalkDesignerMotionMixer.speed;

if (`attributeExists walk_male WalkDesignerMotionMixer`)
	setAttr WalkDesignerMotionMixer.walk_male 1;
currentTime 0;
if (`objExists ($nameSpace+"FKAnkle_R")` && `objExists ($nameSpace+"Ankle")`)
	{
	float $anklePos[3]=`xform -q -ws -t ($nameSpace+"FKAnkle_R")`;
	float $fitAnklePos[3]=`xform -q -ws -t ($nameSpace+"Ankle")`;
	float $offset=$anklePos[1]-$fitAnklePos[1];
	setAttr asMotion:Group.ty ($offset*-1);
	}
float $tempFloats[]=`keyframe -index 1 -q  -tc asMotion:Group.timing`;
float $endTime=$tempFloats[0];
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr WalkDesignerMotionMixer.defaultEndTime $endTime;
select -cl;
}

global proc asWDSolo (int $num)
{
if (!`objExists WalkDesignerMotionMixer`)
	error ("WalkDesignerMotionMixer not found");
float $value;
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
for($i=0;$i<size($motions);$i++)
	{
	if ($i==$num)
		$value=1;
	else
		$value=0;
	floatSliderGrp -e -v $value ("asWDField"+$i);
	setAttr ("WalkDesignerMotionMixer."+$motions[$i]) $value;
	}
}

global proc asWDFinish ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

if (`objExists walkDesignerSet`)
	delete walkDesignerSet;
if (`objExists WalkDesignerMotionMixer`)
	delete WalkDesignerMotionMixer;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Chest_M","Chest_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $tempString[];
string $attrs[]={"tx","ty","tz","rx","ry","rz"};
for($y=0;$y<size($consts);$y++)
	{
	$fkControl=$nameSpace+"FK"+$consts[$y];
	if ($consts[$y]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	for($i=0;$i<size($attrs);$i++)
		{
		$tempString=`listConnections ($fkControl+"."+$attrs[$i])`;
		if (!size($tempString))
			setAttr ($fkControl+"."+$attrs[$i]) 0;
		}
	}
deleteUI asWalkDesigner;
}
//-- ASWalkDesigner Procedures Ends Here --//
//-- ASModelCleaner Procedures Starts Here --//
global proc asModelCleaner ()
{
if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

window -s 1 -title "Model Cleaner" modelCleaner;
columnLayout;
	separator -st none -h 10;
	text -l "This will cleanup your model.\n";
	if (!`pluginInfo -q -l objExport`)
		{
		text -l "The objExport plugin must be loaded:";
		button -l "load objExport plugin" -c "loadPlugin objExport;print (\"// OK, objExport plugin loaded\\n\")";
		separator -h 10 -st none;
		}
	text -l "Create top level group, called \"geo\":";
	button -c modelCleanGreateGeo -label "Create";
	separator -st none -h 10;
	text -l "Now ready for Clean.";
	text -fn "smallBoldLabelFont" -l "(Save your scene first, for safe keeping)\n";
	button -w 230 -c modelCleanGo -ann "clean model" -label "Clean";
showWindow modelCleaner;
}

global proc modelCleanGreateGeo ()
{
if (!`objExists |geo`)
	createNode -n geo transform;
string $tempString[];
string $topLevXforms[]=`ls -as -l`;
for($i=0;$i<size($topLevXforms);$i++)
	{
	if ($topLevXforms[$i]=="|geo")
		continue;
	$tempString=`listRelatives -s $topLevXforms[$i]`;
	if (`size ($tempString)`==0 || `objectType $tempString[0]`=="mesh")
		parent $topLevXforms[$i] |geo;
	}
select |geo;
}

global proc modelCleanGo ()
{
global string $gMainProgressBar;
global string $gMainPane;
string $sceneName=`file -q -sn`;
string $references[];
string $allReferences[]=`file -q -r`;
for ($i=0;$i<size($allReferences);$i++)
	if (!`file -q -deferReference $allReferences[$i]`)
		$references[size($references)]=$allReferences[$i];

select -cl;

string $sceneFile=`file -q -sn`;
string $tmpFile=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/tmp.ma";
if (`asIsMayaLT`)
	$tmpFile=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/tmp.mlt";
int $eyeCandy=0;
int $moreThanOneWithSameName;
string $plugins[]=`pluginInfo -q -ls`;
string $parent[],$tempString[],$longNames[],$buffer[],$oldShapeName[],$partitionPlugs[],$creaseMembers[],$objFileName[];
float $temp[];
float $perspPos[]=`getAttr persp.translate`;
float $perspRot[]=`getAttr persp.rotate`;
int $isGroup[];
int $doubleSided[];
for ($plug in $plugins)
	if (!`stringArrayCount "objExport" $plugins`)
	error "You Must Load the \"objExport\" plugin !";

string $tempDir=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/";
if (!`file -q -ex $tempDir`)
	sysFile -md $tempDir;

//Pre Flight Check
if (!`objExists geo`)
	error "group \"geo\" does not exists !\n";
string $all[]=`ls -noIntermediate`;
for ($obj in $all)
	{
	if (`gmatch $obj "*|*"`)
		{
		$tempString=`listRelatives -ap $obj`;
		if (size($tempString)==1)
			{
			select -add $obj;
			$moreThanOneWithSameName=1;
			}
		}
	}
if ($moreThanOneWithSameName)
	modelCleanMakeUniqueNames;
if (`objExists "polySurface1"`)
	{
	select "polySurface1";
	error "Illegal objectName \"polySurface1\"";
	}

//delete imagePlanes
string $imagePlanes[]=`ls -type imagePlane`;
if (size($imagePlanes))
	delete $imagePlanes;

//delete unused refNodes
deleteUnusedRefNodes;

//unParent all place3dTextures
string $place3ds[]=`ls -type place3dTexture`;
for ($i=0;$i<size($place3ds);$i++)
{
$tempString=`listRelatives -p $place3ds[$i]`;
if(size($tempString))
	parent -w $place3ds[$i];
}

//remove old files
string $fileList[]=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size( $fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Remove nameSpaces
$all=`ls -type transform`;
for ($i=0;$i<size($all);$i++)
    if (`gmatch $all[$i] "*:*"`)
        {
        tokenize $all[$i] ":" $tempString;
        rename $all[$i] $tempString[size($tempString)-1];
        }

//rename Shapes to match name of their Xform
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
    	$tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"TEMPShape");
    	}
$meshes=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
	    $tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"Shape");
    	}

DeleteAllHistory;

//createShaderAssigner
string $assigned[], $shadingEngines[], $namespaces[];
string $allTrns[]=`ls -type transform`;
string $place3dTextures[]=`ls -type place3dTexture`;
if (`objExists shaderAssign`) 
	delete shaderAssign;
createNode -n shaderAssign transform;
addAttr -ln notes -dt "string" shaderAssign;
$shadingEngines=`ls -type shadingEngine`;
string $connections = ("global proc cleanConnectFileNodes(string $namespace1, string $namespace2) {\n");
for ($i=0;$i<size($shadingEngines);$i++) {
	if (`gmatch $shadingEngines[$i] "initial*"`)
		continue;
	$assigned=`sets -q $shadingEngines[$i]`;
	for ($z=0;$z<size($assigned);$z++)
		{
		//per face assigment
//		tokenize $assigned[$z] "." $tempString;
//		$assigned[$z]=$tempString[0];
		}
	$assigned=`stringArrayRemoveDuplicates $assigned`;
	for ($z=0;$z<size($assigned);$z++) 
		{
//		$tempString=`listRelatives -p $assigned[$z]`;
//		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$tempString[0]+"\")`);\n");
		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$assigned[$z]+"\")`);\n");
		}
}
for ($z=0;$z<size($place3dTextures);$z++) {
	$tempString=`listConnections -p 1 ($place3dTextures[$z]+".worldInverseMatrix")`;
	$connections+=("catch(`connectAttr ($namespace2 + \"" +$place3dTextures[$z]+".worldInverseMatrix\") ($namespace1 + \""+$tempString[0]+"\")`);\n");
}
$connections += ("}\n");
setAttr -type "string" shaderAssign.notes $connections;

//exportShaders
string $hyperShadePanelMelFile="C:/Program Files/Autodesk/Maya2012/scripts/others/hyperShadePanel.mel";
if (`file -q -ex$hyperShadePanelMelFile `)
eval ("source \""+$hyperShadePanelMelFile+"\"");
hyperShadePanelMenuCommand("", "deleteUnusedNodes");
string $shadingNodes[]=`lsThroughFilter -na DefaultAllShadingNodesFilter`;
string $objectType;
select -cl;
for ($i=0;$i<size($shadingNodes);$i++)
	{
	$objectType=`objectType $shadingNodes[$i]`;
	if ($objectType=="camera" || `gmatch $objectType "*Light"`)
		continue;
	select -add -ne $shadingNodes[$i];
	}
select -add shaderAssign;
lockNode -l 0 renderPartition;
if (`file -q -ex $tmpFile`)
	sysFile -del $tmpFile;
if (`asIsMayaLT`)
	file -op "v=0;" -typ "mayaLT" -es $tmpFile;
else
	file -op "v=0;p=17" -typ "mayaAscii" -es $tmpFile;

//delete intermediateObjects meshes
$tempString=`ls -intermediateObjects -type mesh`;
if (size($tempString))
	delete $tempString;

// SelectAllPolygonGeometry;
select geo;
select -hi;
string $selAll[]=`ls -l -sl -type transform`;

// read all attribute + their values, to restore after obj import
 string $userAttrs[],$addAttrCmds[];
string $cmd,$sn,$ln,$at,$kk,$dv,$minMax;
float $range[2];
string $shapes[];
string $selAllInclShapes[]=$selAll;
for ($i=0;$i<size($selAll);$i++)
	{
	$tempString=`listRelatives -s $selAll[$i]`;
	if (`objExists $tempString[0]`)
		$shapes[`size($shapes)`]=$tempString[0];
	}
appendStringArray $selAllInclShapes $shapes `size($shapes)`;
for ($i=0;$i<size($selAllInclShapes);$i++)
	{
 	$userAttrs=`listAttr -ud -s $selAllInclShapes[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		if (`getAttr -type ($selAllInclShapes[$i]+"."+$userAttrs[$y])`=="message")
			continue;
		$tempString=`listAttr -sn ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if (`gmatch $at "*Array"` || `gmatch $at "*dataCompound"`)
			continue;
		$dv=`getAttr ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$kk=`getAttr -k ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$l=`getAttr -l ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		$minMax="";
		if (`attributeQuery -re -n $selAllInclShapes[$i] $ln`)
			{
			$range=`attributeQuery -r -n $selAllInclShapes[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		if ($at=="string")
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -dt \""+$at+"\" "+$minMax+" "+$selAllInclShapes[$i]+";"
					+"setAttr -l "+$l+" -type \"string\" "+$selAllInclShapes[$i]+"."+$sn+" \""+`encodeString $dv`+"\";";
		else
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$selAllInclShapes[$i]+";";
		}
	}

// read smooth level
$shapes=`ls -ni -type mesh`;
for ($y=0;$y<size($shapes);$y++)
	{
	if (!`attributeExists "displaySmoothMesh" $shapes[$y]`)
		continue;
	if (!`getAttr -l ($shapes[$y]+".displaySmoothMesh")`)
		continue;
	$smoothLevel=`getAttr ($shapes[$y]+".smoothLevel")`;
	$smoothLock=`getAttr -l ($shapes[$y]+".smoothLevel")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$smoothLock+" "+$shapes[$y]+".smoothLevel "+$smoothLevel+";";
	$dispResolution=`getAttr ($shapes[$y]+".dispResolution")`;
	$displaySmoothMesh=`getAttr ($shapes[$y]+".displaySmoothMesh")`;
	$displaySmoothMeshLock=`getAttr -l ($shapes[$y]+".displaySmoothMesh")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr "+$shapes[$y]+".dispResolution "+$dispResolution+";";
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$displaySmoothMeshLock+" "+$shapes[$y]+".displaySmoothMesh "+$displaySmoothMesh+";";
	}

// select non-instanced geometry
select geo;
select -hi;
string $sel[]=`ls -sl -type transform`;
string $selLong[]=`ls -l -sl -type transform`;
string $selShort[]=$sel;
string $children[];

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "ObjExporting" -bp -ii 1 -min 0 -max (size($sel)) $gMainProgressBar;
for ($i=0;$i<size($sel);$i++)
{
	if (`progressBar -q -ic $gMainProgressBar`)
	{
		break;progressBar -e -ep $gMainProgressBar;
	}
	progressBar -e -s 1 $gMainProgressBar;

	if (`gmatch $obj "*:*"`)
		continue;

	if (`gmatch $selShort[$i] "*|*"`)
		{
		tokenize $selShort[$i] "|" $tempString;
		$selShort[$i]=$tempString[size($tempString)-1];
		}
	select $sel[$i];
	$tempString=`listRelatives -s $sel[$i]`;
	$oldShapeName[$i]=$tempString[0];
	makeIdentity -a 1 -t 1 -r 1 -s 1 $sel[$i];
//		polySetToFaceNormal -setUserNormal;
	DeleteAllHistory;
	if (size(`ls -type nurbsCurve`))
		delete `ls -type nurbsCurve`;
	$tempString=`listRelatives -f -s $sel[$i]`;
	if (size($tempString)==0)
		$isGroup[$i]=1;
	$doubleSided[$i]=1;
	if (`objExists $tempString[0]`)
		if (`attributeExists doubleSided $tempString[0]`)
			$doubleSided[$i]=`getAttr ($tempString[0]+".doubleSided")`;
	$tempString=`listRelatives -p $sel[$i]`;
	if ($tempString[0]!="")
		$parent[$i]=$tempString[0];

	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		sysFile -del ($tempDir+$sel[$i]+".obj");
	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		print ("// Unable to delete "+$tempDir+$sel[$i]+".obj!\n");
	clear $children;
	$children=`listRelatives -f -type transform -c $sel[$i]`;
	if (size($children))
		$children=`parent -w $children`;
	select $sel[$i];
	$objFileName[$i]=`substituteAllString $selLong[$i] "|" "!"`;
	if (`gmatch $objFileName[$i] "!*"`)
		$objFileName[$i]=`substring $objFileName[$i] 2 999`;
	print ("// Exporting: "+$tempDir+$objFileName[$i]+".obj\n");
//		if ($eyeCandy)
//			FrameSelected;
	file -op "groups=0;ptgroups=0;materials=0;smoothing=1;normals=0;" -typ "OBJexport" -pr -es ($tempDir+$objFileName[$i]+".obj");
	if (size($children))
		parent $children $sel[$i];
}
progressBar -e -ep $gMainProgressBar;

//NewScene;
// select -all;delete;
string $filename = `file -q -exn`;
$mayaFileType = `file -q -type`;
file -f -new;
file -type $mayaFileType;
file -rn $filename;
setAttr -type float3 persp.translate $perspPos[0] $perspPos[1] $perspPos[2];
setAttr -type float3 persp.rotate $perspRot[0] $perspRot[1] $perspRot[2];
if ($eyeCandy)
	{
	setNamedPanelLayout "Single Perspective View";
	string $modelPanel=`paneLayout -q -p1 $gMainPane`;
	modelEditor -e -da "smoothShaded" $modelPanel;
	}

//Create groups
for ($i=0;$i<size($sel);$i++)
{
	if ($isGroup[$i])
		createNode -n $sel[$i] transform;
}
for ($i=0;$i<size($sel);$i++)
{
	if ($isGroup[$i])
		{
		if (`objExists $parent[$i]`)
			parent $sel[$i] $parent[$i];
		continue;
		}
print ("// importing: "+$tempDir+$objFileName[$i]+".obj\n");
file -i -type "OBJ" -rpr "DUP" -options "mo=0;lo=1" ($tempDir+$objFileName[$i]+".obj");
$existing[0]="polySurfaceShape1";
$tempString=`listRelatives -p $existing[0]`;
rename $tempString[0] $selShort[$i];

if (`objExists $parent[$i]`)
	parent ("|"+$selShort[$i]) $parent[$i];
if (!$doubleSided[$i])
	setAttr ($sel[$i]+".doubleSided") $doubleSided[$i];
select $sel[$i];
if ($eyeCandy)
	FrameSelected;

// restore original shape name
if (`objExists $sel[$i]`)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objExists $tempString[0]`)
		{
		setAttr ($tempString[0]+".visibleInReflections") 1;
		setAttr ($tempString[0]+".visibleInRefractions") 1;
		if ($tempString[0]!=$oldShapeName[$i])
			{
			print ("// Renaming "+$tempString[0]+" to "+$oldShapeName[$i]+"\n");
			rename $tempString[0] $oldShapeName[$i];
			}
		}
	}
}

// restore added attributes
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

// restore bits in sets
if (`gmatch $sceneName "*/library/set/*"`)
	file -import -type "mayaAscii" -ra false -rpr "export" -options "v=0"  -pr -loadReferenceDepth "all" ($tempDir+"setReferences.ma");

//remove files
$fileList=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size( $fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Import & Assign texturess
file -i $tmpFile;
eval `getAttr shaderAssign.notes`;
cleanConnectFileNodes "" "";
delete shaderAssign;

//set default UI
select -cl;
setNamedPanelLayout "Four View";
FrameAllInAllViews;

if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

print ("// Cleaning finished.\n");
}


global proc deleteUnusedRefNodes ()
{
string $allReferences[]=`file -q -r`;

string $realRefNodes[];
for ($y=0;$y<size($allReferences);$y++)
    $realRefNodes[size($realRefNodes)]=`file -q -rfn $allReferences`;
string $refNodes[]=`ls -type reference`;
for ($y=0;$y<size($refNodes);$y++)
    if (!`stringArrayCount $refNodes[$y] $realRefNodes`)
        {
        lockNode -l 0 $refNodes[$y];
        delete $refNodes[$y];
        }
}

global proc modelCleanMakeUniqueNames ()
{
SelectAllGeometry;
string $alls[]=`ls -sl`;
string $alls2[],$tempString[];
string $suffix;
int $clash;
for ($i=0;$i<size($alls);$i++)
    {
    $break=0;
    SelectAllGeometry;
    select -d $alls[$i];
    $alls2=`ls -sl -sn`;
    $suffix="";
    $clash=0;
    tokenize $alls[$i] "|" $tempString;
    $newName=$tempString[size($tempString)-1]+$suffix;
    for ($z=0;$z<size($alls2);$z++)
        {
        tokenize $alls2[$z] "|" $tempString;
        if ($newName==$tempString[size($tempString)-1])
            {
            for ($aa=0;$aa<999;$aa++)
            if (!`objExists ($newName+$aa)`)
                {
                print("// rename "+$alls[$i]+" "+$alls[$i]+"1\n");                
                rename $alls[$i] ($newName+$aa);
                $break=1;
                break;         
                }
            if ($break)
                break;
            }
        if ($break)
            break;
        }
    }
}
//-- ASModelCleaner Procedures Ends Here --//
//-- ASFace Procedures Starts Here --//
global proc asCreateFaceFitSkeleton ()
{
if (`objExists FaceGroup`)
	if (`confirmDialog -t "Confirm"
	-m "FaceFitSkeleton already exists, this will reset the FaceFitSkeleton"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
if (`objExists FaceGroup`)
	delete FaceGroup;
createNode -n FaceGroup transform;
setAttr -l 1 FaceGroup.inheritsTransform 0;
if (`objExists "|Group"`)
	parent FaceGroup "|Group";
if (`objExists FaceFitSkeleton`)
	delete FaceFitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FaceFitSkeleton;
parent FaceFitSkeleton FaceGroup;
setAttr FaceFitSkeletonShape.overrideEnabled 1;
setAttr FaceFitSkeletonShape.overrideColor 13;
scale -r -p 0 0 0 0.5 0.5 0.5 FaceFitSkeleton.cv[0:7];
duplicate -n FaceFitSkeletonHeight FaceFitSkeleton;
parent FaceFitSkeletonHeight FaceFitSkeleton;
parent -add -s FaceFitSkeletonHeightShape FaceFitSkeleton;
delete FaceFitSkeletonHeight;
move -r 0 1.5 0 FaceFitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FaceFitSkeleton.tx;setAttr -k 1 -l 0 FaceFitSkeleton.ty 8;setAttr -k 0 -l 1 FaceFitSkeleton.tz;
setAttr -k 0 -l 1 FaceFitSkeleton.rx;setAttr -k 0 -l 1 FaceFitSkeleton.ry 0;setAttr -k 0 -l 1 FaceFitSkeleton.rz;
setAttr -k 0 FaceFitSkeleton.sx;setAttr -k 0 FaceFitSkeleton.rz;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sx;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sz;
if (`objExists Head_M` && `objExists Neck_M`)
	{
	float $temp1[]=`xform -q -ws -t Head_M`;
	float $temp2[]=`xform -q -ws -t Neck_M`;
	setAttr FaceFitSkeleton.ty (($temp1[1]+$temp2[1])/2.0);
	}
if (`objExists Main`)
	if (`attributeExists height Main`)
		setAttr FaceFitSkeleton.sy (`getAttr Main.height`/5.0);

asFaceEnsureFitBase;
select FaceFitSkeleton;
}

global proc asAnimateFaceFit ()
{
int $autoKeyState=`autoKeyframe -q -state`;
int $eyeBrowsCartoony=0;
if (`optionMenu -q -sl asFaceEyeBrowsStyleOptionMenu`==2)
	$eyeBrowsCartoony=1;
if (!$autoKeyState)
			autoKeyframe -state 1;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`*0.666;
playbackOptions -min 0 -max 190 -ast 0 -aet 190;
currentTime 0;
int $startStopFrames[];
string $locs[];
$locs={"EyeBrowMain0","EyeBrowMain3","EyeBrowMain6"};
if (`objExists EyeBrowMain0`)
	{
	for ($i=0;$i<size($locs);$i++)
		if (!$eyeBrowsCartoony)
			geometryConstraint $geometry $locs[$i];
	$startStopFrames={0,10,20,30,40,50,60};
	for ($a=0;$a<size($startStopFrames);$a++)
		for ($i=0;$i<size($locs);$i++)
			{
			currentTime $startStopFrames[$a];
			setKeyframe ($locs[$i]+".t");
			}
	currentTime 5;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r 0 (0.0853434*$scale) (-0.0151578*$scale) $locs[$i];
	currentTime 15;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r 0 (-0.0853434*$scale) 0 $locs[$i];
	currentTime 25;refresh;
	move -r 0 (0.0853434*$scale) 0 EyeBrowMain0;
	currentTime 35;refresh;
	move -r (0.0487867*$scale) (-0.0853434*$scale) 0 EyeBrowMain0;
	currentTime 45;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r (0.050709*$scale) 0 0 $locs[$i];
	currentTime 55;refresh;
	move -r (-0.0451116*$scale) (0.0709945*$scale) (-0.0499044*$scale) EyeBrowMain6;
	}
if (`objExists lowerEyeLidOuter3`)
	{
	setKeyframe -t 90 -t 100 lowerEyeLidOuter3.t;
	currentTime 95;refresh;
	move -r (0.00834774*$scale) (0.0515147*$scale) (-0.0123916*$scale) lowerEyeLidOuter3;
	}
if (`objExists upperLip0`)
	{
	setKeyframe -t 0 -t 10 -t 20 -t 30 upperLip0.twist;
	setKeyframe -t 5 -v 100 upperLip0.twist;
	setKeyframe -t 25 -v -80 upperLip0.twist;
	setKeyframe -t 10 -t 20 -t 30 -t 40 lowerLip0.twist;
	setKeyframe -t 20 -t 30 lowerLip0.twist;
	setKeyframe -t 15 -v -100 lowerLip0.twist;
	setKeyframe -t 35 -v 80 lowerLip0.twist;
	setKeyframe -t 20 -t 30 upperLip0.t;
	currentTime 25;refresh;
	move -r 0 (0.034805*$scale) (0.0559906*$scale) upperLip0;
	setKeyframe -t 30 -t 40 lowerLip0.t;
	currentTime 35;refresh;
	move -r 0 (-0.0484243*$scale) (0.0453978*$scale) lowerLip0;
	currentTime 40;
	setKeyframe -t 50 -t 60 -t 70 Lip6.t upperLip0.t lowerLip0.t upperLip3.t lowerLip3.t;
	currentTime 55;refresh;
	move -r (-0.108898*$scale) (0.139484*$scale) (-0.0650974*$scale) Lip6;
	move -r 0 (0.0378315*$scale) (-0.0196724*$scale) upperLip0;
	move -r 0 (-0.0474174*$scale) (-0.0391381*$scale) lowerLip0;
	move -r (-0.143168*$scale) (-0.00257716*$scale) (-0.0584678*$scale) lowerLip3;
	move -r (-0.0354011*$scale) (0.0393*$scale) (-0.0138085*$scale) upperLip3;
	currentTime 65;refresh;
	move -r (0.0506868*$scale) 0 (0.0461135*$scale) Lip6;
	move -r 0 (0.0181591*$scale) 0 upperLip0;
	move -r 0 (-0.0293536*$scale) 0 lowerLip0;
	move -r (0.0290451*$scale) (0.0308008*$scale) (0.0103786*$scale) upperLip3;
	move -r (0.0230078*$scale) (-0.0187822*$scale) (0.00995779*$scale) lowerLip3;
	
	setKeyframe -t 70 -t 80 lowerLipCylinder.cv[0:1][5];
	currentTime 75;refresh;
	move -r 0 (0.025*$scale) 0 lowerLipCylinder.cv[0:1][5];
	setKeyframe -t 80 -t 90 upperLip0.t upperLip0.twist lowerLip0.t lowerLip0.twist;
	currentTime 85;refresh;
	setAttr upperLip0.twist 80;
	move -r 0 (-0.01*$scale) 0 upperLip0;
	setAttr lowerLip0.twist -80;
	move -r 0 (0.01*$scale) 0 lowerLip0;
	}
if (`objExists noseCorner`)
	{
	setKeyframe -t 120 -t 130 -t 140 -t 150 noseCorner;
	currentTime 125;refresh;
	move -r (0.0109107*$scale) (0.0584232*$scale) (-0.00117445*$scale) noseCorner;
	currentTime 135;refresh;
	move -r (-0.028*$scale) 0 0 noseCorner;
	currentTime 145;refresh;
	move -r (0.028*$scale) 0 0 noseCorner;
	}
if (`objExists Lip6`)
	{
	setKeyframe -t 150 -t 160 -t 170 -t 180 -t 190 Lip6;
	currentTime 155;refresh;
	move -r (-0.0449702*$scale) 0 (-0.0544978*$scale) Lip6;
	currentTime 165;refresh;
	move -r (0.0621199*$scale) 0 (0.0613577*$scale) Lip6;
	currentTime 175;refresh;
	move -r (-0.0721402*$scale) (0.121836*$scale) (-0.0335431*$scale) Lip6;
	currentTime 185;refresh;
	move -r (-0.0180624*$scale) (-0.0745626*$scale) (-0.0415436*$scale) Lip6;
	}

if (`objExists EyeBrowMain0`)
	for ($i=0;$i<size($locs);$i++)
		if (!$eyeBrowsCartoony)
			delete ($locs[$i]+"_geometryConstraint1");

if (!$autoKeyState)
			autoKeyframe -state 0;
currentTime 0;
}

global proc asFaceFitProject (string $section,string $part,int $upAndLo)
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`;
spaceLocator -n tempLoc;
string $locs[]=`listRelatives -c ("FaceFit"+$section+$part+"Loc")`;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;

	if (`objExists ($upperLower+$section+$part+"4")`)
		$locs[size($locs)]=($upperLower+$section+$part+"4");
	if (`objExists ($upperLower+$section+$part+"1")`)
		$locs[size($locs)]=($upperLower+$section+$part+"1");
	}

for ($a=0;$a<size($locs);$a++)
	{
	parent tempLoc $locs[$a];
	setAttr -type float3 tempLoc.t 0 0 0;
	geometryConstraint $geometry tempLoc;
	for ($i=0;$i<10;$i++)
	  {
		setAttr tempLoc.tx 0;
		setAttr tempLoc.ty 0;
		}
	float $pos[]=`xform -q -ws -t tempLoc`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $locs[$a];
	}
delete tempLoc;
select $sel;
}

global proc asCreateFaceFit (string $section,string $part,int $upAndLo,int $mainAndOuter,float $radius,int $isSphere)
{
if (`objExists ("FaceFit"+$section+$part)`)
	error ("FaceFit"+$section+$part+" Already Exists");

string $sel[]=`ls -sl -fl`;
int $edgeSelection,$vertexSelection;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*[.]e*"`)
		$edgeSelection=1;
	if (`gmatch $sel[$i] "*[.]vtx*"`)
		$vertexSelection=1;
	}

int $nr;
float $scale=`asFaceGetScale`;
float $dist,$dist2;
float $pos[],$posA[],$posB[];
string $upperLower;
string $tempString[],$tempString2[];
currentTime 0;

if ($section=="Jaw" && $part=="Main" && `objExists FKJaw_M`)
	if (!`asFaceRemoveBodyJaw`)
		return;

if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;
asFitModeEnsureShaders;

spaceLocator -n templateLoc;
setAttr -type float3 templateLocShape.localScale (0.035*$scale) (0.035*$scale) (0.035*$scale);
setAttr templateLocShape.overrideEnabled 1;
setAttr templateLocShape.overrideColor 17;

createNode -n ("FaceFit"+$section+$part) -p FaceFitSkeleton transform;
createNode -n ("FaceFit"+$section+$part+"Geo") -p ("FaceFit"+$section+$part) transform;
if (!$isSphere)
	setAttr ("FaceFit"+$section+$part+"Geo.inheritsTransform") 0;
createNode -n ("FaceFit"+$section+$part+"Curve") -p ("FaceFit"+$section+$part) transform;
setAttr ("FaceFit"+$section+$part+"Curve.inheritsTransform") 0;
setAttr ("FaceFit"+$section+$part+"Curve.v") 0;
createNode -n ("FaceFit"+$section+$part+"Loc") -p ("FaceFit"+$section+$part) transform;
if ($isSphere)
	{
	duplicate -n $section templateLoc;
	parent ($section) ("FaceFit"+$section+$part+"Loc");
	sphere -n ($section+"Sphere") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r (0.02*$scale) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0;
	parent ($section+"Sphere") ("FaceFit"+$section+$part+"Geo");
	connectAttr ($section+".t") ($section+"Sphere.t");
	connectAttr ($section+".r") ($section+"Sphere.r");
	connectAttr ($section+".s") ($section+"Sphere.s");
	setAttr ($section+"SphereShape.overrideEnabled") 1;
	setAttr ($section+"SphereShape.overrideDisplayType") 2;
	addAttr -k 1 -min 0 -dv 1 -ln "falloffRadius" -at double $section;
	addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 $section;
	
	}

if ($section=="EyeLid" && $part=="Main")
	addAttr -k 1 -ln numExtra -at long -dv 1 FaceFitEyeLidMain;

if ($mainAndOuter==0) $part="";
else $parts={"Main","Outer"};
//if ($mainAndOuter==0 && $a>0)
//	continue;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;
	if ($isSphere)
		continue;

	$tempString=`cylinder -n ($upperLower+$section+"Cylinder"+$part) -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r $radius -hr 2 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 1`;
	rename $tempString[1] ($upperLower+$section+"MakeNurbCylinder"+$part);
	parent ($upperLower+$section+"Cylinder"+$part) FaceFitSkeleton;
	displaySmoothness -divisionsU 3 -divisionsV 3 -pointsWire 16 -pointsShaded 4 -polygonObject 3 ($upperLower+$section+"Cylinder"+$part); 
	setAttr ($upperLower+$section+"Cylinder"+$part+"Shape.overrideEnabled") 1;
	setAttr ($upperLower+$section+"Cylinder"+$part+"Shape.overrideDisplayType") 2;
	setAttr -type float3 ($upperLower+$section+"Cylinder"+$part+".r") 0 0 90;
	setAttr -type float3 ($upperLower+$section+"Cylinder"+$part+".s") 0.025 0.2 0.025;
	parent ($upperLower+$section+"Cylinder"+$part) ("FaceFit"+$section+$part+"Geo");
	if ($section=="Lip")
		{
		select ($upperLower+$section+"Cylinder"+$part);
		$tempString=`nonLinear -type twist -lowBound -1 -highBound 1 -startAngle 0 -endAngle 0`;
		rename $tempString[0] ($upperLower+$section+"Twist");
		rename $tempString[1] ($upperLower+$section+"TwistHandle");
		parent ($upperLower+$section+"TwistHandle") FaceFitLipGeo;
		setAttr ($upperLower+$section+"TwistHandle.v") 0;
		}

	$curveCmd="curve -d 3 ";
	for ($i=0;$i<7;$i++)
		{
		select -r ($upperLower+$section+"Cylinder"+$part+".cv["+$i+"][0:7]");
		$tempString=`newCluster " -envelope 1"`;
		rename $tempString[0] ($upperLower+$section+"Cluster"+$part+$i);
		rename $tempString[1] ($upperLower+$section+"ClusterHandle"+$part+$i);
		$tempString2=`listRelatives -s ($upperLower+$section+"ClusterHandle"+$part+$i)`;
		rename $tempString2[0] ($upperLower+$section+"ClusterHandleShape"+$part+$i);
		setAttr -l 1 ($upperLower+$section+"ClusterHandle"+$part+$i+".v") 0;
		$tempString=`listConnections ($upperLower+$section+"Cluster"+$part+$i+".message")`;
		rename $tempString[0] ($upperLower+$section+"Cluster"+$part+$i+"Set");

		$pos=`xform -q -ws -piv ($upperLower+$section+"ClusterHandle"+$part+$i)`;
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		duplicate -n ($upperLower+$section+$part+$i) templateLoc;
		if ($i==1 || $i==3)
			setAttr ($upperLower+$section+$part+$i+"Shape.overrideColor") 14;
		parent ($upperLower+$section+$part+$i) ("FaceFit"+$section+$part+"Loc");
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$section+$part+$i);
		parent ($upperLower+$section+"ClusterHandle"+$part+$i) ($upperLower+$section+$part+$i);
		}
	//aim
	if ($section!="Nose" && $section!="Tongue")
		{
		aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 0 1 ($upperLower+$section+"ClusterHandle"+$part+"2") ($upperLower+$section+"ClusterHandle"+$part+"0");
		aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 0 1 ($upperLower+$section+"ClusterHandle"+$part+"2") ($upperLower+$section+"ClusterHandle"+$part+"1");
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 0 1 ($upperLower+$section+"ClusterHandle"+$part+"4") ($upperLower+$section+"ClusterHandle"+$part+"5");
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 0 1 ($upperLower+$section+"ClusterHandle"+$part+"4") ($upperLower+$section+"ClusterHandle"+$part+"6");
		}
	parent ($upperLower+$section+$part+"1") ($upperLower+$section+$part+"0");
	parent ($upperLower+$section+$part+"2") ($upperLower+$section+$part+"0");
	parent ($upperLower+$section+$part+"4") ($upperLower+$section+$part+"6");
	parent ($upperLower+$section+$part+"5") ($upperLower+$section+$part+"6");
	addAttr -k 1 -dv 0 -ln fineCtrl -at bool ($upperLower+$section+$part+"0");
	addAttr -k 1 -dv 0 -ln fineCtrl -at bool ($upperLower+$section+$part+"6");
	connectAttr ($upperLower+$section+$part+"0.fineCtrl") ($upperLower+$section+$part+"2.v");
	connectAttr ($upperLower+$section+$part+"6.fineCtrl") ($upperLower+$section+$part+"4.v");
	setAttr ($upperLower+$section+$part+"1.v") 0;
	setAttr ($upperLower+$section+$part+"5.v") 0;
	$pos=`xform -q -ws -t ($upperLower+$section+$part+"0")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$section+$part+"1");
	$pos=`xform -q -ws -t ($upperLower+$section+$part+"6")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$section+$part+"5");
	$tempString[0]=`eval ($curveCmd)`;
	rename $tempString[0] ($upperLower+$section+$part+"Curve");
	parent ($upperLower+$section+$part+"Curve") ("FaceFit"+$section+$part+"Curve");
	for ($i=0;$i<7;$i++)
		connectAttr ($upperLower+$section+$part+$i+".worldPosition") ($upperLower+$section+$part+"Curve.controlPoints["+$i+"]");

	//Colors
	if ($part=="Main")
		sets -e -forceElement "asRedSG" ($upperLower+$section+"Cylinder"+$part);
	if ($part=="Outer")
		sets -e -forceElement "asGreenSG" ($upperLower+$section+"Cylinder"+$part);
	if ($section=="Lip" && $upperLower=="upper")
		sets -e -forceElement "asRedSG" upperLipCylinder;
	if ($section=="Lip" && $upperLower=="lower")
		sets -e -forceElement "asBlueSG" lowerLipCylinder;
	if ($section=="Lip")
		{
		sets -e -forceElement asGreen2SG ($upperLower+"LipCylinder.sf[0:3][0]");
		sets -e -forceElement asGreen2SG ($upperLower+"LipCylinder.sf[0:3][2]");
		sets -e -forceElement asGreen2SG ($upperLower+"LipCylinder.sf[0:3][4]");
		sets -e -forceElement asGreen2SG ($upperLower+"LipCylinder.sf[0:3][6]");
		}
	if ($section=="Nose")
		sets -e -forceElement "asGreenSG" NoseCylinder;
	if ($section=="Tongue")
		sets -e -forceElement "asRedSG" TongueCylinder;
	}
if ($section=="noseCorner" || $section=="cheek")
	sets -e -forceElement "asBlue2SG" ($section+"Sphere");

//EyeBrow Place
if ($section=="EyeBrow" && $part=="Main")
	{
	setAttr -type float3 EyeBrowMain0.t -0.102 1 0.55;
	setAttr -type float3 EyeBrowMain3.t -0.224 1 0.55;
	setAttr -type float3 EyeBrowMain6.t -0.347 1 0.55;
	select EyeBrowMain6 EyeBrowMain3 EyeBrowMain0;
	}
if ($section=="EyeBrow" && $part=="Outer")
	{
	setAttr -type float3 EyeBrowOuter0.t 0 1.2 0.55;
	setAttr -type float3 EyeBrowOuter3.t -0.224 1.2 0.55;
	setAttr -type float3 EyeBrowOuter6.t -0.347 1.2 0.55;
	setAttr -l 1 EyeBrowOuter0.tx 0;
	select EyeBrowOuter6 EyeBrowOuter3 EyeBrowOuter0;
	}

//EyeLid Place
if ($section=="EyeLid")
	{
	for ($z=0;$z<7;$z=$z+6)//0 && 6
		{
		duplicate -n ("EyeLid"+$part+$z) templateLoc;parent ("upperEyeLid"+$part+$z) ("lowerEyeLid"+$part+$z) ("EyeLid"+$part+$z);
		setAttr ("upperEyeLid"+$part+$z+"Shape.v") 0;setAttr ("lowerEyeLid"+$part+$z+"Shape.v") 0;
		addAttr -k 1 -dv 0 -ln fineCtrl -at bool ("EyeLid"+$part+$z);
		connectAttr ("EyeLid"+$part+$z+".fineCtrl") ("upperEyeLid"+$part+$z+".fineCtrl");connectAttr ("EyeLid"+$part+$z+".fineCtrl") ("lowerEyeLid"+$part+$z+".fineCtrl");
		setAttr -type float3 ("upperEyeLid"+$part+$z+".t") 0 0 0;
		setAttr -type float3 ("lowerEyeLid"+$part+$z+".t") 0 0 0;
		}
	parent ("EyeLid"+$part+"0") ("EyeLid"+$part+"6") ("FaceFitEyeLid"+$part+"Loc");
	select ("upperEyeLid"+$part+"3") ("lowerEyeLid"+$part+"3") ("EyeLid"+$part+"6") ("EyeLid"+$part+"0");
	}
if ($section=="EyeLid" && $part=="Main")
	{
	setAttr -type float3 EyeLidMain0.t -0.131 0.75 0.5;
	setAttr -type float3 EyeLidMain6.t -0.391 0.748 0.5;
	setAttr -type float3 upperEyeLidMain3.t -0.261 0.848 0.5;
	setAttr -type float3 lowerEyeLidMain3.t -0.261 0.653 0.5;
	setAttr -type float3 upperEyeLidMain2.t (-0.033*$scale) (0.041*$scale) 0;
	setAttr -type float3 lowerEyeLidMain2.t (-0.033*$scale) (-0.041*$scale) 0;
	setAttr -type float3 upperEyeLidMain4.t (0.033*$scale) (0.041*$scale) 0;
	setAttr -type float3 lowerEyeLidMain4.t (0.033*$scale) (-0.041*$scale) 0;
	}
if ($section=="EyeLid" && $part=="Outer")
	{
	setAttr -type float3 EyeLidOuter0.t -0.002 0.75 0.5;
	setAttr -type float3 EyeLidOuter6.t -0.588 0.748 0.5;
	setAttr -type float3 upperEyeLidOuter3.t -0.261 0.945 0.5;
	setAttr -type float3 lowerEyeLidOuter3.t -0.261 0.556 0.5;
	setAttr -type float3 upperEyeLidOuter2.t (-0.065*$scale) (0.077*$scale) 0;
	setAttr -type float3 lowerEyeLidOuter2.t (-0.065*$scale) (-0.077*$scale) 0;
	setAttr -type float3 upperEyeLidOuter4.t (0.065*$scale) (0.077*$scale) 0;
	setAttr -type float3 lowerEyeLidOuter4.t (0.065*$scale) (-0.077*$scale) 0;
	}

//Jaw Place
if ($section=="Jaw" && $part=="Main")
	{
	setAttr -type float3 JawMain0.t 0 0.07 0.545;
	setAttr -type float3 JawMain6.t -0.51 0.603 0;
	setAttr -type float3 JawMain6.r 90 -40 -90;
	setAttr -type float3 JawMain3.t -0.53 0.255 0.301;
	setAttr -type float3 JawMain2.t (-0.067*$scale) 0 0;
	setAttr -type float3 JawMain4.t (0.067*$scale) 0 0;
	setAttr -l 1 JawMain0.tx 0;
	select JawMain0 JawMain3 JawMain6;
	}
if ($section=="Jaw" && $part=="Outer")
	{
	setAttr -type float3 JawOuter0.t 0 -0.165 0.071;
	setAttr -type float3 JawOuter6.t -0.51 0.603 0;
	setAttr -type float3 JawOuter6.r 90 -40 -90;
	setAttr -type float3 JawOuter3.t -0.431 0.179 -0.09;
	setAttr -type float3 JawOuter2.t (-0.067*$scale) 0 0;
	setAttr -type float3 JawOuter4.t (0.122*$scale) (-0.12*$scale) (-0.014*$scale);
	setAttr -l 1 JawOuter0.tx 0;
	select JawOuter0 JawOuter3 JawOuter6;
	}

//Nose Place
if ($section=="Nose")
	{
	setAttr -type float3 Nose0.t 0 0.685 0.547;
	setAttr -type float3 Nose0.r 0 6.36 90;
	setAttr -type float3 Nose0.s (1.5/$scale) (0.75/$scale) (0.15/$scale);
	setAttr -type float3 Nose2.t (-0.035*$scale) 0 0;
	setAttr -type float3 Nose3.t 0 0.522 0.721;
	setAttr -type float3 Nose3.r 0 0 90;
	setAttr -type float3 Nose3.s (1.5/$scale) (1.5/$scale) (0.15/$scale);
	setAttr -type float3 Nose4.t (0.035*$scale) 0 0;
	setAttr -type float3 Nose6.t 0 0.454 0.612;
	setAttr -type float3 Nose6.r 0 -75.871 90;
	setAttr -type float3 Nose6.s (1.5/$scale) (1.5/$scale) (0.15/$scale);
	select Nose0 Nose3 Nose6;
	}

//NoseCorner Place
if ($section=="noseCorner")
	{
	setAttr -type float3 noseCorner.t -0.117 0.502 0.5;
	select noseCorner;
	}

//Cheek Place
if ($section=="cheek")
	{
	setAttr -type float3 cheek.t -0.332 0.433 0.5;
	select cheek;
	}

//Tongue Place
if ($section=="Tongue")
	{
	setAttr -type float3 Tongue0.t 0 0.268 0.161;
	setAttr -type float3 Tongue0.r -90 56 -90;
	setAttr -type float3 Tongue0.s (1.5/$scale) (1.5/$scale) (6/$scale);
	setAttr -type float3 Tongue2.t (-0.044*$scale) 0 0;
	setAttr -type float3 Tongue3.t 0 0.308 0.306;
	setAttr -type float3 Tongue3.r 0 90 0;
	setAttr -type float3 Tongue3.s (1.5/$scale) (1.5/$scale) (6/$scale);
	setAttr -type float3 Tongue4.t (0.01*$scale) 0 0;
	setAttr -type float3 Tongue4.s 1 1 4;
	setAttr -type float3 Tongue6.t 0 0.315 0.478;
	setAttr -type float3 Tongue6.r 0 90 0;
	setAttr -type float3 TongueClusterHandle6.s 0 0 0;
	setAttr -l 1 Tongue0.tx 0;
	setAttr -l 1 Tongue2.ty 0;
	setAttr -l 1 Tongue3.tx 0;
	setAttr -l 1 Tongue4.ty 0;
	setAttr -l 1 Tongue6.tx 0;
	select Tongue0 Tongue3 Tongue6;
	}

//Lip Place
if ($section=="Lip")
	{
	duplicate -n Lip6 templateLoc;parent upperLip6 lowerLip6 Lip6;
	setAttr upperLip6Shape.v 0;setAttr lowerLip6Shape.v 0;
	addAttr -k 1 -dv 0 -ln fineCtrl -at bool Lip6;
	connectAttr Lip6.fineCtrl upperLip6.fineCtrl;connectAttr Lip6.fineCtrl lowerLip6.fineCtrl;
	setAttr -type float3 upperLip6.t 0 0 0;
	setAttr -type float3 lowerLip6.t 0 0 0;
	parent Lip6 FaceFitLipLoc;
	setAttr -type float3 upperLip0.t 0 0.375 0.6;
	setAttr -type float3 upperLip1.t -0.001 0 0;
	setAttr -type float3 upperLip3.t -0.09 0.33 0.6;
	setAttr -type float3 upperLip5.t 0.001 0 0;
	setAttr -type float3 lowerLip0.t 0 0.274 0.6;
	setAttr -type float3 lowerLip1.t -0.001 0 0;
	setAttr -type float3 lowerLip3.t -0.09 0.29 0.6;
	setAttr -type float3 lowerLip5.t 0.001 0 0;
	setAttr -type float3 Lip6.t -0.183 0.307 0.6;
	setAttr -type float3 Lip6.s (0.45/$scale) (0.45/$scale) (0.45/$scale);
	setAttr upperLip2.t (-0.02*$scale) 0 0;
	setAttr lowerLip2.t (-0.02*$scale) 0 0;
	setAttr upperLip4.t (0.066*$scale) 0 0;
	setAttr lowerLip4.t (0.066*$scale) 0 0;
	setAttr -l 1 upperLip0.tx 0;
	setAttr -l 1 lowerLip0.tx 0;
	addAttr -k 1 -ln twist -at double upperLip0;
	addAttr -k 1 -ln twist -at double lowerLip0;
	connectAttr upperLip0.twist upperLipTwist.startAngle;
	connectAttr lowerLip0.twist lowerLipTwist.startAngle;
	select upperLip0 upperLip3 Lip6 lowerLip3 lowerLip0;

	//Push inside lip mesh
	refresh;
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
		for ($i=0;$i<7;$i++)
			{
			$posA=`xform -q -ws -t ($upperLower+"Lip"+$i)`;
			$posB=`xform -q -ws -t ($upperLower+"LipCylinder.cv["+$i+"][3]")`;
			$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
			move -r 0 0 ($dist*-1) ($upperLower+"LipClusterHandle"+$i);
			}
		}
	}

delete templateLoc;
//select EyeBrowMain0 EyeBrowMain2 EyeBrowMain4 EyeBrowOuter0 EyeBrowOuter2 EyeBrowOuter4 upperEyeLidMain2 lowerEyeLidMain2 upperEyeLidOuter2 lowerEyeLidOuter2 EyeLidMain0 EyeLidMain4 EyeLidOuter4 JawMain0 JawMain2 JawMain4 JawOuter0 JawOuter2 JawOuter4 upperLip0 upperLip2 lowerLip0 lowerLip2 Lip4 Nose0 Nose4 noseCorner Cheek0 Tongue0 Tongue2 Tongue4 EyeLidOuter0 Nose2;
if (`checkBox -q -ex ("asFace"+$section+$part)`)
	checkBox -e -ed 1 -v 1 ("asFace"+$section+$part);


//EdgeSelection based placement
if (!$edgeSelection && !$vertexSelection)
	return;

addAttr -ln selection -dt "string" ("FaceFit"+$section+$part);
$tempString[0]="";
for ($i=0;$i<size($sel);$i++)
	$tempString[0]=$tempString[0]+$sel[$i]+" ";
setAttr -type "string" ("FaceFit"+$section+$part+".selection") $tempString[0];

int $around;
float $minPos[3]={999,999,999};
float $maxPos[3]={-999,-999,-999};
string $minXVtx,$maxXVtx,$minYVtx,$maxYVtx,$minZVtx,$maxZVtx;

if ($section=="noseCorner" || $section=="cheek")
	{
	for ($i=0;$i<size($sel);$i++)
		{
		if (!$vertexSelection && `gmatch $sel[$i] "*[.]e*"`)
			{
			select $sel[$i];ConvertSelectionToVertices;$tempString=`ls -sl`;
			$pos=`xform -q -ws -t $tempString[0]`;
			}
		if ($vertexSelection && `gmatch $sel[$i] "*[.]vtx*"`)
			$pos=`xform -q -ws -t $sel[$i]`;
		}
	xform -ws -t $pos[0] $pos[1] $pos[2] ($section+$part);
	return;
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*[.]e*"`)
		continue;
	select $sel[$i];
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$pos=`xform -q -ws -t $tempString[$y]`;
		if ($pos[0]<$minPos[0]) {$minPos[0]=$pos[0];$minXVtx=$tempString[$y];}
		if ($pos[1]<$minPos[1]) {$minPos[1]=$pos[1];$minYVtx=$tempString[$y];}
		if ($pos[2]<$minPos[2]) {$minPos[2]=$pos[2];$minZVtx=$tempString[$y];}
		if ($pos[0]>$maxPos[0]) {$maxPos[0]=$pos[0];$maxXVtx=$tempString[$y];}
		if ($pos[1]>$maxPos[1]) {$maxPos[1]=$pos[1];$maxYVtx=$tempString[$y];}
		if ($pos[2]>$maxPos[2]) {$maxPos[2]=$pos[2];$maxZVtx=$tempString[$y];}
		}
	}
string $startVxt=$maxXVtx;
string $endVxt=$minXVtx;
if ($section=="Nose") {$startVxt=$maxYVtx;$endVxt=$minYVtx;}
if ($section=="Tongue") {$startVxt=$minZVtx;$endVxt=$maxZVtx;}
if ($section=="EyeBrow" || $section=="Jaw" || $section=="Nose"  || $section=="Tongue")
	$endVxt=""; // mean we will find $endVxt while traversing the edge-selection


select $startVxt;
ConvertSelectionToEdges;
$tempString=`ls -sl -fl`;
for ($y=0;$y<size($tempString);$y++)
	{
	if (!`stringArrayCount $tempString[$y] $sel`)
		select -d $tempString[$y];
	}
$tempString=`ls -sl -fl`;
string $edge1=$tempString[0];
string $edge2=$tempString[1];
string $prevVtxs[],$vtxs1[],$vtxs2[];

//get $edges1[]
$curveCmd="curve -n faceLoopCurve1 -d 1 ";
$pos=`xform -q -ws -t $startVxt`;
if ($section=="Lip" && $pos[0]>0.001) //only rightSide for Lip
	;
else
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
select $startVxt;
$prevVtxs[0]=$startVxt;
$vtxs1[size($vtxs1)]=$startVxt;
string $coveredEdges[];

for ($i=0;$i<199;$i++)
	{
	ConvertSelectionToEdges;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge2)
			select -d $tempString[$y];
		}
	$tempString=`ls -sl -fl`;
	$coveredEdges[size($coveredEdges)]=$tempString[0];
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	if ($endVxt=="")
		{
		if  (size($coveredEdges)==size($sel))
			$around=1;
		}
	else
		{
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVxt $tempString`)
				$around=1;
		}
	select -d $prevVtxs;
	$prevVtxs=$tempString;
	$tempString2=`ls -sl -fl`;
	if ($tempString2[0]=="")
		break;
	$vtxs1[size($vtxs1)]=$tempString2[0];
	$pos=`xform -q -ws -t $tempString2[0]`;
	if ($section=="Lip" && $pos[0]>0.001) //only rightSide for Lip
		;
	else
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	select $tempString;
	if ($around)
		{
		if ($endVxt=="")
			$endVxt=$tempString2[0];
		break;
		}
	}

ConvertSelectionToContainedEdges;
string $edges1[]=`ls -sl -fl`;
eval $curveCmd;

if ($upAndLo)
	{
	//get $edges2[]
	$curveCmd="curve -n faceLoopCurve2 -d 1 ";
	$around=0;
	select $maxXVtx;
	$pos=`xform -q -ws -t $maxXVtx`;
	if ($section!="Lip")
		{
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$prevVtxs[0]=$maxXVtx;
		$vtxs2[size($vtxs2)]=$maxXVtx;
		}
	for ($i=0;$i<199;$i++)
		{
		ConvertSelectionToEdges;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge1)
				select -d $tempString[$y];
			}
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $minXVtx $tempString`)
				$around=1;
		select -d $prevVtxs;
		$prevVtxs=$tempString;
		$tempString2=`ls -sl -fl`;
		if (!`size($tempString2)`)
			error "Not a complete edgeloop";
		$vtxs2[size($vtxs2)]=$tempString2[0];
		$pos=`xform -q -ws -t $tempString2[0]`;
		if ($section=="Lip" && $pos[0]>0.001) //only rightSide for Lip
			;
		else
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		select $tempString;
		if ($around)
			break;
		}

	ConvertSelectionToContainedEdges;
	string $edges2[]=`ls -sl -fl`;
	eval $curveCmd;

	int $OneIsUpper;
	select $edges1;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $maxYVtx $tempString`)
			$OneIsUpper=1;
	string $upperVtxs[],$lowerVtxs[];
	if ($OneIsUpper)
		{
		$upperVtxs=$vtxs1;
		$lowerVtxs=$vtxs2;
		rename faceLoopCurve1 upperFaceLoopCurve;
		rename faceLoopCurve2 lowerFaceLoopCurve;
		}
	else
		{
		$upperVtxs=$vtxs2;
		$lowerVtxs=$vtxs1;
		rename faceLoopCurve1 lowerFaceLoopCurve;
		rename faceLoopCurve2 upperFaceLoopCurve;
		}
	addAttr -ln upperSelection -dt "string" ("FaceFit"+$section+$part);
	addAttr -ln lowerSelection -dt "string" ("FaceFit"+$section+$part);
	$tempString[0]="";
	for ($i=0;$i<size($upperVtxs);$i++)
		$tempString[0]=$tempString[0]+$upperVtxs[$i]+" ";
	setAttr -type "string" ("FaceFit"+$section+$part+".upperSelection") $tempString[0];
	$tempString[0]="";
	for ($i=0;$i<size($lowerVtxs);$i++)
		$tempString[0]=$tempString[0]+$lowerVtxs[$i]+" ";
	setAttr -type "string" ("FaceFit"+$section+$part+".lowerSelection") $tempString[0];
	}
if (!$upAndLo)
	rename faceLoopCurve1 FaceLoopCurve;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if (!$upAndLo)
		{
		$upperLower="";
		if ($upperLowerFactor==-1) 
			continue;
		}

	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.004 ($upperLower+"FaceLoopCurve");	
	for ($i=0;$i<9;$i++)
		{
		$nr=$i;
		if ($i==4 || $i==5) continue;//Do 4&5 last
		if ($i==7) $nr=4;
		if ($i==8) $nr=5;
		$pos=`xform -q -ws -t ($upperLower+"FaceLoopCurve.cv["+$nr+"]")`;
		if (($nr==0 && $section!="Lip") || $nr==6)
			xform -ws -t $pos[0] $pos[1] $pos[2] ($section+$part+$nr);
		else
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$section+$part+$nr);
		}
	}
if ($upAndLo)
	delete upperFaceLoopCurve lowerFaceLoopCurve;
else
	delete FaceLoopCurve;

//Lip thickness
if ($section=="Lip")
	{
	$posA=`xform -q -ws -t upperLip0`;
	$posB=`xform -q -ws -t lowerLip0`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	float $posA[]=`xform -q -ws -t upperLipCylinder.cv[0][7]`;
	float $posB[]=`xform -q -ws -t upperLipCylinder.cv[0][3]`;
	float $dist2 =`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	float $lipScale=(`getAttr upperLip0.sx`*($dist/$dist2))/1.0;
	setAttr -type float3 upperLip0.s $lipScale $lipScale $lipScale;
	setAttr -type float3 lowerLip0.s $lipScale $lipScale $lipScale;

	$posA=`xform -q -ws -t upperLip3`;
	$posB=`xform -q -ws -t lowerLip3`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	$posA=`xform -q -ws -t upperLipCylinder.cv[3][7]`;
	$posB=`xform -q -ws -t upperLipCylinder.cv[3][3]`;
	$dist2 =`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	$lipScale=(`getAttr upperLip3.sx`*($dist/$dist2))/1.0;
	setAttr -type float3 upperLip3.s $lipScale $lipScale $lipScale;
	setAttr -type float3 lowerLip3.s $lipScale $lipScale $lipScale;

	setAttr -type float3 Lip6.s ($lipScale/2.0) ($lipScale/2.0) ($lipScale/2.0);
	}
select ("FaceFit"+$section+$part);
}

global proc int asFaceRemoveBodyJaw ()
{
int $return=0;
string $dialog=`confirmDialog -t "Confirm"
	-m "This will replace the Jaw from the Body-setup"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog=="OK")
	$return=1;

string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
	if (`objExists Jaw_M`) asRemoveInfluence Jaw_M $skinClusters[$i];

if (`objExists FKOffsetJaw_M`) delete FKOffsetJaw_M;
if (`objExists Jaw_M`) delete Jaw_M;
if (`objExists Jaw`) delete Jaw;

asRemoveUnusedfromBuildPose bodySetup;
return $return;
}

global proc int asCanBuild (string $section)
{
int $canBuild=0;
if ($section=="EyeBall")
	if (`objExists FitEyeBall`)
		$canBuild=1;
if ($section=="EyeLid")
	if (`objExists EyeLidMain0` && `objExists FitEyeBall`)
		$canBuild=1;
if ($section=="EyeBrow")
	if (`objExists EyeBrowMain0` && `objExists EyeLidMain0` && `objExists FitEyeBall`)
		$canBuild=1;
if ($section=="Jaw")
	if (`objExists JawOuter0` && `objExists EyeLidMain0` && `objExists FitEyeBall`
	 && `objExists FitEyeBall` && `objExists upperLip0` && `objExists  Nose0`
	 && `objExists noseCorner` && `objExists cheek`)
		$canBuild=1;
if ($section=="Cheek")
	if (`objExists upperLip0` && `objExists noseCorner` && `objExists cheek`)
		$canBuild=1;
if ($section=="Lip")
	if (`objExists upperLip0`)
		$canBuild=1;
if ($section=="Tongue")
	if (`objExists Tongue0`)
		$canBuild=1;
return $canBuild;
}

global proc asBuildAdvancedFace ()
{
global string $gMainProgressBar;
global string $gSelect;
global int $stepBuild;
setToolTo $gSelect;
asSetFixedWrapOptions;
int $modifier=`getModifiers`;
int $buildEyeBall=`asCanBuild EyeBall`;
int $buildEyeLid=`asCanBuild EyeLid`;
int $buildEyeBrow=`asCanBuild EyeBrow`;
int $buildJaw=`asCanBuild Jaw`;
int $buildCheek=`asCanBuild Cheek`;
int $buildLip=`asCanBuild Lip`;
int $buildTongue=`asCanBuild Tongue`;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[],$tempFloat[];
string $tempString[],$allFaceGeo[],$cmds[],$deformJointsList[],$allBefore[];
string $cmd;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`objExists FaceFitSkeleton`)
	error "Face FitSkeleton not found";
if (!`objExists $geometry`)
	error ("Face Geometry:\""+$geometry+"\" not found");
if (! `objExists FaceMotionSystem`)
	{
	if (`objExists Eye_R`) error "Object called \"Eye_R\" exists, rename this to another name before building face-setup";
	if (`objExists Eye_L`) error "Object called \"Eye_L\" exists, rename this to another name before building face-setup";
	}
if (`objExists EyeBrowMain0`)
	if (!size(`listConnections EyeBrowMain0.tx`))
		error "No Fit Animation Found, Click the \"Animate Fit\" button, before building the face";
if (!`asConfirmIfNotInBuildPose`)
	return;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
currentTime 0;

	
if ($stepBuild==1 || $stepBuild==0)
	{
	// Unlock All SkinInfluences
	if (`objExists DeformSet`)
		{
		$deformJointsList=`sets -q "DeformSet"`;
		for ($i=0;$i<size($deformJointsList);$i++)
			if (`attributeExists lockInfluenceWeights $deformJointsList[$i]`)
				if (`getAttr ($deformJointsList[$i]+".lockInfluenceWeights")`)
					setAttr ($deformJointsList[$i]+".lockInfluenceWeights") 0;
		}
	}

if (`objExists PausedForSim2`)
	{
	delete PausedForSim2;
	$stepBuild=15;asBuildAdvancedFace;
	$stepBuild=16;asBuildAdvancedFace;
	$stepBuild=17;asBuildAdvancedFace;
	$stepBuild=18;asBuildAdvancedFace;
	return;
	}
if (`objExists PausedForSim1`)
	{
	delete PausedForSim1;
	$stepBuild=9;asBuildAdvancedFace;
	$stepBuild=10;asBuildAdvancedFace;
	$stepBuild=11;asBuildAdvancedFace;
	$stepBuild=12;asBuildAdvancedFace;
	$stepBuild=13;asBuildAdvancedFace;
	$stepBuild=14;asBuildAdvancedFace;
	createNode -n PausedForSim2 transform;
	select -cl;
	progressBar -e -ep $gMainProgressBar;
	print "// Paused before NCloth sim, you may adjust Ncloth before proceeding\n.";
	return;
	}

if ($stepBuild==2 || $stepBuild==0)
	{
	if (`headsUpDisplay -q -ex HUDFitModeFace`)
		asToggleFitModeFace;
	
	if (`checkBox -q -v asFaceKeepBlendShapes` && `objExists asFaceBS`)
		asKeepBlendShapes;
	
	//Rebuild ?
	if (`objExists FaceMotionSystem`) 
		{
		if (!`asConfirmIfNotInBuildPose`)
			return;
		//Pre Rebuild CurveShapes
		string $controlSetMembers[]=`sets -q FaceControlSet`;
		//add ctrlBox, so Shape of this is maintained in ReBuild
		if (`objExists "ctrlBox"`)
			$controlSetMembers[size($controlSetMembers)]="ctrlBox";
		string $curveShape;
		int $spans,$degree,$numCVs;
		float $cvPos[3];
		for ($i=0;$i<size($controlSetMembers);$i++)
			{
			$tempString=`listRelatives -s $controlSetMembers[$i]`;
			$curveShape=$tempString[0];
			if (!`objExists $curveShape`)
				continue;
			if (`objectType $curveShape`!="nurbsCurve")
				continue;
			$spans=`getAttr ($curveShape+".spans")`;
			$degree=`getAttr ($curveShape+".degree")`;
			$numCVs=$spans+$degree;
			for ($y=0;$y<$numCVs;$y++)
				{
				$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
				$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
				}
			}
		//ctrlBox xform
		$tempFloat=`getAttr ctrlBox.t`;
		$cmds[size($cmds)]="setAttr -type float3 ctrlBox.t "+$tempFloat[0]+" "+$tempFloat[1]+" "+$tempFloat[2]+";";
		$tempFloat=`getAttr ctrlBox.r`;
		$cmds[size($cmds)]="setAttr -type float3 ctrlBox.r "+$tempFloat[0]+" "+$tempFloat[1]+" "+$tempFloat[2]+";";
		$tempFloat=`getAttr ctrlBox.s`;
		$cmds[size($cmds)]="setAttr -type float3 ctrlBox.s "+$tempFloat[0]+" "+$tempFloat[1]+" "+$tempFloat[2]+";";
	
		//lockWeights all but headJoint
		$tempString=`listConnections ($skinCluster+".matrix")`;
		for ($i=0;$i<size($tempString);$i++)
			if ($tempString[$i]!=$headJoint)
				setAttr ($tempString[$i]+".lockInfluenceWeights") 1;
		//remove previous inf`s
		select `listRelatives -ad -type joint FaceDeformationSystem`;
		select -add $geometry;
		RemoveInfluence;
		skinPercent -normalize 1 $skinCluster $geometry;
		for ($i=0;$i<size($tempString);$i++)
			setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
		delete `sets -q FaceAllSet`;
		//intermediateObject
		for ($i=0;$i<size($allFaceGeo);$i++)
			{
			if ($allFaceGeo[$i]==$geometry)
				continue;
	//		if (size(`listRelatives -s -ni $allFaceGeo[$i]`))
	//			continue;
			$tempString=`listRelatives -s $allFaceGeo[$i]`;
			for ($y=1;$y<size($tempString);$y++)
				delete $tempString[$y];
			if (size($tempString))
				setAttr ($tempString[0]+".intermediateObject") 0;
			}
		}
	}

if ($stepBuild==3 || $stepBuild==0)
	{	
	//Prep
	setAttr -l 0 FaceFitSkeleton.v;
	setAttr -l 1 FaceFitSkeleton.v 0;
	$allBefore=`ls`;
	asFaceEnsureAdvancedBase;
	spaceLocator -n tempLoc;
	setAttr tempLoc.v 0;
	createNode -n tempLocFlip transform;
	parent tempLoc tempLocFlip;
	
	if ($buildEyeBall)
		{
		setAttr ctrlBoxEye_L.v 1;
		setAttr ctrlBoxEye_R.v 1;
		}
	if ($buildEyeBrow)
		{
		setAttr ctrlBoxBrow_R.v 1;
		setAttr ctrlBoxBrow_L.v 1;
		}
	if ($buildCheek)
		{
		setAttr ctrlBoxCheek_R.v 1;
		setAttr ctrlBoxCheek_L.v 1;
		setAttr ctrlBoxNose_R.v 1;
		setAttr ctrlBoxNose_L.v 1;
		}
	if ($buildJaw)
		{
		setAttr ctrlBoxMouth_M.v 1;
		setAttr ctrlBoxMouthCorner_R.v 1;
		setAttr ctrlBoxMouthCorner_L.v 1;
		}
	if ($buildTongue)
		setAttr ctrlBoxTongue_M.v 1;
	
	setAttr -l 0 -k 1 ctrlEye_L.sx;setAttr -l 0 -k 1 ctrlEye_L.sy;setAttr -l 0 -k 1 ctrlEye_L.sz;
	setAttr -l 0 -k 1 ctrlEye_R.sx;setAttr -l 0 -k 1 ctrlEye_R.sy;setAttr -l 0 -k 1 ctrlEye_R.sz;
	
	//create faceTargets by wrapping
	createNode -n faceTargets transform;
	setAttr faceTargets.v 0;
	duplicate -n tempTarget $geometry;
	asLockAttr tempTarget 0 0 0 0;
	//sets -remove jawArea tempTarget.vtx[0:9999];
	parent tempTarget faceTargets;
	$tempString=`listRelatives -s tempTarget`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
	setAttr tempTarget.v 0;
	duplicate -n target_default tempTarget;
	createNode -n tempNearestPointOnCurve nearestPointOnCurve;
	asUpdateAllSet $allBefore;
	}

//EyeBall
if ($stepBuild==4 || $stepBuild==0)
	if ($buildEyeBall)
		{
		$allBefore=`ls`;
		asAdvancedEyeBall;
		asUpdateAllSet $allBefore;
		}


//EyeLid
if ($stepBuild==5 || $stepBuild==0)
	if ($buildEyeLid)
		{
		$allBefore=`ls`;
		asAdvancedEyeLid;
		asUpdateAllSet $allBefore;
		setAttr "FaceMotionSystem.visibility" 0;
		}

//EyeBrow detect
if ($stepBuild==6 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		$allBefore=`ls`;
		asAdvancedEyeBrowPartA;
		asUpdateAllSet $allBefore;
		}

//EyeBrow Cutout
if ($stepBuild==7 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		$allBefore=`ls`;
		asAdvancedEyeBrowPartB;
		asUpdateAllSet $allBefore;
		}

//EyeBrow Ncloth Prep
if ($stepBuild==8 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		$allBefore=`ls`;
		asAdvancedEyeBrowPartC;
		asUpdateAllSet $allBefore;
		if ($stepBuild==0 && $modifier%8)
			{
			createNode -n PausedForSim1 transform;
			select -cl;
			progressBar -e -ep $gMainProgressBar;
			print "// Paused before NCloth sim, you may adjust Ncloth before proceeding\n.";
			return;
			}
		playbackOptions -min 0 -max 190 -ast 0 -aet 190;
		}

//EyeBrow Ncloth Sim
if ($stepBuild==9 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		$allBefore=`ls`;
		string $faceTargets[]={"brow_raiser_R","brow_lowerer_R","brow_innerRaiser_R","brow_innerLowerer_R","brow_squeeze_R","brow_outerRaiser_R"};
		if (`objExists foreheadGeo`)
			asFaceSkinSim $faceTargets foreheadGeo;//nCloth sim
		if (`objExists "Group"`) setAttr "Group.v" 1;
		if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
		if (`objExists foreheadGeo`)
			{
			select foreheadGeo;
			DeleteHistory;
			delete foreheadGeoSlideOn tempdynamicConstraint foreheadGeo;
			}
		for ($a=1;$a<5;$a++)
			delete ("foreHeadBorderCurve"+$a);
		delete tempNClothConstraint2 tempNClothRigid1 eyeBrowPoly EyeBrowMainPoly EyeBrowExtrude EyeBrowCircle EyeBrowMainCurve2;
		asUpdateAllSet $allBefore;
		}

//Jaw detect
if ($stepBuild==10 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		$allBefore=`ls`;
		asAdvancedJaw;
		asFaceBsSdk ctrlMouth_M.ty -1 FKSDK2Jaw_M.rz 15;
		asFaceBsSdk ctrlMouth_M.ty -1 FKSDK2Jaw_M.tx ($scale/30);
		setAttr FaceMotionSystem.v 1;
		asUpdateAllSet $allBefore;
		}

//Jaw Skin PartA
if ($stepBuild==11 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		$allBefore=`ls`;
		asSkinJawPartA;
		asUpdateAllSet $allBefore;
		}

//Detect Jaw area
if ($stepBuild==12 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		$allBefore=`ls`;
		asSkinJawPartB;
		asUpdateAllSet $allBefore;
		}

//Jaw Cutout
if ($stepBuild==13 || $stepBuild==0)
	if ($buildCheek)
		{
		$allBefore=`ls`;
		asAdvancedCheekPartA;
		asUpdateAllSet $allBefore;
		}

//Detect lip
if ($stepBuild==14 || $stepBuild==0)
	if ($buildCheek)
		{
		$allBefore=`ls`;
		asAdvancedCheekPartB;
		asUpdateAllSet $allBefore;
		}

//Jaw Skin  (Cheek)
if ($stepBuild==15 || $stepBuild==0)
	if ($buildCheek)
		{
		$allBefore=`ls`;
		for ($a=1;$a<5;$a++)
			delete ("JawBorderCurve"+$a);
		string $faceTargets[]=
			{
			"mouth_rollInUpper_R","mouth_rollInLower_R","mouth_rollOutUpper_R","mouth_rollOutLower_R",
			"chin_raiser_C","mouth_wide_C","mouth_oo_C","chinRaiser_C","mouth_presser_R","cheek_raiser_R",
			"cheek_puff_R","cheek_suck_R","nose_wrinkler_R","nose_dilator_R","nose_compressor_R",
			"mouth_puckerAnti_R","mouth_pucker_R","mouth_smile_R","mouth_frown_R"
			};
		asFaceSkinSim $faceTargets mouthGeo;
		select mouthGeo;
		DeleteHistory;
		string $deleteObjs[]={"lipGeometry","JawCylinderMainPoly","NoseCylinderPoly","lowerEyeLidCylinderOuterPoly",
			"noseCornerSpherePoly","lipGeometry","JawCylinderMainPoly","NoseCylinderPoly","lowerEyeLidCylinderOuterPoly",
			"noseCornerSpherePoly","CheekPuffDynamicConstraint","CheekSuckDynamicConstraint","mouthNCloth","mouthGeo"};
		for ($i=0;$i<size($deleteObjs);$i++)
			if (`objExists $deleteObjs[$i]`)
				delete $deleteObjs[$i];
		if (`objExists "Group"`) setAttr "Group.v" 1;
		if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
		asUpdateAllSet $allBefore;
		}

//Jaw Skin  (Cheek)
if ($stepBuild==16 || $stepBuild==0)
	{
	$allBefore=`ls`;
	if ($buildTongue)
		asAdvancedTongue;
	asUpdateAllSet $allBefore;
	}

//Squint
if ($stepBuild==17 || $stepBuild==0)
	{
	$allBefore=`ls`;
	if ($buildEyeBall)
		asFaceSquintByLattice;
	asUpdateAllSet $allBefore;
	}

//The Rest
if ($stepBuild==18 || $stepBuild==0)
	{
	$allBefore=`ls`;
	asBuildAdvancedFaceContinue2;
	asUpdateAllSet $allBefore;
	}

//Post Rebuild
if ($stepBuild==0)
	for ($cmd in $cmds)
		if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
}



global proc asBuildAdvancedFaceContinue2 ()
{
global string $gMainProgressBar;
int $modifier=`getModifiers`;
int $buildEyeBall=`asCanBuild EyeBall`;
int $buildEyeLid=`asCanBuild EyeLid`;
int $buildEyeBrow=`asCanBuild EyeBrow`;
int $buildJaw=`asCanBuild Jaw`;
int $buildCheek=`asCanBuild Cheek`;
int $buildLip=`asCanBuild Lip`;
int $buildTongue=`asCanBuild Tongue`;
int $tempInts[];
float $scale=`asFaceGetScale`;
float $pos[];
string $upperLower,$lidJoint,$eyeJoint;
string $tempString[],$tempString2[],$deformJoints[],$lidJoints[],$lipJoints[],$insideVtxs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $allBefore[]=`ls`;

cycleCheck -e off;

if (`objExists PausedForSim2`)
	delete PausedForSim2;


//Keep Blendshapes
if (`checkBox -q -v asFaceKeepBlendShapes` && `objExists keepTweakedBlendShapes`)
	{
	string $shps[];
	string $keepShpsXforms[]=`listRelatives -c keepTweakedBlendShapes`;
	for ($i=0;$i<size($keepShpsXforms);$i++)
		$shps[size($shps)]=`substitute "_tweaked" $keepShpsXforms[$i] ""`;
	for ($i=0;$i<size($shps);$i++)
		connectAttr ($shps[$i]+"_tweaked.outMesh") ($shps[$i]+".inMesh");
	}

//asFaceBS blendShape
if (`objExists faceTargets`)
	{
	delete tempTarget target_default;
	select `listRelatives -c faceTargets`;
	select -add $geometry;
	$tempString=`blendShape -frontOfChain`;
	rename $tempString asFaceBS;
	}

//asFaceBsSdk
for ($a=0;$a<2;$a++)
	{
	if ($a==0)	$side="_R";
	if ($a==1)	$side="_L";

	if ($buildEyeBrow)
		{
		asFaceBsSdk ("ctrlBrow"+$side+".ty")  1 ("asFaceBS.brow_raiser"+$side) 1;
		setAttr ("asFaceBS_brow_raiser"+$side+".preInfinity") 1; // no neg weight when drive<0
	
		asFaceBsSdk ("ctrlBrow"+$side+".ty") -1 ("asFaceBS.brow_lowerer"+$side) 1;
		setAttr ("asFaceBS_brow_lowerer"+$side+".postInfinity") 0; // no neg weight when drive>0
	
		asFaceBsSdk ("ctrlBrow"+$side+".tx")  1 ("asFaceBS.brow_innerRaiser"+$side) 1;
		setAttr ("asFaceBS_brow_innerRaiser"+$side+".preInfinity") 1; // no neg weight when drive<0
	
		asFaceBsSdk ("ctrlBrow"+$side+".tx") -1 ("asFaceBS.brow_innerLowerer"+$side) 1;
		setAttr ("asFaceBS_brow_innerLowerer"+$side+".postInfinity") 0; // no neg weight when drive>0
	
		if (!`attributeExists squeeze ("ctrlBrow"+$side)`)
			addAttr -ln "squeeze"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
		asFaceBsSdk ("ctrlBrow"+$side+".squeeze") 10 ("asFaceBS.brow_squeeze"+$side) 1;
	
		if (!`attributeExists outerUpDown ("ctrlBrow"+$side)`)
			addAttr -ln "outerUpDown"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
		asFaceBsSdk ("ctrlBrow"+$side+".outerUpDown") 10 ("asFaceBS.brow_outerRaiser"+$side) 1;
		//	setAttr ("asFaceBS_brow_outerRaiser"+$side+".preInfinity") 1; // no neg weight when drive<0
		}

	if ($buildEyeBall)
		{
		if (!`attributeExists squint ("ctrlEye"+$side)`)
			addAttr -ln "squint"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
		asFaceBsSdk ("ctrlEye"+$side+".squint") 10 ("asFaceBS.eye_squint"+$side) 1;
		}

	if ($buildCheek)
		{
		asFaceBsSdk ("ctrlCheek"+$side+".ty") 1 ("asFaceBS.cheek_raiser"+$side) 1;
		setAttr ("asFaceBS_cheek_raiser"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlCheek"+$side+".tx") 1 ("asFaceBS.cheek_puff"+$side) 1;
		setAttr ("asFaceBS_cheek_puff"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlCheek"+$side+".tx") -1 ("asFaceBS.cheek_suck"+$side) 1;
		setAttr ("asFaceBS_cheek_suck"+$side+".postInfinity") 0; // no neg weight when drive>0
		}

	if ($buildCheek)
		{
		asFaceBsSdk ("ctrlNose"+$side+".ty") 1 ("asFaceBS.nose_wrinkler"+$side) 1;
		setAttr ("asFaceBS_nose_wrinkler"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlNose"+$side+".tx") 1 ("asFaceBS.nose_dilator"+$side) 1;
		setAttr ("asFaceBS_nose_dilator"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlNose"+$side+".tx") -1 ("asFaceBS.nose_compressor"+$side) 1;
		setAttr ("asFaceBS_nose_compressor"+$side+".postInfinity") 0; // no neg weight when drive>0
		}
	}

if ($buildCheek)
	{
	asFaceBsSdk ctrlMouth_M.tx 1 asFaceBS.mouth_wide_C 1;
	setAttr ("asFaceBS_mouth_wide_C.preInfinity") 1; // no neg weight when drive<0
	
	asFaceBsSdk ctrlMouth_M.tx -1 asFaceBS.mouth_oo_C 1;
	setAttr ("asFaceBS_mouth_oo_C.postInfinity") 0; // no neg weight when drive>0
	}

if ($buildJaw)
	{
	if (!`attributeExists JAW ctrlMouth_M`)
		addAttr -k 0 -ln "JAW" -at "double" ctrlMouth_M;setAttr -l 1 -cb 1 ctrlMouth_M.JAW;
	if (!`attributeExists jawSide ctrlMouth_M`)
		addAttr -ln "jawSide"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawSide 10 FKSDK1Jaw_M.ry ($scale*4.0);
	asFaceBsSdk ctrlMouth_M.jawSide -10 FKSDK1Jaw_M.ry ($scale*-4.0);	
	if (!`attributeExists jawForward ctrlMouth_M`)
		addAttr -ln "jawForward"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawForward 10 FKSDK1Jaw_M.tx ($scale/35.0);
	asFaceBsSdk ctrlMouth_M.jawForward -10 FKSDK1Jaw_M.tx ($scale/-35.0);
	if (!`attributeExists CHIN ctrlMouth_M`)
		addAttr -k 0 -ln "CHIN" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.CHIN;
	if (!`attributeExists chinRaiser ctrlMouth_M`)
		addAttr -ln "chinRaiser"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.chinRaiser 10 asFaceBS.chinRaiser_C 1;
	}
if ($buildCheek)
	{
	if (!`attributeExists LIP_PRESS ctrlMouth_M`)
		addAttr -k 0 -ln "LIP_PRESS" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.LIP_PRESS;
	if (!`attributeExists lipPress_R ctrlMouth_M`)
		addAttr -ln "lipPress_R"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	if (!`attributeExists lipPress_L ctrlMouth_M`)
		addAttr -ln "lipPress_L"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.lipPress_R 10 asFaceBS.mouth_presser_R 1;
	asFaceBsSdk ctrlMouth_M.lipPress_L 10 asFaceBS.mouth_presser_L 1;
	
	for ($a=0;$a<2;$a++) {if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		if (!`attributeExists LIP_ROLL ctrlMouth_M`)
			addAttr -k 0 -ln "LIP_ROLL" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.LIP_ROLL;
		if (!`attributeExists ("lipUpperRoll"+$side) ctrlMouth_M`)
			addAttr -ln ("lipUpperRoll"+$side)  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
		asFaceBsSdk ("ctrlMouth_M.lipUpperRoll"+$side) -10 ("asFaceBS.mouth_rollInUpper"+$side) 1;
		setAttr ("asFaceBS_mouth_rollInUpper"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouth_M.lipUpperRoll"+$side) 10 ("asFaceBS.mouth_rollOutUpper"+$side) 1;
		setAttr ("asFaceBS_mouth_rollOutUpper"+$side+".preInfinity") 1; // no neg weight when drive<0
		}
	for ($a=0;$a<2;$a++) {if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		if (!`attributeExists ("lipLowerRoll"+$side) ctrlMouth_M`)
			addAttr -ln ("lipLowerRoll"+$side)  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
		asFaceBsSdk ("ctrlMouth_M.lipLowerRoll"+$side) -10 ("asFaceBS.mouth_rollInLower"+$side) 1;
		setAttr ("asFaceBS_mouth_rollInLower"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouth_M.lipLowerRoll"+$side) 10 ("asFaceBS.mouth_rollOutLower"+$side) 1;
		setAttr ("asFaceBS_mouth_rollOutLower"+$side+".preInfinity") 1; // no neg weight when drive<0
		}
	for ($a=0;$a<2;$a++) {if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		asFaceBsSdk ("ctrlMouthCorner"+$side+".tx") 1 ("asFaceBS.mouth_puckerAnti"+$side) 1;
		setAttr ("asFaceBS_mouth_puckerAnti"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".tx") -1 ("asFaceBS.mouth_pucker"+$side) 1;
		setAttr ("asFaceBS_mouth_pucker"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".ty") 1 ("asFaceBS.mouth_smile"+$side) 1;
		setAttr ("asFaceBS_mouth_smile"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".ty") -1 ("asFaceBS.mouth_frown"+$side) 1;
		setAttr ("asFaceBS_mouth_frown"+$side+".postInfinity") 0; // no neg weight when drive>0
		}
	}
if (`objExists faceTargets`)
	delete faceTargets;


//PingPongs
if ($buildEyeBrow)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
	
		asPingPong EyeBrowMain0 browInner $b $side 6 1 1;
		asPingPong EyeBrowMain3 browHalf $b $side 10 1 1;
		asPingPong EyeBrowMain6 browOuter $b $side 6 1 1;
		}
	//Weighting PingPongs via a skinCage(foreHeadMesh)
	loft -n foreHeadLoftNurbs -ch 0 -u 1 -c 0 -ar 0 -d 1 -ss 1 -rn 0 -po 0 -rsn true EyeBrowOuterCurve EyeBrowMainCurve upperEyeLidOuterCurve;
	nurbsToPoly -n foreHeadLoft -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs;
	duplicate -n foreHeadLoft2 foreHeadLoft;
	setAttr foreHeadLoft2.sx -1;
	loft -n foreHeadLoftNurbs3 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true foreHeadLoft2.e[13] foreHeadLoft.e[13];
	nurbsToPoly -n foreHeadLoft3 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs3;
	loft -n foreHeadLoftNurbs4 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true foreHeadLoft2.e[15] foreHeadLoft.e[15];
	nurbsToPoly -n foreHeadLoft4 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs4;
	loft -n foreHeadLoftNurbs5 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true foreHeadLoft.e[17] foreHeadLoft.e[0];
	nurbsToPoly -n foreHeadLoft5 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs5;
	loft -n foreHeadLoftNurbs6 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true foreHeadLoft2.e[17] foreHeadLoft2.e[0];
	nurbsToPoly -n foreHeadLoft6 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs6;
	delete foreHeadLoftNurbs foreHeadLoftNurbs3 foreHeadLoftNurbs4 foreHeadLoftNurbs5 foreHeadLoftNurbs6;
	polyUnite -n foreHeadMesh -ch 0 -mergeUVSets 1 foreHeadLoft foreHeadLoft foreHeadLoft2 foreHeadLoft3 foreHeadLoft4 foreHeadLoft5 foreHeadLoft6;
	polyMergeVertex -d 0.01 -am 1 -ch 0 foreHeadMesh;
	spaceLocator -n tempGeoSnapLoc;
	spaceLocator -n tempGeoSnapLocOffset;
	parent tempGeoSnapLoc tempGeoSnapLocOffset;
	int $popOutVtxNrs[]={29,30};
	for ($a=0;$a<size($popOutVtxNrs);$a++)
		{
		$pos=`xform -q -ws -t ("foreHeadMesh.vtx["+$popOutVtxNrs[$a]+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempGeoSnapLocOffset;
		geometryConstraint $geometry tempGeoSnapLoc;
		for ($i=0;$i<10;$i++)
		  {
			setAttr tempGeoSnapLoc.tx 0;
			setAttr tempGeoSnapLoc.ty 0;
			}
		$pos=`xform -q -ws -t tempGeoSnapLoc`;
		xform -ws -t 0 $pos[1] $pos[2] ("foreHeadMesh.vtx["+$popOutVtxNrs[$a]+"]");
		}
	delete tempGeoSnapLocOffset;
	
	select foreHeadMesh FaceAttachToHead;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] foreHeadSC;
	string $browJoints[]={"browInnerJoint_R","browHalfJoint_R","browOuterJoint_R","browInnerJoint_L","browHalfJoint_L","browOuterJoint_L"};
	int $browJointVtxNrs[]={7,6,11,21,20,25};
	for ($i=0;$i<size($browJoints);$i++)
		{
		skinCluster -e -ai $browJoints[$i] -lw false -wt 0 foreHeadSC;
		skinPercent -tv $browJoints[$i] 1 foreHeadSC ("foreHeadMesh.vtx["+$browJointVtxNrs[$i]+"]");
		}
	skinPercent -tv browInnerJoint_R 0.5 -tv browHalfJoint_R 0.5 foreHeadSC foreHeadMesh.vtx[9];
	skinPercent -tv browInnerJoint_L 0.5 -tv browHalfJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[23];
	skinPercent -tv browHalfJoint_R 0.5 -tv browOuterJoint_R 0.5 foreHeadSC foreHeadMesh.vtx[13];
	skinPercent -tv browHalfJoint_L 0.5 -tv browOuterJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[27];
	skinPercent -tv browInnerJoint_R 0.5 -tv browInnerJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[29];
	
	int $tempInts[]=`polyEvaluate -v $geometry`;
	int $numVtx=$tempInts[0];
	select -cl;
	for ($i=0;$i<$numVtx;$i++)
		{
		$vtx=$geometry+".vtx["+$i+"]";
		$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $vtx`;
		if (size($infs)==1 && $infs[0]==$headJoint)
			select -add $vtx;
		}
	string $headJointWeightedVtxs[]=`ls -sl`;
	select -r foreHeadMesh.vtx[0:28];
	select -add $headJointWeightedVtxs;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	delete foreHeadMesh;
	}

select -r $geometry;
doPruneSkinClusterWeightsArgList 1 { "0.001" };
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

if ($buildCheek)
	{
	//SoftModPingPongs
	//determine default radius if first build
	if (`getAttr cheek.falloffRadius`==1)
		{
	  float $posA[]=`xform -q -ws -t cheek`;
	  float $posB[]=`xform -q -ws -t Lip6`;
	  float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	  setAttr cheek.falloffRadius $dist;
		}
	if (`getAttr noseCorner.falloffRadius`==1)
		{
	  float $posA[]=`xform -q -ws -t noseCorner`;
	  float $posB[]=`xform -q -ws -t Nose6`;
	  float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	  setAttr noseCorner.falloffRadius $dist;
		}
	
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		softCluster cheek cheek $b $side;
		softCluster noseCorner noseCorner $b $side;
		}
	}
	

//Lip
if ($buildLip)
	asAdvancedLip;


//Post
progressBar -e -ep $gMainProgressBar;
$deleteObjs={"eyeLidVtxs","foreHeadVtxs","grownUpLipVtxs","grownUpLipVtxsInverse","jawArea","tempLocFlip",
		"tempLoc","nucleus1","keepTweakedBlendShapes"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

//Also delete iconsGroup
if (`objExists iconsGroup`) delete iconsGroup;

//Also update buildPose
select `sets -q FaceControlSet`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k -shortNames $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controlSetMembers[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
setAttr -type "string" faceBuildPose.udAttr $setAttrCmd;

asUpdateAllSet $allBefore;

cycleCheck -e on;

select -cl;
print ("// Advanced Face created\n");
}

global proc asAdvancedEyeBall ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $eyeBallPos[3]=`xform -q -ws -t FitEyeBall`;
float $scale=`asFaceGetScale`;
string $tempString[];

createNode -n EyeSetup -p FaceMotionSystem transform;
string $eye,$eyeBallSkinCluster;
string $eyeGeos[];

//EyeAimSetup
createNode -n EyeAimSetup -p EyeSetup transform;
createNode -n EyeAimFollowHead -p EyeAimSetup transform;
parentConstraint $headJoint EyeAimFollowHead;
scaleConstraint $headJoint EyeAimFollowHead;
$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] AimEye_M;
setAttr AimEye_MShape.overrideEnabled 1;
setAttr AimEye_MShape.overrideColor 17;
sets -add FaceControlSet AimEye_M;
scale -r -p 0 0 0 ($scale/10.0) ($scale/10.0) ($scale/10.0) AimEye_M.cv[0:4];
createNode -n AimAimAt -p EyeAimSetup transform;
xform -ws -t 0 $eyeBallPos[1] $eyeBallPos[2] AimAimAt;
//aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject AimAimAt AimAimAt AimEye_M;
//setAttr -k 0 AimEye_M.rx;setAttr -k 0 AimEye_M.ry;setAttr -k 0 AimEye_M.rz;
createNode -n AimEyeOffset_M transform;
createNode -n AimEyeFollow_M transform;
parent AimEyeFollow_M AimEyeOffset_M;
parent AimEye_M AimEyeFollow_M;
parent AimEyeOffset_M Aimcontrols;
xform -ws -t 0 $eyeBallPos[1] ($eyeBallPos[2]+$scale) AimEyeOffset_M;
createNode -n AimEyeUpVec -p FitEyeBall transform;
parent AimEyeUpVec EyeAimFollowHead;

addAttr -k 1 -ln aim -at double -min 0 -max 10 -dv 0 AimEye_M;
createNode -n eyeAimSetRange setRange;
setAttr eyeAimSetRange.minX 0;
setAttr eyeAimSetRange.maxX 1;
setAttr eyeAimSetRange.oldMinX 0;
setAttr eyeAimSetRange.oldMaxX 10;
connectAttr AimEye_M.aim eyeAimSetRange.value.valueX;

addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 AimEye_M;
createNode -n eyeAimFollowSetRange setRange;
setAttr eyeAimFollowSetRange.minX 0;setAttr eyeAimFollowSetRange.minY 1;
setAttr eyeAimFollowSetRange.maxX 1;setAttr eyeAimFollowSetRange.maxY 0;
setAttr eyeAimFollowSetRange.oldMinX 0;setAttr eyeAimFollowSetRange.oldMinY 0;
setAttr eyeAimFollowSetRange.oldMaxX 10;setAttr eyeAimFollowSetRange.oldMaxY 10;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueX;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueY;
parentConstraint -mo $headJoint FaceGroup AimEyeFollow_M;
connectAttr eyeAimFollowSetRange.outValue.outValueY AimEyeFollow_M_parentConstraint1.FaceGroupW1;
connectAttr eyeAimFollowSetRange.outValue.outValueX ("AimEyeFollow_M_parentConstraint1."+$headJoint+"W0");

for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists FitEyeBall`)
		continue;
	if ($b==1) $side="_R"; else $side="_L";

	select FaceAttachToHead;
	joint -n ("Eye"+$side);
	setAttr ("Eye"+$side+".rotateOrder") 2;
	xform -ws -t ($eyeBallPos[0]*$b) $eyeBallPos[1] $eyeBallPos[2] ("Eye"+$side);
	delete `orientConstraint FitEyeBall  ("Eye"+$side)`;
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("Eye"+$side);
	setAttr ("Eye"+$side+".segmentScaleCompensate") 0;
//	setAttr ("Eye"+$side+".jointOrientX") 180;
	if ($side=="_L")
		setAttr Eye_L.jointOrientY (`getAttr Eye_R.jointOrientY`*-1);
	joint -n ("EyeEnd"+$side);
	if (`objExists DeformSet`)
		sets -add DeformSet ("EyeEnd"+$side);
	setAttr ("EyeEnd"+$side+".tx") (`getAttr FitEyeBall.sx`*1.55);

	$eyeJoint="Eye"+$side;
	$eye=`textField -q -tx ("asFaceEye"+$side+"TextField")`;
	if ($eye=="")
		continue;
	tokenize $eye " " $tempString;
	clear $eyeGeos;
	for ($i=0;$i<size($tempString);$i++)
		$eyeGeos[$i]=$tempString[$i];

	for ($i=0;$i<size($eyeGeos);$i++)
		{
		$haveSkinCluster=0;
		$historyNodes=`listHistory $eyeGeos[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$eyeBallSkinCluster=$historyNodes[$y];
				}
	
		if ($haveSkinCluster)
			{
			skinCluster -e -lw true -wt 0 -ai $eyeJoint $eyeBallSkinCluster;
			setAttr ($eyeJoint+".lockInfluenceWeights") 0;
			skinPercent -tv $eyeJoint 1 $eyeBallSkinCluster $eyeGeos[$i];
			}
		else
			{
			select $eyeJoint $eyeGeos[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			for ($y=0;$y<size($tempString);$y++)
				rename $tempString[$y] ("eyeSC"+$side);
			}
		}
	connectAttr ("ctrlEye"+$side+".sx") ($eyeJoint+".sz");
	connectAttr ("ctrlEye"+$side+".sy") ($eyeJoint+".sy");
	connectAttr ("ctrlEye"+$side+".sz") ($eyeJoint+".sx");
	//SDK
	asFaceBsSdk ("ctrlEye"+$side+".tx") 1 ($eyeJoint+".ry") -30;
	asFaceBsSdk ("ctrlEye"+$side+".tx") -1 ($eyeJoint+".ry") 30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") 1 ($eyeJoint+".rz") -30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") -1 ($eyeJoint+".rz") 30;
	//Look-at
	createNode -n ("EyeOffset"+$side) -p ("Eye"+$side) transform;
	parent ("EyeOffset"+$side) EyeAimFollowHead;
	duplicate -n ("EyeAimTargetOn"+$side) ("EyeOffset"+$side);
	parent ("EyeAimTargetOn"+$side) ("Eye"+$side);
	setAttr ("EyeAimTargetOn"+$side+".tx") $scale;
	parent ("EyeAimTargetOn"+$side) EyeSetup;
	duplicate -n ("EyeAimTargetOff"+$side) ("EyeAimTargetOn"+$side);
	parent ("EyeAimTargetOff"+$side) EyeAimFollowHead;
	parent ("EyeAimTargetOn"+$side) AimEye_M;
	duplicate -n ("EyeAim"+$side) ("EyeOffset"+$side);
	parent ("EyeAim"+$side) ("EyeOffset"+$side);
	createNode -n ("EyeAimBlend"+$side) blendColors;
	connectAttr ("EyeAim"+$side+".rotate") ("EyeAimBlend"+$side+".color1");
	connectAttr ("Eye"+$side+"_rotateY.output") ("EyeAimBlend"+$side+".color2G");
	connectAttr ("Eye"+$side+"_rotateZ.output") ("EyeAimBlend"+$side+".color2B");
	connectAttr -f ("EyeAimBlend"+$side+".outputR") ("Eye"+$side+".rx");
	connectAttr -f ("EyeAimBlend"+$side+".outputG") ("Eye"+$side+".ry");
	connectAttr -f ("EyeAimBlend"+$side+".outputB") ("Eye"+$side+".rz");

	aimConstraint -aimVector 1 0 0 -worldUpType objectrotation -worldUpObject AimEyeUpVec -worldUpVector 0 1 0 ("EyeAimTargetOff"+$side) ("EyeAimTargetOn"+$side) ("EyeAim"+$side);
	parent -w ("EyeAim"+$side);
	asAlign ("EyeOffset"+$side) ("EyeAim"+$side) 1 1 0 0;
	parent ("EyeAim"+$side) ("EyeOffset"+$side);
	connectAttr eyeAimSetRange.outValue.outValueX ("EyeAimBlend"+$side+".blender");
	}
}

global proc asAdvancedEyeLid ()
{
global string $gMainProgressBar;
int $tempInts[];
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint;
string $tempString[],$tempString2[],$tempString3[],$infs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

createNode -n LidSetup -p FaceMotionSystem transform;
createNode -n LidJoints -p LidSetup transform;
parentConstraint $headJoint LidJoints;
scaleConstraint $headJoint LidJoints;
setAttr -l 1 LidSetup.v 0;
select FaceAttachToHead;
joint -n faceLid;
setAttr faceLid.segmentScaleCompensate 0;
skinCluster -e -wt 0 -ai faceLid  -lw true $skinCluster;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	createNode -n ("LidSetup"+$side) transform;
	asAlign ("LidSetup"+$side) ("Eye"+$side) 1 1 0 0;
	parent ("LidSetup"+$side) faceLid;
	}

//Setup Lid
int $numLid=20;
int $numLidUpper=20;
int $numLidLower=20;
string $selectionMainVtxs[],$selectionMainVtxsAll[],$selectionOuterVtxs[],$selectionOuterVtxsAll[];
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
progressBar -e -st ("Setup EyeLid") -bp -ii 0 -min 0 -max 4 $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blink"+$side) -at double LidSetup;
	addAttr -dv 0.2 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blinkCenter"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLid"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLid"+$side) -at double LidSetup;
	addAttr -dv 1.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidFollow"+$side) -at double LidSetup;
	addAttr -dv 1.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidFollow"+$side) -at double LidSetup;

	createNode -n ("blinkCenterReverse"+$side) reverse;
	connectAttr ("LidSetup.blinkCenter"+$side) ("blinkCenterReverse"+$side+".inputX");

	createNode -n ("LidLocs"+$side) transform;
	setAttr ("LidLocs"+$side+".inheritsTransform") 0;
	parent ("LidLocs"+$side) LidSetup;
	setAttr -l 1 ("LidLocs"+$side+".v") 0;
	createNode -n ("LidCurves"+$side) transform;
	parent ("LidCurves"+$side) LidSetup;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		progressBar -e -s 1 $gMainProgressBar;
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		if (`attributeExists selection FaceFitEyeLidMain`)
			{
			$tempString[0]=`getAttr ("FaceFitEyeLidMain."+$upperLower+"Selection")`;
			tokenize $tempString[0] $selectionMainVtxs;
			$selectionMainVtxsAll=`stringArrayCatenate $selectionMainVtxsAll $selectionMainVtxs`;
			$numLid=size($selectionMainVtxs);
			if ($upperLower=="upper")
				$numLidUpper=$numLid;
			else
				$numLidLower=$numLid;
			$tempString[0]=`getAttr ("FaceFitEyeLidOuter."+$upperLower+"Selection")`;
			tokenize $tempString[0] $selectionOuterVtxs;
			$selectionOuterVtxsAll=`stringArrayCatenate $selectionOuterVtxsAll $selectionOuterVtxs`;
			}

		duplicate -n ($upperLower+"LidCurve2"+$side) ($upperLower+"EyeLidMainCurve");
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.004 ($upperLower+"LidCurve2"+$side);	
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[2]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[1]");
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[3]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[2]");
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[4]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[3]");
		if ($side=="_R")
			{
			//find best position for cv[2,1&3]
			int $nudgeVtxNrs[]={2,1,3};
			for ($i=0;$i<size($nudgeVtxNrs);$i++)
				{
				connectAttr -f ($upperLower+"LidCurve2"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;
				$pos=`xform -q -ws -t ($upperLower+"LidCurve2"+$side+".cv["+$nudgeVtxNrs[$i]+"]")`;
				setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
				$posA=`getAttr tempNearestPointOnCurve.position`;
				connectAttr -f ($upperLower+"EyeLidMainCurve.worldSpace[0]") tempNearestPointOnCurve.inputCurve;
				$posB=`getAttr tempNearestPointOnCurve.position`;
				move -r (($posB[0]-$posA[0])*2) (($posB[1]-$posA[1])*2) (($posB[2]-$posA[2])*2) ($upperLower+"LidCurve2"+$side+".cv["+$nudgeVtxNrs[$i]+"]");
				}
			}

		//Might need to flip over Left curve here
		if ($side=="_L")
			scale -r -p 0 0 0 -1 1 1 ($upperLower+"LidCurve2"+$side+".cv[0:4]");
		parent ($upperLower+"LidCurve2"+$side) ("LidCurves"+$side);

		//make Tweaked-Shape, so each cv is zero position at the correct place
		createNode -n ($upperLower+"LidCurve2"+$side+"TweakedShape") -p ($upperLower+"LidCurve2"+$side) nurbsCurve;
		connectAttr -f ($upperLower+"LidCurve2"+$side+"Shape.worldSpace[0]") ($upperLower+"LidCurve2"+$side+"TweakedShape.create");
		setAttr ($upperLower+"LidCurve2"+$side+"Shape.intermediateObject") 1;

		connectAttr -f ($upperLower+"LidCurve2"+$side+"Shape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		$curveCmd="curve -d 1 ";
		for ($i=1;$i<($numLid+1);$i++)
			{
			setAttr tempPointOnCurveInfo.parameter (($i-1)/($numLid-1.00));
			$pos=`getAttr tempPointOnCurveInfo.position`;
			if (`attributeExists selection FaceFitEyeLidMain`)
				{
				$pos=`xform -q -ws -t $selectionMainVtxs[$i-1]`;
				$pos[0]=$pos[0]*$b;
				}
			$eyeJoint="Eye"+$side;
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"LidCurve1"+$side);
		duplicate -n ($upperLower+"EyeLidMainCurve1"+$side) ($upperLower+"LidCurve1"+$side);
		parent ($upperLower+"LidCurve1"+$side) ("LidCurves"+$side);

		//EyeLidOuterCurve1 (for loft)
		connectAttr -f ($upperLower+"EyeLidOuterCurveShape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		$curveCmd="curve -d 1 ";
		
		int $numLowerLid=20;
		if (`attributeExists selection FaceFitEyeLidMain`)
			$numLowerLid=size($selectionOuterVtxs);
		for ($i=1;$i<$numLowerLid+1;$i++)
			{
			setAttr tempPointOnCurveInfo.parameter (($i-1)/($numLid-1.00));
			$pos=`getAttr tempPointOnCurveInfo.position`;
			if (`attributeExists selection FaceFitEyeLidMain`)
				{
				$pos=`xform -q -ws -t $selectionOuterVtxs[$i-1]`;
				$pos[0]=$pos[0]*$b;
				}
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"EyeLidOuterCurve1"+$side);
		$spans=`getAttr ($upperLower+"EyeLidMainCurve1"+$side+".spans")`;
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 1 -tol 0.004 ($upperLower+"EyeLidOuterCurve1"+$side);	

		for ($i=1;$i<($numLid+1);$i++)
			{
			spaceLocator -n ($upperLower+"LidLoc"+$i+$side);
			parent ($upperLower+"LidLoc"+$i+$side) ("LidLocs"+$side);
			createNode -n ($upperLower+"LidPoci"+$i+$side) pointOnCurveInfo;
			setAttr ($upperLower+"LidPoci"+$i+$side+".turnOnPercentage") 1;
			setAttr ($upperLower+"LidPoci"+$i+$side+".parameter") (($i-1)/($numLid-1.00));
			connectAttr ($upperLower+"LidPoci"+$i+$side+".position") ($upperLower+"LidLoc"+$i+$side+".translate");
			connectAttr ($upperLower+"LidCurve1"+$side+"Shape.worldSpace[0]") ($upperLower+"LidPoci"+$i+$side+".inputCurve");

			createNode -n ($upperLower+"LidInner"+$i+"Aim"+$side) transform;
			parent ($upperLower+"LidInner"+$i+"Aim"+$side) ("LidSetup"+$side);
			setAttr -type float3 ($upperLower+"LidInner"+$i+"Aim"+$side+".t") 0 0 0;
			aimConstraint -worldUpType objectrotation -worldUpObject $headJoint -worldUpVector 1 0 0 ($upperLower+"LidLoc"+$i+$side) ($upperLower+"LidInner"+$i+"Aim"+$side);
			select -cl;
			joint -n ($upperLower+"LidInner"+$i+$side);
			$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+($i-1)+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidInner"+$i+$side);
			parent ($upperLower+"LidInner"+$i+$side) ($upperLower+"LidInner"+$i+"Aim"+$side);
			}
	
		if ($upperLower=="upper")
			duplicate -n ("closedLidCurve2"+$side) ("upperLidCurve2"+$side);
		if ($upperLower=="lower")
			{
			select -r ("upperLidCurve2"+$side) ("lowerLidCurve2"+$side) ("closedLidCurve2"+$side);
			blendShape -n ("closedLidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;
			connectAttr ("LidSetup.blinkCenter"+$side) ("closedLidCurveCloseBS"+$side+".upperLidCurve2"+$side);
			connectAttr ("blinkCenterReverse"+$side+".outputX") ("closedLidCurveCloseBS"+$side+".lowerLidCurve2"+$side);
			}
		duplicate -n ($upperLower+"LidCurveClose"+$side) ($upperLower+"LidCurve2"+$side);
		select -r ($upperLower+"LidCurve2"+$side) ("closedLidCurve2"+$side) ($upperLower+"LidCurveClose"+$side);
		blendShape -n ($upperLower+"LidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;

		createNode -n ($upperLower+"CloseLidCurveMixer"+$side) plusMinusAverage;
		connectAttr ("LidSetup.blink"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[0]");
		connectAttr ("LidSetup."+$upperLower+"Lid"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[1]");
		connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"LidCurveCloseBS"+$side+".closedLidCurve2"+$side);

		createNode -n ($upperLower+"blinkReverse"+$side) reverse;
		connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"blinkReverse"+$side+".inputX");
		connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"LidCurveCloseBS"+$side+"."+$upperLower+"LidCurve2"+$side);

//		connectAttr ("blinkReverse"+$side+".outputX") ($upperLower+"LidCurveCloseBS"+$side+"."+$upperLower+"LidCurve2"+$side);

		//wireDeform in WorldSpace, since wireDefomer does not work well with 180 rotation, and extreme scaling.
		createNode -n ("LidWireWS"+$side) -p ("LidCurves"+$side) transform;
		parentConstraint $headJoint ("LidWireWS"+$side);
		scaleConstraint $headJoint ("LidWireWS"+$side);
		duplicate -n ($upperLower+"LidCurve1OS"+$side) ($upperLower+"LidCurve1"+$side);
		parent ($upperLower+"LidCurve1"+$side) ("LidWireWS"+$side);
		wire -n ($upperLower+"LidCurveWire"+$side) -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ($upperLower+"LidCurveClose"+$side) ($upperLower+"LidCurve1OS"+$side);
		connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"LidCurveWire"+$side+".scale[0]");
		setAttr ($upperLower+"LidCurveWire"+$side+".dropoffDistance[0]") 20;
		connectAttr ($upperLower+"LidCurve1OS"+$side+"Shape.create") ($upperLower+"LidCurve1"+$side+"Shape.create");

		if ($b==1 && $upperLowerFactor==1)
			connectAttr -f tempNearestPointOnCurve.position tempLoc.translate;
		connectAttr -f ($upperLower+"LidCurve1"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;

		if ($upperLower=="upper")
			{
			asPingPong ("upperLidCurve2"+$side+".ep[0]") "LidCorner1" 1 $side 7 1 0;
			asPingPong ("upperLidCurve2"+$side+".ep[2]") "LidCorner2" 1 $side 7 1 0;
			}

		//$upperLower (1)
		$pos=`xform -q -ws -t ($upperLower+"LidCurve2"+$side+".ep[1]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		$closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid1") 1 $side 7 1 0;

		//$upperLower (2)
		$pos=`xform -q -ws -t ($upperLower+"LidCurveClose"+$side+".cv[1]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		$closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid2") 1 $side 10 1 0;
		setAttr -type float3 ($upperLower+"Lid2"+$side+".s") 0.5 0.5 0.5;
		makeIdentity -a 1 -t 0 -r 0 -s 1 ($upperLower+"Lid2"+$side);
		asFaceAddIn {($upperLower+"Lid1Joint"+$side),("LidCorner1Joint"+$side)} ($upperLower+"Lid2Joint"+$side) 1;
//		setAttr ($upperLower+"Lid2Joint"+$side+"AddIn_parentConstraint1."+$upperLower+"Lid1Joint"+$side+"W0") 3;

		//$upperLower (3)
		$pos=`xform -q -ws -t ($upperLower+"LidCurveClose"+$side+".cv[3]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		$closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid3") 1 $side 10 1 0;
		setAttr -type float3 ($upperLower+"Lid3"+$side+".s") 0.5 0.5 0.5;
		makeIdentity -a 1 -t 0 -r 0 -s 1 ($upperLower+"Lid3"+$side);
		asFaceAddIn {($upperLower+"Lid1Joint"+$side),("LidCorner2Joint"+$side)} ($upperLower+"Lid3Joint"+$side) 1;
//		setAttr ($upperLower+"Lid3Joint"+$side+"AddIn_parentConstraint1."+$upperLower+"Lid1Joint"+$side+"W0") 3;
		connectAttr ("LidCorner2Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[4]");
		connectAttr ($upperLower+"Lid3Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[3]");
		connectAttr ($upperLower+"Lid1Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[2]");
		connectAttr ($upperLower+"Lid2Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[1]");
		connectAttr ("LidCorner1Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[0]");

		//now after binding the curve, we can parent the joints
		if ($upperLower=="upper")
			parent ("LidCorner1JointOffset"+$side) ("LidCorner2JointOffset"+$side) LidJoints;
		parent ($upperLower+"Lid1JointOffset"+$side) ($upperLower+"Lid2JointOffset"+$side) ($upperLower+"Lid3JointOffset"+$side) LidJoints;


		// LidControlFollow
		createNode -n ($upperLower+"Lid1JointFollow"+$side) transform;
		$pos=`xform -q -ws -t ($upperLower+"Lid1Joint"+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid1JointFollow"+$side);
		$tempString=`listRelatives -p ($upperLower+"Lid1Joint"+$side)`;
		parent ($upperLower+"Lid1JointFollow"+$side) $tempString[0];
		duplicate -n ($upperLower+"Lid1JointFollowBlended"+$side) ($upperLower+"Lid1JointFollow"+$side);
		createNode -n ($upperLower+"Lid1JointFollowLidRot"+$side) transform;
		parent ($upperLower+"Lid1JointFollowLidRot"+$side) $tempString[0];
		$pos=`xform -q -ws -t $eyeJoint`;
		$rot=`xform -q -ws -ro $eyeJoint`;
		asAlign ($upperLower+"Lid1JointFollowLidRot"+$side) $eyeJoint 1 1 0 1;
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ($upperLower+"Lid1JointFollowLidRot"+$side);
//		if ($side=="_L")
//			rotate -r -os 0 -180 0 ($upperLower+"Lid1JointFollowLidRot"+$side);
//		setAttr ($upperLower+"Lid1JointFollowLidRot"+$side+".rotateOrder") `getAttr ($eyeJoint+".rotateOrder")`;
		duplicate -n ($upperLower+"Lid1JointFollowLidRotOffset"+$side) ($upperLower+"Lid1JointFollowLidRot"+$side);
		parent ($upperLower+"Lid1JointFollowLidRot"+$side) ($upperLower+"Lid1JointFollowLidRotOffset"+$side);
		parentConstraint -mo ($upperLower+"Lid1JointFollowLidRot"+$side) ($upperLower+"Lid1JointFollow"+$side);
		connectAttr ($eyeJoint+".rx") ($upperLower+"Lid1JointFollowLidRot"+$side+".rx");
		connectAttr ($eyeJoint+".ry") ($upperLower+"Lid1JointFollowLidRot"+$side+".ry");
		connectAttr ($eyeJoint+".rz") ($upperLower+"Lid1JointFollowLidRot"+$side+".rz");
//		parentConstraint -mo $eyeJoint ($upperLower+"Lid1JointFollow"+$side);
		createNode -n ($upperLower+"LidFollowMultiply"+$side) multiplyDivide;
		connectAttr ($upperLower+"Lid1JointFollow"+$side+".t") ($upperLower+"LidFollowMultiply"+$side+".input1");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2X");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2Y");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2Z");
		connectAttr ($upperLower+"LidFollowMultiply"+$side+".output") ($upperLower+"Lid1JointFollowBlended"+$side+".t");
		asFaceAddIn {($upperLower+"Lid1JointFollowBlended"+$side)} ($upperLower+"Lid1Joint"+$side) 1;
		}
	}

//ctrlLid attributes
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if (!`attributeExists blink ("ctrlEye"+$side)`)
		addAttr -ln "blink"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkCenter ("ctrlEye"+$side)`)
		addAttr -ln "blinkCenter" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLid ("ctrlEye"+$side)`)
		addAttr -ln "upperLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLid ("ctrlEye"+$side)`)
		addAttr -ln "lowerLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLidFollow ("ctrlEye"+$side)`)
		addAttr -ln "upperLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidFollow ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);

	if (`objExists LidSetup`)
		{
		asFaceBsSdk ("ctrlEye"+$side+".blink") 10 ("LidSetup.blink"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".blink") -10 ("LidSetup.blink"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".blinkCenter") 10 ("LidSetup.blinkCenter"+$side) 1;
		setAttr ("ctrlEye"+$side+".blinkCenter") 0.2;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") 10 ("LidSetup.upperLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") -10 ("LidSetup.upperLid"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") 10 ("LidSetup.lowerLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") -10 ("LidSetup.lowerLid"+$side) -1;
		setAttr ("LidSetup.upperLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidFollow") 10 ("LidSetup.upperLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".upperLidFollow") 10;
		setAttr ("LidSetup.lowerLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidFollow") 10 ("LidSetup.lowerLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".lowerLidFollow") 3;
		}
	connectAttr ("ctrlEye"+$side+".sx") ("LidSetup"+$side+".sz");
	connectAttr ("ctrlEye"+$side+".sy") ("LidSetup"+$side+".sy");
	connectAttr ("ctrlEye"+$side+".sz") ("LidSetup"+$side+".sx");
	}

//EyeLidSkinCage
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	loft -n ($upperLower+"tempLoft_R") -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true ($upperLower+"EyeLidMainCurve1_R") ($upperLower+"EyeLidOuterCurve1_R");
	nurbsToPoly -n ($upperLower+"EyeLidSkinCage_R") -mnd 1 -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($upperLower+"tempLoft_R");
	delete ($upperLower+"tempLoft_R");
	}

//polyUnite upperLower
polyUnite -ch 0 -mergeUVSets 1 -name ("EyeLidSkinCage_R") ("upperEyeLidSkinCage_R") ("lowerEyeLidSkinCage_R");
polyMergeVertex -d 0.0001 -am 1 -ch 0 ("EyeLidSkinCage_R");

//Weighting Lid
sets -em -n eyeLidVtxs;
if (`objExists "Sets"`)
	sets -add "Sets" eyeLidVtxs;
progressBar -e -st ("Setup EyeLid") -bp -ii 0 -min 0 -max (2*$numLid) $gMainProgressBar;

select faceLid;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$numLid=$numLidUpper;}
	else {$upperLower="lower";$numLid=$numLidLower;}

	for ($i=1;$i<($numLid+1);$i++)
		select -add ($upperLower+"LidInner"+$i+"_R");
	}
select -d ("lowerLidInner"+"1_R") ("lowerLidInner"+$numLidLower+"_R");//not include first/last lower joints, avoid overlap
select -add ("EyeLidSkinCage_R");
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] ("KidSC_R");
$tempInts=`polyEvaluate -v ("EyeLidSkinCage_R")`;
for ($i=0;$i<$tempInts[0];$i++)
	{
	$tempString=`skinPercent -ignoreBelow 0.001 -q -t ("KidSC_R") ("EyeLidSkinCage_R.vtx["+$i+"]")`;
	if (size($tempString)>1)
		skinPercent -tv faceLid 1 ("KidSC_R") ("EyeLidSkinCage_R.vtx["+$i+"]");
	}
//find vtx within sphere volume (to copy weights to)
polySphere -n tempVolumeSphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
delete `pointConstraint LidCorner1Joint_R LidCorner2Joint_R tempVolumeSphere`;
$posA=`xform -q -ws -t tempVolumeSphere`;
float $longestDist=0;
for ($i=0;$i<7;$i++)
	{
	$posB=`xform -q -ws -t ("upperEyeLidOuterCurve.cv["+$i+"]")`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist>$longestDist)
		$longestDist=$dist;
	}
setAttr -type float3 tempVolumeSphere.s $longestDist $longestDist $longestDist;
makeIdentity -a 1 -t 1 -r 1 -s 1 tempVolumeSphere;
selectVtxsInsideGeo $geometry tempVolumeSphere;
$insideVtxs=`ls -sl -fl`;
delete tempVolumeSphere;

//update $insideVtxs to a probably more accurate selection, if used guide-edges
if (`attributeExists selection FaceFitEyeLidMain`)
	{
	asCreateSamplerMesh $geometry;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr samplerMesh.outMesh closestSampler.inMesh;
	$posA=`xform -q -ws -t upperEyeLidMainCurve.ep[2]`;
	$posB=`xform -q -ws -t upperEyeLidOuterCurve.ep[2]`;
	setAttr -type float3 closestSampler.inPosition (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0);
	select ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
	for ($i=0;$i<30;$i++)
		{
		refresh;
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $selectionMainVtxsAll $selectionOuterVtxsAll;
		}
	select -add $selectionMainVtxsAll $selectionOuterVtxsAll;
	$insideVtxs=`ls -sl -fl`;
	string $mirroredInsideVtxs[];
	delete samplerMesh closestSampler;
	}

//Xfer weights to face
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";$numLid=$numLidUpper;}
		else {$upperLower="lower";$numLid=$numLidLower;}
	
		for ($i=1;$i<($numLid+1);$i++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			skinCluster -e -ai ($upperLower+"LidInner"+$i+$side) -lw false -wt 0 $skinCluster;
			}
		}
	}
select ("EyeLidSkinCage_R.vtx[0:999]") $insideVtxs;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//update eyeLidVtxs-set
for ($i=0;$i<size($insideVtxs);$i++)
	{
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $insideVtxs[$i]`;
	for ($y=0;$y<size($infs);$y++)
		if (`gmatch $infs[$y] "*Lid*"`)
			sets -add eyeLidVtxs $insideVtxs[$i];
	}

//InnerExtra weight
int $numExtra=`getAttr FaceFitEyeLidMain.numExtra`;
select $selectionMainVtxsAll;
$tempString=`ls -sl -fl`;
for ($y=0;$y<$numExtra;$y++)
	{
	clear $tempString3;
	for ($i=0;$i<size($tempString);$i++)
		{
		select $tempString[$i];
		for ($z=0;$z<$y+1;$z++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d `sets -q eyeLidVtxs`;
			$tempString2=`ls -sl -fl`;
			$tempString3=`stringArrayCatenate $tempString3 $tempString2`;
			}
		}
	for ($i=0;$i<size($tempString);$i++)
		{
		$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $tempString[$i]`;
		select $tempString[$i];
		for ($z=0;$z<$y+1;$z++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d `sets -q eyeLidVtxs`;
			}
		$tempString2=`ls -sl -fl`;
		for ($a=0;$a<size($tempString2);$a++)
			if (`stringArrayCount $tempString2[$a] $tempString3`==1)
				skinPercent -tv $infs[0] 1 $skinCluster $tempString2[$a];
		}
	}
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//hammer
if (`attributeExists selection FaceFitEyeLidMain`)
	{
	select eyeLidVtxs;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		if ($pos[0]>0)
			select -d $tempString[$i];
		}
	$tempString[0]=`getAttr FaceFitEyeLidMain.upperSelection`;
	eval ("select -d "+$tempString[0]);
	$tempString[0]=`getAttr FaceFitEyeLidMain.lowerSelection`;
	eval ("select -d "+$tempString[0]);
	weightHammerVerts;
	}
delete EyeLidSkinCage_R;
delete upperEyeLidMainCurve1_R upperEyeLidOuterCurve1_R lowerEyeLidMainCurve1_R lowerEyeLidOuterCurve1_R;
delete upperEyeLidMainCurve1_L upperEyeLidOuterCurve1_L lowerEyeLidMainCurve1_L lowerEyeLidOuterCurve1_L;
}

global proc asAdvancedEyeBrowPartA ()
{
global string $gMainProgressBar;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint,$vtx;
string $tempString[],$tempString2[],$tempString3[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;

//create curves around forhead region
$curveCmd="curve -d 3 ";
for ($i=0;$i<7;$i++)
	{
	$pos=`xform -q -ws -t ("EyeBrowOuter"+$i)`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve1;

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t EyeBrowOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;delete `pointConstraint EyeBrowOuter6 EyeLidOuter6 tempGeoSnapLoc`;
geometryConstraint $geometry tempGeoSnapLoc;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$pos=`xform -q -ws -t EyeLidOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeLidMain6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve2;

duplicate -n foreHeadBorderCurve3 upperEyeLidMainCurve;
parent -w foreHeadBorderCurve3;
$tempString=`listRelatives -s foreHeadBorderCurve3`;
rename $tempString[0] "foreHeadBorderCurveShape3";
reverseCurve -ch 0 -rpo 1 "foreHeadBorderCurve3";

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t EyeLidMain0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeLidOuter0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $pos[1] $pos[2] tempGeoSnapLoc;
if (`objExists Nose0`)
	{
	$posA=`xform -q -ws -t tempGeoSnapLoc`;
	$posB=`xform -q -ws -t Nose0`;
	xform -ws -t 0 $posA[1] $posB[2] tempGeoSnapLoc;
	}
geometryConstraint $geometry tempGeoSnapLoc;
for($i=0;$i<20;$i++) setAttr tempGeoSnapLoc.tx 0;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve4;

select -r foreHeadBorderCurve1 foreHeadBorderCurve2 foreHeadBorderCurve3 foreHeadBorderCurve4 ;
}

global proc asAdvancedEyeBrowPartB ()
{
global string $gMainProgressBar;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint,$vtx;
string $tempString[],$tempString2[],$tempString3[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;

string $deleteObjs[]={"foreheadGeo","foreHeadVtxs","foreHeadBorderVtxs"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;

//select vtx`s from forehead region curves
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempPointOnCurveInfo.position tempLoc.t;

asCreateSamplerMesh $geometry;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr -f tempLoc.worldPosition closestSampler.inPosition;

select -cl;
string $borderVtxs[];
//progressBar -e -st ("Setup EyeBrow") -bp -ii 0 -min 0 -max (98*2*4) $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	setAttr tempLocFlip.sx $b;
	for ($a=1;$a<5;$a++)
		{
		connectAttr -f ("foreHeadBorderCurveShape"+$a+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		for ($i=0;$i<99;$i++)
			{
//			progressBar -e -s 1 $gMainProgressBar;
			setAttr tempPointOnCurveInfo.parameter ($i*0.01);
			refresh;
			$vtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
			if (!`stringArrayCount $vtx $borderVtxs`)
				{
				$borderVtxs[size($borderVtxs)]=$vtx;
				select -add $vtx;
				}
			}
		}
	}
//ensure complete loop
select $borderVtxs;
asEnsureSelectionCompleteLoop;
$borderVtxs=`ls -sl -fl`;
sets -n foreHeadBorderVtxs;
if (`objExists "Sets"`)
	sets -add "Sets" foreHeadBorderVtxs;

//Find centerForHead vtx to grow from
$posA=`xform -q -ws -t foreHeadBorderCurve1.cv[0]`;
$posB=`xform -q -ws -t foreHeadBorderCurve4.cv[2]`;
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) tempGeoSnapLoc;
setAttr -l 1 tempGeoSnapLoc.tx;delete `geometryConstraint $geometry tempGeoSnapLoc`;
setAttr -l 0 tempGeoSnapLoc.tx;setAttr tempGeoSnapLoc.tx 0;
connectAttr -f tempGeoSnapLoc.worldPosition closestSampler.inPosition;
string $foreheadStartVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete tempGeoSnapLoc tempPointOnCurveInfo samplerMesh closestSampler;

//grow until forehead region, to create separate forhead object;
select $foreheadStartVtx;
for ($i=0;$i<30;$i++)
{
ConvertSelectionToEdges;
ConvertSelectionToVertices;
select -d `sets -q foreHeadBorderVtxs`;
}
select -add $borderVtxs;
sets -n foreHeadVtxs;
if (`objExists "Sets"`)
	sets -add "Sets" foreHeadVtxs;
select -d $borderVtxs;
ConvertSelectionToFaces;
string $forheadFaces[]=`ls -sl`;

duplicate -n foreheadGeo $geometry;
asLockAttr foreheadGeo 0 0 0 0;
$tempString=`listRelatives -p foreheadGeo`;
if (size($tempString))
	parent -w foreheadGeo;
$tempString=`listRelatives -s foreheadGeo`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
select foreheadGeo.f[0:99999];
for ($i=0;$i<size($forheadFaces);$i++)
	select -d (`substitute $geometry $forheadFaces[$i] foreheadGeo`);
delete;

if (`objExists foreheadGeo`)
	setAttr foreheadGeo.v 1;
select -r foreHeadBorderCurve1 foreHeadBorderCurve2 foreHeadBorderCurve3 foreHeadBorderCurve4 ;

if (`objExists "Group"`) setAttr "Group.v" 1;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
}

global proc asAdvancedEyeBrowPartC ()
{
global string $gMainProgressBar;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint,$vtx;
string $tempString[],$tempString2[],$tempString3[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $borderVtxs[]=`sets -q foreHeadBorderVtxs`;

//ncloth
select foreheadGeo;
$tempString=`createNCloth 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] foreheadNCloth;
setAttr foreheadNCloth.ignoreSolverGravity 1;
setAttr foreheadNCloth.damp 10;
setAttr foreheadNCloth.stretchResistance 0;
setAttr foreheadNClothShape.selfCollide 0;
setAttr foreheadNCloth.selfCollisionFlag 4;
setAttr foreheadNCloth.stretchResistance 5;
setAttr foreheadNCloth.compressionResistance 3;
setAttr foreheadNCloth.bendResistance 3;

select -r foreheadGeo.vtx[0:9999];
refresh;
//someTimes polySelectConstraint -pp 3 fails, ensuring -t seem to fix
polySelectConstraint -t 1 -pp 3;
$tempString=`createNConstraint transform 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] tempNClothConstraint1;

$curveCmd="curve -d 3 ";
$pos=`xform -q -ws -t EyeBrowOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];

spaceLocator -n tempGeoSnapLoc;delete `pointConstraint EyeBrowOuter6 EyeBrowMain6 tempGeoSnapLoc`;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;

$pos=`xform -q -ws -t EyeBrowMain6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain5`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain4`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain3`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain2`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain1`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $pos[1] $pos[2] tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
for($i=0;$i<20;$i++) setAttr tempGeoSnapLoc.tx 0;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$pos=`xform -q -ws -t EyeBrowMain0`;$curveCmd+=" -p "+($pos[0]*-1)+" "+$pos[1]+" "+$pos[2];

$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] EyeBrowMainCurve2;
connectAttr EyeBrowMainCurve.controlPoints[0] EyeBrowMainCurve2.cv[8];
connectAttr EyeBrowMainCurve.controlPoints[1] EyeBrowMainCurve2.cv[7];
connectAttr EyeBrowMainCurve.controlPoints[2] EyeBrowMainCurve2.cv[6];
connectAttr EyeBrowMainCurve.controlPoints[3] EyeBrowMainCurve2.cv[5];
connectAttr EyeBrowMainCurve.controlPoints[4] EyeBrowMainCurve2.cv[4];
connectAttr EyeBrowMainCurve.controlPoints[5] EyeBrowMainCurve2.cv[3];
connectAttr EyeBrowMainCurve.controlPoints[6] EyeBrowMainCurve2.cv[2];
circle -n EyeBrowCircle -c 0 0 0 -nr 1 0 0 -sw 360 -r ($scale/100.0) -d 3 -ut 0 -tol 0.00393701 -s 8 -ch 1;
extrude -n EyeBrowExtrude -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1 EyeBrowCircle EyeBrowMainCurve2;
nurbsToPoly -n EyeBrowMainPoly -mnd 1  -ch 1 -f 2 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 2 -un 20 -vt 2 -vn 256 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 EyeBrowExtrude;

nurbsToPoly -n eyeBrowPoly -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 8 -vt 1 -vn 8 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 EyeBrowCylinderMain;
select -r foreheadGeo EyeBrowMainPoly;
//select -r foreheadGeo eyeBrowPoly;
$tempString=`createNConstraint pointToPoint 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] tempNClothRigid1;
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] tempNClothConstraint2;

setAttr tempNClothConstraintShape2.constraintMethod 2;
setAttr tempNClothConstraintShape2.connectionMethod 1;
$posA=`xform -q -ws -t EyeBrowCylinderMain.cv[2][1]`;
$posB=`xform -q -ws -t EyeBrowCylinderMain.cv[2][5]`;
//float $posA[]=`xform -q -ws -t EyeBrowCylinderMain.cv[2][1]`;
//float $posB[]=`xform -q -ws -t EyeBrowCylinderMain.cv[2][5]`;
float $browWidth=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
setAttr tempNClothConstraintShape2.maxDistance ($browWidth/2.0);
duplicate -n foreheadGeoSlideOn foreheadGeo;
setAttr foreheadGeoSlideOn.v 0;
select -r foreheadGeo.vtx[0:655] ;
select -add foreheadGeoSlideOn;
$tempString=`createNConstraint slideOnSurface 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] tempNRigid;
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] tempdynamicConstraint;
setAttr tempdynamicConstraintShape.collideWidthScale 0;

//Find nearby vtx and remove these from the slideConstraint, to have smoother the main eyeBrow part
select -r foreheadGeo;
string $nearBrowVtxs[];
for ($i=0;$i<56;$i++)
	{
	$pos=`xform -q -ws -t eyeBrowPoly.vtx[$i]`;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 $browWidth -dp $pos[0] $pos[1] $pos[2];
	select -add $nearBrowVtxs;
	$nearBrowVtxs=`ls -sl`;
	}
polySelectConstraint -m 0;
select $nearBrowVtxs;
select -add tempdynamicConstraint;
dynamicConstraintMembership "remove";

if (`objExists tempNearestPointOnCurve`)
	delete tempNearestPointOnCurve;
currentTime -1;
select -cl;
}

global proc asAdvancedJaw ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
float $scale=`asFaceGetScale`;
string $tempString[];

//Existing Jaw ?
if (`objExists Jaw_M`)
	error "Jaw_M already exists, can not build new Jaw, remove old jaw first";

createNode -n JawSetup -p FaceMotionSystem transform;
createNode -n JawSetupFollowHead -p JawSetup transform;
parentConstraint $headJoint JawSetupFollowHead;
scaleConstraint $headJoint JawSetupFollowHead;

createNode -n JawUpVectorOffset -p JawSetup transform;
parentConstraint $headJoint JawUpVectorOffset;
createNode -n JawUpVector transform;
parent JawUpVector JawUpVectorOffset;
setAttr -type float3 JawUpVector.t 0 0 0;

select -cl;
float $pos[]=`xform -q -ws -t JawOuterCurve.cv[6]`;
joint -n Jaw_M;
xform -ws -t 0 $pos[1] $pos[2] Jaw_M;
delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject JawUpVector JawMain0 Jaw_M`;
select -cl;
joint -n TeethUpper_M;
parent Jaw_M TeethUpper_M FaceAttachToHead;
//setAttr TeethUpper_M.ty ($scale*0.2);
makeIdentity -a 1 -t 0 -r 1 -s 0 Jaw_M;

select -cl;
joint -n TeethLower_M;
parent TeethLower_M Jaw_M;
//setAttr TeethLower_M.ty ($scale*-0.2);
string $curve=`curve -d 1 -p -3 0 0 -p -1 0 -1 -p 0 0 -3 -p 1 0 -1 -p 3 0 0 -p 1 0 1 -p 0 0 3 -p -1 0 1 -p -3 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8`;
rename $curve FKTeethTemplate;
sets -add FaceControlSet FKTeethTemplate;
setAttr FKTeethTemplateShape.overrideEnabled 1;
setAttr FKTeethTemplateShape.overrideColor 17;
setAttr -type float3 FKTeethTemplate.s ($scale/86.0) ($scale/36.0) ($scale/250.0);
rotate -r -os 90 0 0 FKTeethTemplate;
makeIdentity -a 1 -t 0 -r 1 -s 1 FKTeethTemplate;

string $upperLower,$upperLowerTeeth,$teethUpperLowerM;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerTeeth=$upperTeeth;$teethUpperLowerM="TeethUpper_M";}
	else {$upperLower="lower";$upperLowerTeeth=$lowerTeeth;$teethUpperLowerM="TeethLower_M";}

	if ($upperLowerTeeth!="")
		{
		eval ("select "+$upperLowerTeeth);
		$tempString=`ls -sl -o`;
		if (size($tempString)>1)
			select $tempString[0];
		float $bb[]=`xform -q -bb`;
		xform -ws -t (($bb[0]+$bb[3])/2.0) (($bb[1]+$bb[4])/2.0) (($bb[2]+$bb[5])/2.0) $teethUpperLowerM;
		duplicate -n ("FK"+$teethUpperLowerM) FKTeethTemplate;
		asAlign ("FK"+$teethUpperLowerM) $teethUpperLowerM 1 1 0 0;
		createNode -n ("FKOffset"+$teethUpperLowerM) transform;
		asAlign ("FKOffset"+$teethUpperLowerM) ("FK"+$teethUpperLowerM) 1 1 0 0;
		parent ("FK"+$teethUpperLowerM) ("FKOffset"+$teethUpperLowerM);
		parent ("FKOffset"+$teethUpperLowerM) JawSetupFollowHead;
		parentConstraint ("FK"+$teethUpperLowerM) $teethUpperLowerM;
		scaleConstraint ("FK"+$teethUpperLowerM) $teethUpperLowerM;
		move -r ($scale*0.33) 0 0 ("FK"+$teethUpperLowerM+".cv[0:8]");
		}
	}
delete FKTeethTemplate;

select Jaw_M;
joint -n JawEnd_M;
float $pos2[]=`xform -q -ws -t JawMain0`;
xform -ws -t $pos2[0] $pos2[1] $pos2[2] JawEnd_M;
setAttr Jaw_M.segmentScaleCompensate 0;
setAttr TeethUpper_M.segmentScaleCompensate 0;
setAttr TeethLower_M.segmentScaleCompensate 0;

$curve=`curve -d 1 -p -3 0 0 -p -1 0 -1 -p 0 0 -3 -p 1 0 -1 -p 3 0 0 -p 1 0 1 -p 0 0 3 -p -1 0 1 -p -3 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8`;
rename $curve FKJaw_M;
sets -add FaceControlSet FKJaw_M;
setAttr FKJaw_MShape.overrideEnabled 1;
setAttr FKJaw_MShape.overrideColor 17;
//setAttr FKJaw_M.rx -90;
setAttr -type float3 FKJaw_M.s ($scale/18.0) ($scale/18.0) ($scale/36.0);
makeIdentity -a 1 -t 0 -r 0 -s 1 FKJaw_M;
createNode -n FKOffsetJaw_M transform;
createNode -n FKSDK1Jaw_M -p FKOffsetJaw_M transform;
createNode -n FKSDK2Jaw_M -p FKSDK1Jaw_M transform;
parent FKOffsetJaw_M JawSetupFollowHead;
parent FKJaw_M FKSDK2Jaw_M;
asAlign FKOffsetJaw_M Jaw_M 1 1 0 0;
parentConstraint FKJaw_M Jaw_M;
scaleConstraint FKJaw_M Jaw_M;
$pos=`xform -q -ws -t Jaw_M`;
move -r ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]) FKJaw_M.cv[0:8];
rotate -r -p $pos2[0] $pos2[1] $pos2[2] -os 0 90 90 FKJaw_M.cv[0:8];
if ($lowerTeeth!="")
	parent FKOffsetTeethLower_M FKJaw_M;

select -r FKJaw_M ;
}

global proc asAdvancedCheekPartA ()
{
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower;
string $tempString[],$tempString2[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;

if (`objExists mouthGeo`)
	delete mouthGeo;

select jawArea;
ConvertSelectionToFaces;
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $mouthAreFaces[]=`ls -sl`;
duplicate -n mouthGeo $geometry;
asLockAttr mouthGeo 0 0 0 0;
setAttr mouthGeo.v 1;
$tempString=`ls -l mouthGeo`;
if (`gmatch $tempString[0] "*?|*"`)
	parent -w mouthGeo;
$tempString=`listRelatives -s mouthGeo`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
$tempString=`listRelatives -s mouthGeo`;
if ($tempString[0]!="mouthGeoShape")
	rename $tempString[0] "mouthGeoShape";
sets -remove grownUpLipVtxs mouthGeoShape.vtx[0:9999];
sets -remove grownUpLipVtxsInverse mouthGeoShape.vtx[0:9999];
select mouthGeo.f[0:99999];
for ($i=0;$i<size($mouthAreFaces);$i++)
	select -d (`substitute $geometry $mouthAreFaces[$i] mouthGeo`);
delete;

if (`objExists "Group"`) setAttr "Group.v" 0;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
select -r mouthGeo ;
}

global proc asAdvancedCheekPartB ()
{
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower;
string $tempString[],$tempString2[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;

createNode -n lipGeometry transform;
setAttr lipGeometry.v 0;
int $loop1VtxNrs[]={0,3,7,11,17,37,40,46,128,131,134,140,160,163,168};
int $loop2VtxNrs[]={12,13,16,18,39,41,45,47,133,135,139,141,162,164,169};
int $loop3VtxNrs[]={14,15,20,21,43,44,49,50,137,138,143,144,166,167,171};
int $loop4VtxNrs[]={8,9,10,19,36,38,42,48,130,132,136,142,161,165,170};
int $loop5VtxNrs[]={25,26,28,29,54,55,61,62,148,149,155,156,175,176,181};
int $loop6VtxNrs[]={22,23,24,27,52,53,59,60,146,147,153,154,173,174,180};
int $loop7VtxNrs[]={31,32,34,35,57,58,64,65,151,152,158,159,178,179,183};
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		if ($side=="_R")
			{
			nurbsToPoly -n ($upperLower+"LipCylinderPoly_R") -mnd 1 -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 16 -vt 1 -vn 16 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($upperLower+"LipCylinder");
			parent ($upperLower+"LipCylinderPoly"+$side) lipGeometry;
			}
		else
			{
			duplicate -n ($upperLower+"LipCylinderPoly_L") ($upperLower+"LipCylinderPoly_R");
			setAttr ($upperLower+"LipCylinderPoly_L.sx") -1;
			connectAttr ($upperLower+"LipCylinderPoly_R.outMesh") ($upperLower+"LipCylinderPoly_L.inMesh");
			}
		
		duplicate -n ($upperLower+"LipCylinderPolyBS"+$side) ($upperLower+"LipCylinderPoly"+$side);
		select ($upperLower+"LipCylinderPoly"+$side) ($upperLower+"LipCylinderPolyBS"+$side);
		blendShape -n ($upperLower+"LipBS"+$side) -frontOfChain -w 0 1;
		blendShape -e  -t ($upperLower+"LipCylinderPolyBS"+$side) 1 ($upperLower+"LipCylinderPoly"+$side) 1 ($upperLower+"LipCylinderPolyBS"+$side);

		if ($side=="_L")
			for ($i=0;$i<240;$i++)
				setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$i+"]") 0;

		for ($i=0;$i<size($loop1VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop1VtxNrs[$i]+"]") 0.5;
		for ($i=0;$i<size($loop2VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop2VtxNrs[$i]+"]") `abs($b-0.49)`;
		for ($i=0;$i<size($loop3VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop3VtxNrs[$i]+"]") `abs($b-0.35)`;
		for ($i=0;$i<size($loop4VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop4VtxNrs[$i]+"]") `abs($b-0.2)`;
		for ($i=0;$i<size($loop5VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop5VtxNrs[$i]+"]") `abs($b-0.1)`;
		}
	}

select mouthGeo;
$tempString=`createNCloth 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] mouthNCloth;
setAttr mouthNCloth.ignoreSolverGravity 1;
setAttr mouthNCloth.damp 10;
setAttr mouthNCloth.stretchResistance 0;
setAttr mouthNCloth.selfCollide 0;
setAttr mouthNCloth.selfCollisionFlag 4;
setAttr mouthNCloth.stretchResistance 5;
setAttr mouthNCloth.compressionResistance 3;
setAttr mouthNCloth.bendResistance 3;
setAttr mouthNCloth.selfCollide 0;

select -r mouthGeo.vtx[0:9999];

refresh;
//someTimes polySelectConstraint -pp 3 fails, ensuring -t seem to fix
polySelectConstraint -t 1 -pp 3;
$borderVtxs=`ls -sl`;
$tempString=`createNConstraint transform 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] tempNClothConstraint1;

//find $grownUpLipVtxsOnMouthGeo & $grownUpLipVtxsInverseOnMouthGeo
string $grownUpLipVtxsOnMouthGeo[];
asCreateSamplerMesh mouthGeo;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
select `sets -q grownUpLipVtxs`;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$grownUpLipVtxsOnMouthGeo[$i]="mouthGeo.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	}
delete samplerMesh closestSampler;
select $grownUpLipVtxsOnMouthGeo;
InvertSelection;
string $grownUpLipVtxsInverseOnMouthGeo[]=`ls -sl`;

//constraint to lipGeo
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
	
		select -r mouthGeo ($upperLower+"LipCylinderPolyBS"+$side);
		$tempString=`createNConstraint pointToPoint 0`;
		$tempString2=`listRelatives -p $tempString[0]`;
		rename $tempString2[0] ($upperLower+"LipNClothRigid"+$side);
		$tempString2=`listRelatives -p $tempString[1]`;
		rename $tempString2[0] ($upperLower+"LipNClothConstraint"+$side);
	
		select ($upperLower+"LipNClothConstraint"+$side);
		select -add $borderVtxs;
		if ($upperLower=="upper")	select -add $grownUpLipVtxsInverseOnMouthGeo;
		if ($upperLower=="lower")	select -add $grownUpLipVtxsOnMouthGeo;
		dynamicConstraintMembership "remove";
		
		setAttr ($upperLower+"LipNClothConstraint"+$side+".constraintMethod") 2;
		setAttr ($upperLower+"LipNClothConstraint"+$side+".connectionMethod") 1;
		setAttr ($upperLower+"LipNClothConstraint"+$side+".maxDistance") ($scale*0.01);//using 1% of facescale as skinOffset
		}
	}

//constraint to JawCylinderMainPoly
asFaceClothConstraint JawCylinderMain ($scale*0.01);

//constraint to Nose
asFaceClothConstraint NoseCylinder ($scale*0.01);

//constraint to noseCorner
asFaceClothConstraint noseCornerSphere ($scale*0.01);

//constraint to lowerEyeLidCylinderPolyOuter_R
asFaceClothConstraint lowerEyeLidCylinderOuter ($scale*0.01);

//Cheek Puff & Suck forceFields
select -r mouthGeo;
$tempString=`createNConstraint force 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] CheekPuffDynamicConstraint;
select -r mouthGeo;
$tempString=`createNConstraint force 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] CheekSuckDynamicConstraint;
setAttr -type float3 CheekPuffDynamicConstraint.s ($scale*0.1) ($scale*0.1) ($scale*0.1);//using 10% of facescale as skinOffset
setAttr -type float3 CheekSuckDynamicConstraint.s ($scale*0.1) ($scale*0.1) ($scale*0.1);//using 10% of facescale as skinOffset
setAttr CheekPuffDynamicConstraintShape.force ($scale/1.5);
setAttr CheekSuckDynamicConstraintShape.force ($scale/1.5);

$pos=`xform -q -ws -t cheek`;
xform -ws -t ($pos[0]+($scale*0.02)) $pos[1] ($pos[2]-($scale*0.02)) CheekPuffDynamicConstraint;
xform -ws -t ($pos[0]-($scale*0.02)) $pos[1] ($pos[2]+($scale*0.02)) CheekSuckDynamicConstraint;
setKeyframe -v 0 -t 100 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 1 -t 101 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 1 -t 105 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 0 -t 106 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 0 -t 110 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 1 -t 111 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 1 -t 115 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 0 -t 116 CheekSuckDynamicConstraintShape.ena;

//Find LipVtxs
asWrapLipCylinders $scale;
string $lipArea[]=`ls -sl`;
delete tempWrap;
if (size($lipArea)==0)
	{
	//Trying again with scaled up objects, because wrap deformer does not work on small objects
	print ("// LipArea not detected, trying upscale x10 to get wrap-attachment\n");
	scale -r -p 0 0 0 10 10 10 mouthGeo.vtx[0:9999];
	setAttr -type float3 lipGeometry.s 10 10 10;
	asWrapLipCylinders ($scale*10);
	$lipArea=`ls -sl`;
	delete tempWrap;
	scale -r -p 0 0 0 0.1 0.1 0.1 mouthGeo.vtx[0:9999];
	setAttr -type float3 lipGeometry.s 1 1 1;
	if (size($lipArea)==0)
		error "Unable to determine the lipArea";
	}
createNode -n lipArea objectSet;
	if (`objExists "Sets"`)
		sets -add "Sets" lipArea;
sets -add lipArea $lipArea;
select $lipArea;
}

global proc asWrapLipCylinders (float $scale)
{
asSetFixedWrapOptions;
select -r mouthGeo upperLipCylinderPoly_R;CreateWrap;
select -r mouthGeo upperLipCylinderPoly_L;AddWrapInfluence;
select -r mouthGeo lowerLipCylinderPoly_R;AddWrapInfluence;
select -r mouthGeo lowerLipCylinderPoly_L;AddWrapInfluence;
$tempString=`listConnections mouthGeo.inMesh`;
rename $tempString[0] tempWrap;
setAttr tempWrap.autoWeightThreshold 0;
setAttr tempWrap.weightThreshold 0;
setAttr tempWrap.exclusiveBind 0;
setAttr tempWrap.maxDistance ($scale*0.01);
setAttr upperLipCylinderPoly_R.tz (100*$scale);setAttr upperLipCylinderPoly_L.tz (100*$scale);
setAttr lowerLipCylinderPoly_R.tz (100*$scale);setAttr lowerLipCylinderPoly_L.tz (100*$scale);
int $tempInts[]=`polyEvaluate -v mouthGeo`;
int $numVtx=$tempInts[0];
select -cl;
for ($i=0;$i<$numVtx;$i++)
	{
	$pos=`xform -q -ws -t ("mouthGeo.vtx["+$i+"]")`;
	if ($pos[2]>(50*$scale))
		select -add  ("mouthGeo.vtx["+$i+"]");
	}
setAttr upperLipCylinderPoly_R.tz 0;setAttr upperLipCylinderPoly_L.tz 0;
setAttr lowerLipCylinderPoly_R.tz 0;setAttr lowerLipCylinderPoly_L.tz 0;
}

global proc asAdvancedLip ()
{
//Lip PingPongs
float $posA[]=`xform -q -ws -t Lip6`;
float $posB[]=`xform -q -ws -t upperLip0`;
float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
if (!`attributeExists falloffRadius Lip6`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double Lip6;
if (!`attributeExists falloffMode Lip6`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 Lip6;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	softCluster Lip6 Lip6 $b $side;
	sets -e -forceElement asFaceGreenSG ("Lip6"+$side);
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	$posA=`xform -q -ws -t ($upperLower+"Lip0")`;
	$posB=`xform -q -ws -t Lip6`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if (!`attributeExists falloffRadius ($upperLower+"Lip0")`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double ($upperLower+"Lip0");
	if (!`attributeExists falloffMode ($upperLower+"Lip0")`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 ($upperLower+"Lip0");
	softCluster ($upperLower+"Lip0") ($upperLower+"Lip0") 1 "_M";
	sets -e -forceElement asFaceGreenSG ($upperLower+"Lip0_M");

	$posA=`xform -q -ws -t ($upperLower+"Lip3")`;
	$posB=`xform -q -ws -t Lip6`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if (!`attributeExists falloffRadius ($upperLower+"Lip3")`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double ($upperLower+"Lip3");
	if (!`attributeExists falloffMode ($upperLower+"Lip3")`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 ($upperLower+"Lip3");
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		softCluster ($upperLower+"Lip3") ($upperLower+"Lip3") $b $side;
		sets -e -forceElement asFaceBrownSG ($upperLower+"Lip3"+$side);
		}
	}
}

global proc asAdvancedTongue ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
if ($tongue=="")
	return;
float $scale=`asFaceGetScale`/3.0;
string $tongueSkinCluster="";
string $tempString[];

createNode -n TongueSetup -p FaceMotionSystem transform;

//Tongue setup
select -cl;
joint -n tempTongueJoint;
select -add TongueCurve;
pathAnimation -n motionPathTemp -fractionMode true -follow true -followAxis x -upAxis z -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject $headJoint -inverseUp false -inverseFront false -bank false -startTimeU `playbackOptions -query -minTime` -endTimeU  `playbackOptions -query -maxTime`;
delete `listConnections -scn 1 motionPathTemp.uValue`;
setAttr motionPathTemp.uValue 0;refresh;
duplicate -n faceRigTongue0_M tempTongueJoint;
setAttr motionPathTemp.uValue 0.5;refresh;
duplicate -n faceRigTongue1_M tempTongueJoint;
setAttr motionPathTemp.uValue 0.75;refresh;
duplicate -n faceRigTongue2_M tempTongueJoint;
setAttr motionPathTemp.uValue 0.9;refresh;
duplicate -n faceRigTongue3_M tempTongueJoint;
setAttr motionPathTemp.uValue 1;refresh;
duplicate -n faceRigTongue4_M tempTongueJoint;
delete tempTongueJoint;
select FaceAttachToHead;
for ($i=0;$i<5;$i++)
	{
	if ($i==0)
		parent faceRigTongue0_M FaceAttachToHead;
	else
		parent ("faceRigTongue"+$i+"_M") ("faceRigTongue"+($i-1)+"_M");
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("faceRigTongue"+$i+"_M");
	}
setAttr faceRigTongue0_M.overrideEnabled 0;
setAttr faceRigTongue0_M.segmentScaleCompensate 0;
if (`objExists FKJaw_M`)
	{
	parentConstraint -mo FKJaw_M faceRigTongue0_M;
	scaleConstraint FKJaw_M faceRigTongue0_M;
	}

//Polycube skin method
polyCube -n tempWeightCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 4 -ax 0 1 0 -cuv 4 -ch 1;
xform -s $scale $scale $scale tempWeightCube;

select -r tempWeightCube.vtx[10:13] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue0;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue0_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

select -r tempWeightCube.vtx[8:9] tempWeightCube.vtx[14:15] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue1;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue1_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

select -r tempWeightCube.vtx[6:7] tempWeightCube.vtx[16:17] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue2;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue2_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

select -r tempWeightCube.vtx[4:5] tempWeightCube.vtx[18:19] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue3;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue3_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

select -r tempWeightCube.vtx[0:3] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
parent $tempString[1] Tongue4;
xform -os -t 0 0 0 -ro 0 -90 0 -s 0.05 0.05 0.05 $tempString[1];
$pos=`xform -q -ws -t faceRigTongue4_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

duplicate -n tempWeightCube2 tempWeightCube;
select -r tempWeightCube2 faceRigTongue3_M faceRigTongue2_M faceRigTongue1_M faceRigTongue0_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] tongueBoxSC;
//	skinCluster -n tongueBoxSC -dr 4 -lw false -wt 1 -mi 1;
select -r tempWeightCube2.vtx[10:13] ;
skinPercent -tv faceRigTongue0_M 1 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[8:9] tempWeightCube2.vtx[14:15] ;
skinPercent -tv faceRigTongue0_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv faceRigTongue1_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[6:7] tempWeightCube2.vtx[16:17] ;
skinPercent -tv faceRigTongue1_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv faceRigTongue2_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[4:5] tempWeightCube2.vtx[18:19] ;
skinPercent -tv faceRigTongue2_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv faceRigTongue3_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[0:3] ;
skinPercent -tv faceRigTongue3_M 1 tongueBoxSC `ls -sl`;

string $historyNodes[];
tokenize $tongue $tempString;
if(size($tempString))
	$historyNodes=`listHistory $tempString[0]`;
else
	$historyNodes=`listHistory $tongue`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="skinCluster")
		if (!`gmatch $historyNodes[$i] "prefix_*"` && $historyNodes[$i]!="squashIKSC")
			{
			$tongueSkinCluster=$historyNodes[$i];
			break;
			}
if ($tongueSkinCluster=="")
	{
	select -r $tongue faceRigTongue3_M faceRigTongue2_M faceRigTongue1_M faceRigTongue0_M;
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	rename $tempString[0] tongueSC;
//		skinCluster -n tongueSC -dr 4 -lw false -wt 1 -mi 1;
	$tongueSkinCluster="tongueSC";
	}
else
	skinCluster -e -wt 0 -ai faceRigTongue3_M -ai faceRigTongue2_M -ai faceRigTongue1_M -ai faceRigTongue0_M $tongueSkinCluster;

//move prefix_ inf joints, since in a rebuild case, weights gets copied to these joints instead of new ones
$tempString=`listConnections -type joint -s 1 -d 0 $tongueSkinCluster`;
skinCluster -e -moveJointsMode 1 $tongueSkinCluster;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "prefix_*"`)
		if(`objExists $tempString[$i]`)
			move -r 0 0 -10 $tempString[$i];
skinCluster -e -moveJointsMode 0 $tongueSkinCluster;

eval ("select tempWeightCube2 "+$tongue);
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
skinCluster -e -removeUnusedInfluence 1 $tongueSkinCluster;
delete tempWeightCube tempWeightCube2;

asConnectTongueControl;
}

global proc asUpdateAllSet (string $allBefore[])
{
global string $gMainProgressBar;
string $previouslySel[]=`ls -sl`;
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;

select $allAfter;
select -ne -d $allSame;
select -ne -d `ls -type objectSet`;
select -d `listRelatives -ad FaceFitSkeleton`;
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] "*[.]*"`)
		sets -add FaceAllSet $sel[$i];
progressBar -e -ep $gMainProgressBar;
select $previouslySel;
}

global proc asFaceSkinSim (string $faceTargets[], string $wrapDriver)
{
global string $gMainProgressBar;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $polyAverages[];

//Load custom cloth preset here. e.g:
//select tempNClothShape;
//AttributeEditor;
//applyPresetToNode "|tempNCloth|tempNClothShape" "" "" "C:/Program Files/Autodesk/Maya2015/presets/attrPresets/nCloth/putty.mel" 1;
//setAttr "tempNClothShape.ignoreSolverGravity" 1;

select -r tempTarget;
select -add $wrapDriver;
$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "0", "0" }`;
rename $tempString[0] tempWrap;
setAttr tempWrap.autoWeightThreshold 0;
setAttr tempWrap.maxDistance 0.001;
setAttr tempWrap.exclusiveBind 1;
if (`objExists lipArea`)
	sets -remove lipArea mouthGeoBase.vtx[0:99999];

//remove teeth from wrapSet
$tempString=`listConnections tempWrap.message`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!="FaceAllSet")
		rename $tempString[$i] tempWrapSet;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1)  $teeth=$upperTeeth;
	if ($upperLowerFactor==-1) $teeth=$lowerTeeth;
	if ($teeth!="")
		{
		$tempString=`stringToStringArray $teeth " "`;
		select -cl;
		for ($i=0;$i<size($tempString);$i++)
			{
			$sub=`substitute $geometry $tempString[$i] "tempTarget"`;
			if (`objExists $sub`)
				select -add $sub;
			}
		if (size(`ls -sl`))
			{
			ConvertSelectionToVertices;
			sets -remove tempWrapSet `ls -sl`;
			}
		}
	}

int $time=-5;
createNode -n flipGroup transform;
progressBar -e -st ("Setup EyeBrow") -bp -ii 0 -min 0 -max 24 $gMainProgressBar;
for ($i=0;$i<size($faceTargets);$i++)
	{
	if (`objExists lowerLipBS_L`) //$centerFade
		{
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1) $side="_R"; else $side="_L";
			for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
				{
				if ($upperLowerFactor==1) $upperLower="upper";
				else $upperLower="lower";
				$centerFade=1;
				if (!`gmatch $faceTargets[$i] "*_R"`)
					$centerFade=0;
					{
					setAttr ($upperLower+"LipBS"+$side+".w[0]") $centerFade;
					setAttr ($upperLower+"LipBS"+$side+".w[1]") (!$centerFade);
					}
				}
			}
		}
	if ($faceTargets[$i]=="mouth_wide_C")
		{
		select lipArea;
		for ($y=0;$y<2;$y++)
			{
			$tempString=`polyAverageVertex -i 10 -ch 1`;
			$polyAverages[$y]=$tempString[0];
			}
		}

//	currentTime 0;
	currentTime $time;
	for ($y=0;$y<10;$y++)
		{
		$time++;
		currentTime $time;
		progressBar -e -s 1 $gMainProgressBar;
		}
	for ($y=0;$y<5;$y++)
		{
		currentTime ($time-1);	
		currentTime $time;	
		}
	duplicate -n $faceTargets[$i] tempTarget;

	if ($faceTargets[$i]=="mouth_wide_C") delete $polyAverages;

	if (!`gmatch $faceTargets[$i] "*_R"`)
		continue;

	//mirror target
	string $leftTarget=`substitute "_R" $faceTargets[$i] "_L"`;
	duplicate -n $leftTarget target_default;
//	parent $leftTarget faceTargets;
	duplicate -n WrapDriver $faceTargets[$i];
	setAttr flipGroup.sx 1;
	parent WrapDriver flipGroup;
	setAttr flipGroup.sx -1;
	select target_default WrapDriver;
	$tempString=`blendShape -frontOfChain`;
	rename $tempString[0] tempBS;
	setAttr tempBS.target_default 1;
	select -r $leftTarget;
	select -add WrapDriver;
	$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "0", "0" }`;
	rename $tempString[0] tempWrap2;
	setAttr tempWrap2.exclusiveBind 1;
	setAttr tempBS.target_default 0;
	select $leftTarget;
	DeleteHistory;
	delete WrapDriver;
}
delete flipGroup;
currentTime 0;
}

global proc asFaceClothConstraint (string $nurbs, float $maxDistance)
{
nurbsToPoly -n ($nurbs+"Poly") -mnd 1 -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 32 -vt 1 -vn 16 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 $nurbs;
setAttr ($nurbs+"Poly.v") 0;
select -r mouthGeo ($nurbs+"Poly");
$tempString=`createNConstraint pointToPoint 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] ($nurbs+"NClothRigid");
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] ($nurbs+"NClothConstraint");
setAttr ($nurbs+"NClothConstraint.constraintMethod") 2;
setAttr ($nurbs+"NClothConstraint.connectionMethod") 1;
setAttr ($nurbs+"NClothConstraint.maxDistance") $maxDistance;//using 1% of facescale as skinOffset
}

global proc selectVtxsInsideGeo (string $geometry, string $volumeGeo)
{
int $tempInts[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInts[0];
float $pos[];
string $cpomNode = `createNode closestPointOnMesh`;
connectAttr ($volumeGeo + ".worldMesh") ($cpomNode + ".inMesh");
connectAttr -f ($volumeGeo+".worldMatrix[0]") ($cpomNode+".inputMatrix");
select -cl;
for ($i=0;$i<$numVtx;$i++)
	{
	$pos=`xform -q -ws -t ($geometry+".vtx["+$i+"]")`;
	setAttr ($cpomNode + ".inPositionX") $pos[0];
	setAttr ($cpomNode + ".inPositionY") $pos[1];
	setAttr ($cpomNode + ".inPositionZ") $pos[2];
	vector $queryPoint = <<$pos[0], $pos[1], $pos[2]>>;
	float $cPosX = `getAttr ($cpomNode + ".positionX")`;
	float $cPosY = `getAttr ($cpomNode + ".positionY")`;
	float $cPosZ = `getAttr ($cpomNode + ".positionZ")`;
	vector $pos = unit($queryPoint - <<$cPosX, $cPosY, $cPosZ>>);
	float $nX = `getAttr ($cpomNode + ".normalX")`;
	float $nY = `getAttr ($cpomNode + ".normalY")`;
	float $nZ = `getAttr ($cpomNode + ".normalZ")`;
	vector $normal = unit(<<$nX, $nY, $nZ>>);
	if (dot($normal, $pos) <= 0)
		select -add ($geometry+".vtx["+$i+"]");
	}
delete $cpomNode;
}

global proc asFaceCreateTestDuplicate ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
if ($geometry=="")
	error "No \"Face\" Geometry choosen yet";
if (!`objExists $geometry`)
	error ("Face Geometry:\""+$geometry+"\" not found");
createNode -n FaceSymmetryTestGroup transform;
duplicate -n FaceSymmetryTest $geometry;
parent FaceSymmetryTest FaceSymmetryTestGroup;
asLockAttr FaceSymmetryTestGroup 1 1 0 1;
setAttr -k 0 -l 1 FaceSymmetryTestGroup.sy;
setAttr -k 0 -l 1 FaceSymmetryTestGroup.sz;
setAttr FaceSymmetryTestGroup.sx -1;
select FaceSymmetryTestGroup;
connectControl asFaceDuplicateSlider FaceSymmetryTestGroup.sx;
}

global proc asFaceWrapDeformToFace ()
{
float $pos[];
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $shape;
string $tempString[];
//remove possible defomers first
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if (size($tempString)<2)
		continue;
	$tempString=`listRelatives -ni -s $sel[$i]`;
	delete `listRelatives -s -ni $sel[$i]`;
	$tempString=`listRelatives -s $sel[$i]`;
	$shape=$tempString[0];
	setAttr ($shape+".intermediateObject") 0;
	$tempString=`listConnections -p 1 ($shape+".worldMesh[0]")`;
	if (size($tempString))
		disconnectAttr ($shape+".worldMesh[0]") $tempString[0];
	print ("// Deleting history for \""+$sel[$i]+"\", to avoid double deformations;\n");
	}
for ($i=0;$i<size($sel);$i++)
	{
	select -r $sel[$i];
	select -add $geometry;
	$tempString=`doWrapArgList "6" { "1","0","1", "2", "0", "1", "1", "0" }`;
	rename $tempString[0] eyeBrowWrap;
	}
print ("// WrapDeformer created\n");
}

global proc asFaceSkinEyeLashes ()
{
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "Nothing selected";
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $numLid,$haveSkinCluster;
string $skinCluster;
string $tempString[],$historyNodes[];

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		for ($y=1;$y<99;$y++)
			{
			if (`objExists ($upperLower+"LidInner"+$y+$side)`)
				$numLid=$y;
			else
				break;
			}

		polyPlane -n ($upperLower+"EyeLidCage"+$side) -w 1 -h 1 -sx ($numLid-1) -sy 1 -ax 0 1 0 -cuv 2 -ch 1;
		for ($y=1;$y<$numLid+1;$y++)
			{
			$pos=`xform -q -ws -t ($upperLower+"LidInner"+$y+$side)`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			$pos=`xform -q -ws -t FitEyeBall`;
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 4 4 4 ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			}
		select ($upperLower+"EyeLidCage"+$side);
		for ($y=1;$y<$numLid+1;$y++)
			select -add ($upperLower+"LidInner"+$y+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"EyeLidCageSC"+$side);
		select $geometry ($upperLower+"EyeLidCage"+$side);
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		
		for ($y=1;$y<$numLid+1;$y++)
			{
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			artAttrSkinWeightCopy;
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			artAttrSkinWeightPaste;
			}
		}
	}

select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
for ($i=0;$i<size($sel);$i++)
	{
	$historyNodes=`listHistory $sel[$i]`;
	$haveSkinCluster=0;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	select $sel[$i];
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			for ($y=1;$y<99;$y++)
				{
				if (`objExists ($upperLower+"LidInner"+$y+$side)`)
					$numLid=$y;
				else
					break;
				}

			if ($haveSkinCluster)
				for ($y=1;$y<$numLid+1;$y++)
					catchQuiet (`skinCluster -e -ai ($upperLower+"LidInner"+$y+$side) -lw false -wt 0 $skinCluster`);
			if (!$haveSkinCluster)
				{
				for ($y=1;$y<$numLid+1;$y++)
					select -add ($upperLower+"LidInner"+$y+$side);
				}
			}
		}
	if (!$haveSkinCluster)
		{
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=`rename $tempString[0] ($sel[$i]+"EyeLashSC")`;
		}

	select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
	select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
delete upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
select $sel;
}

global proc asFaceDeleteFromCheckBox (string $region)
{
string $dialog=`confirmDialog -t "Confirm"
	-m ("Delete "+$region)
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	{
	checkBox -e -v 1 ("asFace"+$region);
	return;
	}
if (`objExists ("FaceFit"+$region)`)
	delete ("FaceFit"+$region);
checkBox -e -ed 0 ("asFace"+$region);
}

global proc asEnsureSelectionCompleteLoop ()
{
string $borderVtxs[]=`ls -sl -fl`;
int $neighboursInLoop,$neighboursInLoop2,$expandsBeforeHit,$closestNr;
for ($i=0;$i<size($borderVtxs);$i++)
	{
	select $borderVtxs[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $borderVtxs[$i];
	$tempString=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $tempString[$y] $borderVtxs`)
			$neighboursInLoop++;

	if ($neighboursInLoop<2)
		{
		//edgeloop not complete, must add vtx`s.
		for ($y=0;$y<size($tempString);$y++)
			{
			if (`stringArrayCount $tempString[$y] $borderVtxs`)
				continue;
			select $tempString[$y];
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d $tempString[$y] $borderVtxs[$i];
			$tempString2=`ls -sl -fl`;
			int $foundSolution=0;
			for ($z=0;$z<size($tempString2);$z++)
				if (`stringArrayCount $tempString2[$z] $borderVtxs`)
					if (!`stringArrayCount $tempString[$y] $borderVtxs`)
						{
						$borderVtxs[size($borderVtxs)]=$tempString[$y];
						$foundSolution=1;
						}
			if (!$foundSolution)
				for ($z=0;$z<size($tempString2);$z++)
					{
					if ($foundSolution)continue;
					select $tempString2[$z];
 					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
					select -d $tempString2[$z];
					$tempString3=`ls -sl -fl`;
					for ($q=0;$q<size($tempString3);$q++)
  					if (`stringArrayCount $tempString3[$q] $borderVtxs`)
  						{
							if (`stringArrayCount $tempString3[$q] $tempString`)
							    continue;
							if (!`stringArrayCount $tempString2[$z] $borderVtxs`)
								$borderVtxs[size($borderVtxs)]=$tempString2[$z];
							if (!`stringArrayCount $tempString[$y] $borderVtxs`)
								$borderVtxs[size($borderVtxs)]=$tempString[$y];
              $foundSolution=1;                             
							}
					}
			}
		}
	}
select $borderVtxs;
}

global proc asSkinJawPartA ()
{
global string $gMainProgressBar;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $jawJoint="Jaw_M";
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $upperTeethJoint="TeethUpper_M";
string $lowerTeethJoint="TeethLower_M";
string $vtx;
string $tempString[],$borderVtxs[];
float $pos[],$posA[],$posB[],$posC[];

//make sure teeth geo is in vtxs
if ($upperTeeth!="") 
	{
	eval ("select "+$upperTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$upperTeeth=`stringArrayToString $tempString " "`;
	}
if ($lowerTeeth!="") 
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$lowerTeeth=`stringArrayToString $tempString " "`;
	}

//add jaw joint as inf
$tempString=`listConnections ($jawJoint+".worldMatrix[0]")`;
if (!`stringArrayCount $skinCluster $tempString`)
	skinCluster -e -ai $jawJoint -lw false -wt 0 $skinCluster;

//define jawArea
//create curves around jaw region
$curveCmd="curve -d 3 ";
for ($i=0;$i<7;$i++)
	{
	$pos=`xform -q -ws -t ("JawOuter"+$i)`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawBorderCurve1;

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;delete `pointConstraint JawOuter6 EyeLidOuter6 tempGeoSnapLoc`;
geometryConstraint $geometry tempGeoSnapLoc;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$pos=`xform -q -ws -t EyeLidOuter6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeLidMain6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawBorderCurve2;

duplicate -n JawBorderCurve3 lowerEyeLidMainCurve;
parent -w JawBorderCurve3;
$tempString=`listRelatives -s JawBorderCurve3`;
rename $tempString[0] "JawBorderCurveShape3";

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t EyeLidMain0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeLidOuter0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $pos[1] $pos[2] tempGeoSnapLoc;
if (`objExists Nose0`)
	{
	$posA=`xform -q -ws -t tempGeoSnapLoc`;
	$posB=`xform -q -ws -t Nose0`;
	xform -ws -t 0 $posA[1] $posB[2] tempGeoSnapLoc;
	}
geometryConstraint $geometry tempGeoSnapLoc;
for($i=0;$i<20;$i++) setAttr tempGeoSnapLoc.tx 0;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawBorderCurve4;
select -r JawBorderCurve1 JawBorderCurve2 JawBorderCurve3 JawBorderCurve4 ;
}

global proc asSkinJawPartB ()
{
global string $gMainProgressBar;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $jawJoint="Jaw_M";
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $upperTeethJoint="TeethUpper_M";
string $lowerTeethJoint="TeethLower_M";
string $vtx;
string $tempString[],$borderVtxs[];
float $pos[],$posA[],$posB[],$posC[];

//select vtx`s from Jaw region curves
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempPointOnCurveInfo.position tempLoc.t;

asCreateSamplerMesh $geometry;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr -f tempLoc.worldPosition closestSampler.inPosition;

select -cl;
progressBar -e -st ("Setup JawArea") -bp -ii 0 -min 0 -max (98*2*4) $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	setAttr tempLocFlip.sx $b;
	for ($a=1;$a<5;$a++)
		{
		connectAttr -f ("JawBorderCurveShape"+$a+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		for ($i=0;$i<99;$i++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			setAttr tempPointOnCurveInfo.parameter ($i*0.01);
//			refresh;
			$vtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
			if (!`stringArrayCount $vtx $borderVtxs`)
				$borderVtxs[size($borderVtxs)]=$vtx;
			}
		}
	}
select $borderVtxs;
GrowPolygonSelectionRegion;//Thicken the `Border` for the `Jaw-shell`.
$borderVtxs=`ls -sl -fl`;

//Find center vtx to grow from
$posA=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $posA[1] $posA[2] tempGeoSnapLoc;
setAttr -l 1 tempGeoSnapLoc.tx;delete `geometryConstraint $geometry tempGeoSnapLoc`;
setAttr -l 0 tempGeoSnapLoc.tx;setAttr tempGeoSnapLoc.tx 0;
connectAttr -f tempGeoSnapLoc.worldPosition closestSampler.inPosition;
string $JawStartVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete samplerMesh closestSampler;
//delete tempGeoSnapLoc JawBorderCurve1 JawBorderCurve2 JawBorderCurve3 JawBorderCurve4;
delete tempGeoSnapLoc;


//grow until Jaw region, to create separate forhead object;
select $JawStartVtx;
for ($i=0;$i<50;$i++)
{
ConvertSelectionToEdges;
ConvertSelectionToVertices;
select -d $borderVtxs; 
}
select -d `sets -q foreHeadVtxs`;
GrowPolygonSelectionRegion;
select -d `sets -q eyeLidVtxs`;
string $jawArea[]=`ls -sl`;
if (size($jawArea)==0)
	error "Unable to determine the jawArea";
//Remove eyeLidVtxs+grownOnce, to avoid bleeding eyeLidWeights
select eyeLidVtxs;GrowPolygonSelectionRegion;
string $expandedEyeLidVtxs[]=`ls -sl`;
select $jawArea;
select -d $expandedEyeLidVtxs;
$jawArea=`ls -sl`;
createNode -n jawArea objectSet;
	if (`objExists "Sets"`)
		sets -add "Sets" jawArea;
sets -add jawArea $jawArea;

//define 50% vtxs & 0% vtxs (as a line from mouthCnr (noseCnr) to JawStart
duplicate -n JawMainCurve50 JawMainCurve;
$pos=`xform -q -ws -t upperLipCylinder.cv[6][3]`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve50.cv[0:1];
$pos=`xform -q -ws -t JawMain6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve50.cv[5:6];
$posA=`xform -q -ws -t upperLipCylinder.cv[6][3]`;
$posB=`xform -q -ws -t JawMain6`;
$posC=`xform -q -ws -t JawMain3`;
$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
xform -ws -t ($posC[0]-$mag*0.1) (($posA[1]+$posB[1])/2.0) ($posC[2]+$mag*0.1) JawMainCurve50.cv[2:4];
duplicate -n JawMainCurve0 JawMainCurve;
$pos=`xform -q -ws -t Nose6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve0.cv[0:1];
$pos=`xform -q -ws -t JawMain6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve0.cv[5:6];
$posA=`xform -q -ws -t Nose6`;
$posB=`xform -q -ws -t JawMain6`;
$posC=`xform -q -ws -t JawMain3`;
xform -ws -t ($posC[0]-$mag*0.1) (($posA[1]+$posB[1])/2.0) ($posC[2]+$mag*0.1) JawMainCurve0.cv[2:4];

//All head first
select jawArea;
skinPercent -tv $headJoint 1 $skinCluster `ls -sl`;

//teeth
string $upperLower,$teeth,$teethJoint,$teethObject;
string $teethObjects[];
string $teethSC=$skinCluster;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$teeth=$upperTeeth;$teethJoint=$upperTeethJoint;}
	else {$upperLower="lower";$teeth=$lowerTeeth;$teethJoint=$lowerTeethJoint;}
		
	if ($teeth=="")
		continue;

	tokenize $teeth " " $tempString;
	clear $teethObjects;
	for ($i=0;$i<size($tempString);$i++)
		$teethObjects[$i]=$tempString[$i];

	for ($i=0;$i<size($teethObjects);$i++)
		{
		$teethObject=$teethObjects[$i];
		if (`gmatch $teethObject "*[.]*"`)
			{
			tokenize $teethObject "." $tempString;
			$teethObject=$tempString[0];
			}
		int $haveSkinCluster=0;
	
		string $historyNodes[]=`listHistory $teethObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$teethSC=$historyNodes[$y];
				}
		if (!$haveSkinCluster)
			{
			select $teethJoint;
			select -add $teethObjects[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] ($upperLower+"TeethSC");
			}
		else
			{
			$tempString=`listConnections ($teethSC+".matrix")`;
			if (!`stringArrayCount $teethJoint $tempString`)
				skinCluster -e -ai $teethJoint -lw false -wt 0 $teethSC;
			eval ("select "+$teeth);
			skinPercent -tv $teethJoint 1 $teethSC `ls -sl`;
			}
		}
	}

//jaw line
asSelectCurveVtx JawMainCurve;
string $jawCurveVtxs[]=`ls -sl`;
skinPercent -tv $jawJoint 1 $skinCluster `ls -sl`;
asSelectCurveVtx JawMainCurve50;
string $jawCurve50Vtxs[]=`ls -sl`;
skinPercent -tv $jawJoint 0.5 $skinCluster `ls -sl`;
asSelectCurveVtx JawMainCurve0;
string $jawCurve0Vtxs[]=`ls -sl`;

//find $LipVtxs
$posA=`xform -q -ws -t upperLipCylinder.cv[0][3]`;
$posB=`xform -q -ws -t upperLipCylinder.cv[0][7]`;
float $lipRadius=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`/1.5;
select $geometry;
$pos=`xform -q -ws -t upperLipCylinder.cv[0][3]`;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $lipRadius -dp $pos[0] $pos[1] $pos[2];
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $upperLipVtxs[]=`ls -sl`;
if (!size($upperLipVtxs))
	error ("Failed to find $upperLipVtxs, within radius of \""+$lipRadius+"\" of upperLipCylinder.cv[0][3]");

$posA=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
$posB=`xform -q -ws -t lowerLipCylinder.cv[0][7]`;
$lipRadius=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`/1.5;
$pos=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $lipRadius -dp $pos[0] $pos[1] $pos[2];
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $lowerLipVtxs[]=`ls -sl`;
polySelectConstraint -m 0;
if (!size($lowerLipVtxs))
	error ("Failed to find $lowerLipVtxs, within radius of \""+$lipRadius+"\" of lowerLipCylinder.cv[0][3]");


//find "$grownUpLipVtxs"
asCreateSamplerMesh $geometry;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
$pos=`xform -q -ws -t Lip6`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
string $sideLipVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
$pos=`xform -q -ws -t upperLip0`;
string $nearestInYVtx;
float $nearestInYDist=999;
for ($i=0;$i<size($upperLipVtxs);$i++)
	{
	$vtx=$upperLipVtxs[$i];
	float $pos2[]=`xform -q -ws -t $vtx`;
	float $dist=abs($pos[1]-$pos2[1]);
	if ($dist<$nearestInYDist)//closest in TY)
		{
		$nearestInYDist=$dist;
		$nearestInYVtx=$vtx;
		}
	}
select $nearestInYVtx;
string $grownUpLipVtxs[],$grownUpLipVtxsInverse[];
for ($i=0;$i<99;$i++)
	{
	GrowPolygonSelectionRegion;
	$tempString=`ls -sl -fl`;
	if (`stringArrayCount $sideLipVtx $tempString`)
		{
		$grownUpLipVtxs=`ls -sl`;
		sets -n grownUpLipVtxs;
		if (`objExists "Sets"`)
			sets -add "Sets" grownUpLipVtxs;
		InvertSelection;
		$grownUpLipVtxsInverse=`ls -sl`;
		sets -n grownUpLipVtxsInverse;
		if (`objExists "Sets"`)
			sets -add "Sets" grownUpLipVtxsInverse;
		break;
		}
	}

//update $upperLipVtxs[] & $lowerLipVtxs[], for up/lo lip separation
select $upperLipVtxs;
select -d $grownUpLipVtxsInverse;
$upperLipVtxs=`ls -sl`;
select $lowerLipVtxs;
select -d $grownUpLipVtxs;
$lowerLipVtxs=`ls -sl`;

//$noseEndVtx
$pos=`xform -q -ws -t Nose6`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
string $noseEndVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete samplerMesh closestSampler;

skinPercent -tv $jawJoint 0.1 $skinCluster $upperLipVtxs;
skinPercent -tv $jawJoint 0.5 $skinCluster $sideLipVtx;
skinPercent -tv $jawJoint 0.9 $skinCluster $lowerLipVtxs;
skinPercent -tv $jawJoint 0.5 $skinCluster $jawCurve50Vtxs;

select jawArea;
select -d $jawCurveVtxs $upperLipVtxs $sideLipVtx $lowerLipVtxs $noseEndVtx;
select -d $jawCurve50Vtxs $jawCurve0Vtxs `sets -q eyeLidVtxs`;
weightHammerVerts;
select $jawCurveVtxs $upperLipVtxs $sideLipVtx $lowerLipVtxs $noseEndVtx $jawCurve50Vtxs $jawCurve0Vtxs;
weightHammerVerts;
select $jawCurve0Vtxs;GrowPolygonSelectionRegion;GrowPolygonSelectionRegion;
weightHammerVerts;

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
select jawArea;
}

global proc asSelectCurveVtx (string $curve)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[]=`listRelatives -s $curve`;
string $curveShape=$tempString[0];

string $tmpObjs[]={"tempLocator","tempPointOnCurveInfo","samplerMesh","closestSampler"};
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
spaceLocator -n tempLocator;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
connectAttr -f ($curveShape+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
setAttr tempPointOnCurveInfo.parameter 0.5;
connectAttr tempPointOnCurveInfo.position tempLocator.t;
setAttr tempLocator.v 0;

asCreateSamplerMesh $geometry; 
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr tempLocator.worldPosition closestSampler.inPosition;
setAttr "tempPointOnCurveInfo.parameter" 1;
select -cl;
int $previousVtx;
for ($i=0;$i<99;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter (0.01*$i);
	int $vtx=`getAttr closestSampler.result.closestVertexIndex`;
	if($vtx!=$previousVtx)
		{
		select -add ($geometry+".vtx["+$vtx+"]");
		string $currentSel[]=`ls -sl`;
		refresh;
		select $currentSel;
		}
	$previousVtx=$vtx;
	}
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
}

global proc asFacePaintControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";
$tempString=`listConnections ($sel[0]+".s")`;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	asFacePaintClusterWeights;
	print "// Detected this controller to control a \"Cluster\", starting Cluster Painting Tool";
	}
else
	{
	tokenize $sel[0] "_" $tempString;
	if (!($tempString[1]=="R" || $tempString[1]=="L" || $tempString[1]=="M"))
		$error=1;
	string $joint=$tempString[0]+"Joint_"+$tempString[1];
	if (!`objExists $joint`)
		$error=1;
	if (!$error)
		{
		select $geometry;
		ArtPaintSkinWeightsTool;
		string $currentCtx = `currentCtx`;
		artSkinSelectInfluence artAttrSkinPaintCtx $joint;
		print "// Detected this controller to control a \"Joint\", starting Skin Weight Tool";
		}
	}
if ($error)
		error "Unable to detect which joint or cluster this is controlling";
}

global proc asFacePaintClusterWeights ()
{
string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrun" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;
	
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
$fitJoint=$tempString[0];
$side="_"+$tempString[1];

if ($dialog=="UnPrun")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ($geometry+".vtx[0:999999]");
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

artAttrToolScript 4 "cluster";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
select $geometry;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
}

global proc asBSWizardStop ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
text -e -l "..." asBSWizardObjAttrText;
text -e -l "..." asBSWizardValueText;
button -e -en 0 asBSWizardHelpButton;
button -e -en 0 asBSWizardNextButton;
if (`objExists deleteThis`)
	delete deleteThis;
if (`objExists tempAnimCurve`)
	delete tempAnimCurve;
asGoToBuildPose faceSetup;
}

global proc asBSWizard ()
{
button -e -en 1 asBSWizardNextButton;
button -e -en 1 asBSWizardHelpButton;
asGoToBuildPose faceSetup;
playbackOptions -min 1 -max 10 -ast 1 -aet 10;
asBSWizardNext;
}

global proc asBSWizardNext ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
int $step=$previousStep+1;

if (`objExists deleteThis`)
	delete deleteThis;
if (`objExists tempAnimCurve`)
	delete tempAnimCurve;
asGoToBuildPose faceSetup;

string $objAttr;
float $value;
if ($step==1)
	{$objAttr="ctrlBrow_R.translateY";$value=-1;}
if ($step==2)
	{$objAttr="ctrlBrow_R.translateY";$value=1;}
if ($step==3)
	{$objAttr="ctrlBrow_R.translateX";$value=1;}
if ($step==4)
	{$objAttr="ctrlBrow_R.translateX";$value=-1;}
if ($step==5)
	{$objAttr="ctrlBrow_R.squeeze";$value=10;}
if ($step==6)
	{$objAttr="ctrlBrow_R.outerUpDown";$value=10;}
if ($step==7)
	$step=8;
//	{$objAttr="ctrlBrow_R.outerUpDown";$value=-10;}
if ($step==8)
	{$objAttr="ctrlEye_R.squint";$value=10;}
if ($step==9)
	{$objAttr="ctrlCheek_R.translateY";$value=1;}
if ($step==10)
	{$objAttr="ctrlCheek_R.translateX";$value=1;}
if ($step==11)
	{$objAttr="ctrlCheek_R.translateX";$value=-1;}
if ($step==12)
	{$objAttr="ctrlNose_R.translateY";$value=1;}
if ($step==13)
	{$objAttr="ctrlNose_R.translateX";$value=1;}
if ($step==14)
	{$objAttr="ctrlNose_R.translateX";$value=-1;}
if ($step==15)
	$step=16;
//	{$objAttr="ctrlNose_R.furrowDeepener";$value=10;}
if ($step==16)
	$step=17;
//	{$objAttr="ctrlMouth_M.translateY";$value=-1;}
if ($step==17)
	{$objAttr="ctrlMouth_M.translateX";$value=1;}
if ($step==18)
	{$objAttr="ctrlMouth_M.translateX";$value=-1;}
if ($step==19)
	$step=22;
if ($step==22)
	$step=23;
//	{$objAttr="ctrlMouth_M.jawShut";$value=10;}
if ($step==23)
	$step=24;
//	{$objAttr="ctrlMouth_M.chinRaiser";$value=10;}
if ($step==24)
	$step=25;
//	{$objAttr="ctrlMouth_M.oh";$value=10;}
if ($step==25)
	$step=26;
//	{$objAttr="ctrlMouth_M.pucker";$value=10;}
if ($step==26)
	$step=27;
//	{$objAttr="ctrlMouth_M.funnel";$value=10;}
if ($step==27)
	{$objAttr="ctrlMouth_M.lipPress_R";$value=10;}
if ($step==28)
	{$objAttr="ctrlMouth_M.lipUpperRoll_R";$value=10;}
if ($step==29)
	{$objAttr="ctrlMouth_M.lipUpperRoll_R";$value=-10;}
if ($step==30)
	{$objAttr="ctrlMouth_M.lipLowerRoll_R";$value=10;}
if ($step==31)
	{$objAttr="ctrlMouth_M.lipLowerRoll_R";$value=-10;}
if ($step==32)
	{$objAttr="ctrlMouthCorner_R.translateY";$value=-1;}
if ($step==33)
	{$objAttr="ctrlMouthCorner_R.translateY";$value=1;}
if ($step==34)
	{$objAttr="ctrlMouthCorner_R.translateX";$value=1;}
if ($step==35)
	{$objAttr="ctrlMouthCorner_R.translateX";$value=-1;}
if ($step==36)
	$step=37;
//	{$objAttr="ctrlMouthCorner_R.dimpler";$value=10;}
if ($step==37)
	$step=38;
//	{$objAttr="ctrlMouthCorner_R.stretcher";$value=10;}
if ($step==38)
	{
	print ("// All Shapes Complete.\n");
	asBSWizardStop;
	if (`window -q -ex faceHelpImage`)
		deleteUI faceHelpImage;
	return;
	}

text -e -l ($step+"/"+$lastStep) asBSWizardStepText;
button -e -c ("asHelpImage asBSWizardStep"+$step) asBSWizardHelpButton;
if (`window -q -ex faceHelpImage`)
	asHelpImage ("asBSWizardStep"+$step);

text -e -l $objAttr asBSWizardObjAttrText;
text -e -l $value asBSWizardValueText;

print ("// "+$step+"/"+$lastStep+"\n");
evalEcho ("setAttr "+$objAttr+" "+$value);
asBSAdjustTarget;
}

global proc asBSResetTarget ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[],$resetTargets[];
if (!`objExists deleteThis`)
	error "Click create blendshape target first";
$tempString=`listRelatives deleteThis`;
$resetTargets[0]=$tempString[0];

setAttr asFaceBS.envelope 0;
duplicate -n asBSResetTarget $geometry;
setAttr asFaceBS.envelope 1;
parent asBSResetTarget deleteThis;
$tempString=`listRelatives -s asBSResetTarget`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
for ($i=0;$i<size($resetTargets);$i++)
	{
	select -r asBSResetTarget $resetTargets[$i];
	blendShape -n deleteThisResetBS -frontOfChain;
	setAttr deleteThisResetBS.asBSResetTarget 1;
	select $resetTargets[$i];
	DeleteHistory;
	}
delete asBSResetTarget;
select $sel;
}

global proc asBSExtractAll ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
//for ($i=0;$i<$lastStep;$i++)
createNode -n asBlendShapes transform;
for ($i=0;$i<$lastStep;$i++)
	{
	asBSWizardNext;
	if (`objExists asFaceMirroWrap`)
		delete asFaceMirroWrap;
	if (`text -q -l asBSWizardStepText`=="0/37")
		break;
	parent `listRelatives -c deleteThis` asBlendShapes;
	}
string $tempString[]=`listRelatives -c asBlendShapes`;
for ($i=0;$i<size($tempString);$i++)
	if (!`getAttr ($tempString[$i]+".v")`)
		delete $tempString[$i];
}

global proc asBSAdjustTarget ()
{
select asFaceBS;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $targets[]=`listAttr -m asFaceBS.weight`;
string $targetLeft;
int $targetNum;
float $targetWeights[];
float $targetWeightsSum=0;
for ($i=0;$i<size($targets);$i++)
    {
    $targetWeights[$i]=`getAttr ("asFaceBS."+$targets[$i])`;
    $targetWeightsSum+=$targetWeights[$i];
    if ($targetWeights[$i]>0.99 && $targetWeights[$i]<1.01)
        $targetNum=$i;
    }
if ($targetWeightsSum>1.01 || $targetWeightsSum<0.99)
	{
	for ($i=0;$i<size($targets);$i++)
		if ($targetWeights[$i]>0.001 || $targetWeights[$i]<-0.001)
			print ("// asFaceBS."+$targets[$i]+" = "+$targetWeights[$i]+"\n");
	AttributeEditor;
  error "Must have one target set to \"1\", and the rest set to \"0\"\n";
  }
if (`objExists deleteThis`)
	delete deleteThis;
createNode -n deleteThis transform;
float $cheekPos[]=`xform -q -ws -t JawOuter6`;
string $targetName=$targets[$targetNum];
if (`objExists $targetName`)
	error ("Object "+$targetName+" exists");
if (!`attributeExists ($targetName+"_tweaked") FaceFitSkeleton`)
	addAttr -k 1 -dv 1 -ln ($targetName+"_tweaked") -at bool FaceFitSkeleton;
setAttr ("FaceFitSkeleton."+$targetName+"_tweaked") 1;
if (`gmatch $targetName "*_R"`)
	{
	$targetLeft=`substitute "_R" $targetName "_L"`;
		if (!`attributeExists ($targetLeft+"_tweaked") FaceFitSkeleton`)
			addAttr -k 1 -dv 1 -ln ($targetLeft+"_tweaked") -at bool FaceFitSkeleton;
	setAttr ("FaceFitSkeleton."+$targetLeft+"_tweaked") 1;
	}
setAttr ($skinCluster+".envelope") 0;
duplicate -n $targetName $geometry;
asLockAttr $targetName 0 0 0 0;
setAttr ($skinCluster+".envelope") 1;
parent $targetName deleteThis;
select $targetName;
string $tempString[]=`listRelatives -f -s $targetName`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
connectAttr -f ($targetName+".worldMesh[0]") ("asFaceBS.inputTarget[0].inputTargetGroup["+$targetNum+"].inputTargetItem[6000].inputGeomTarget");
refresh;//Maya2016 bug workaround
move -r ($cheekPos[0]*2.5) 0 0 $targetName;

if (`gmatch $targetName "*_R"`)
    {
    refresh;
    $targetLeft=`substitute "_R" $targetName "_L"`;
    setAttr asFaceBS.envelope 0;
    duplicate -n $targetLeft $geometry;
    asLockAttr $targetLeft 0 0 0 0;
    parent $targetLeft deleteThis;
    setAttr asFaceBS.envelope 1;
    move -r ($cheekPos[0]*-2.5) 0 0 $targetLeft;
    $tempString=`listRelatives -f -s $targetLeft`;
    for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
    duplicate -n ($targetLeft+"MirrorDriver") $targetLeft;
    setAttr ($targetLeft+"MirrorDriver.sx") -1;
    setAttr ($targetLeft+"MirrorDriver.v") 0;

    select -r $targetLeft ($targetLeft+"MirrorDriver");
		CreateWrap;
    $tempString=`listConnections ($targetLeft+"MirrorDriver.inflType")`;
		rename $tempString[0] asFaceMirroWrap;
		setAttr asFaceMirroWrap.exclusiveBind 1;
    connectAttr -f ($targetName+".outMesh") ($targetLeft+"MirrorDriver.inMesh");
    
    for ($i=0;$i<size($targets);$i++)
        if ($targets[$i]==$targetLeft)
            connectAttr -f ($targetLeft+".worldMesh[0]") ("asFaceBS.inputTarget[0].inputTargetGroup["+$i+"].inputTargetItem[6000].inputGeomTarget");
    }

floatSlider -e -en 1 asFaceBSFloatSlider;
connectControl asFaceBSFloatSlider ("asFaceBS."+$targetName);
select $targetName;
}

global proc asFaceCreatePlacementLocator (int $mirror, string $controlName)
{
string $side="_R";
if ($mirror)
	$side="_L";
else
	{
	if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
		return;
	$controlName=`promptDialog -query -text`;
	}
if (`objExists ($controlName+$side)`)
	error ("Controller \""+$controlName+$side+"\" Already exists");

spaceLocator -n ($controlName+"_placement");
float $posA[]=`xform -q -ws -t EyeLidOuter6`;
float $posB[]=`xform -q -ws -t EyeLidOuter0`;
float $posC[];
$posC[0]=($posA[0]+$posB[0])/2.0;
$posC[1]=($posA[1]+$posB[1])/2.0;
$posC[2]=($posA[2]+$posB[2])/2.0 + ($posB[0]-$posA[0]);
xform -ws -t $posC[0] $posC[1] $posC[2] ($controlName+"_placement");
float $scale=($posB[0]-$posA[0])/2.0;
xform -os -r -s $scale $scale $scale ($controlName+"_placement");
addAttr -k 1 -ln placementLocator -at bool -dv true ($controlName+"_placement");
if ($mirror)
	{
	$posC=`xform -q -ws -t ($controlName+"_R")`;
	xform -ws -t ($posC[0]*-1) $posC[1] $posC[2] ($controlName+"_placement");
	$scale=`getAttr ($controlName+"_R.falloffRadius")`*2;
	xform -os -r -s $scale $scale $scale ($controlName+"_placement");
	}
select ($controlName+"_placement");
}

global proc asFaceCreateRubberControl ()
{
string $tempString[];
string $sel[]=`ls -sl`;
if (!`attributeExists placementLocator $sel[0]`)
	error "A placement locator must be selected";
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $controlName=`substitute "_placement"  $sel[0] ""`;
string $side="_R";
float $pos[]=`xform -q -ws -t $sel[0]`;
	if ($pos[0]>0)
		$side="_L";
if ($pos[0]>-0.001 && $pos[0]<0.001)
	$side="_M";
float $falloffRadius=`getAttr ($sel[0]+".sx")`;
delete $sel[0];

if (!`objExists RubberSetup`)
	{
	string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
	string $allFaceGeo[],$tempString[];
	tokenize $allFaceGeoString $tempString;
	for ($i=0;$i<size($tempString);$i++)
		$allFaceGeo[$i]=$tempString[$i];
	select $allFaceGeo;

	$tempString=`lattice  -divisions 21 21 21 -objectCentered true  -ldv 2 2 2`;
	rename $tempString[0] rubberFfd;
	rename $tempString[1] rubberFfdLattice;
	rename $tempString[2] rubberFfdBase;
	$tempString=`listConnections rubberFfd.message`;
	rename $tempString[0] rubberFfdSet;
	setAttr rubberFfd.outsideLattice 1;

	float $rubberTopPos[3]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
	float $rubberBasePos[3]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
	float $rubberHeight=$rubberTopPos[1]-$rubberBasePos[1];
	float $rubberFrwPos[3]=`xform -q -ws -t upperEyeLidMain3`;
	float $rubberWidthPos[3]=`xform -q -ws -t JawMain6`;
	float $rubberWidth=$rubberWidthPos[0]*2;
	float $scaleFactor=$rubberHeight;
	if ($rubberWidth>$rubberHeight)
		$scaleFactor=$rubberWidth;

	xform -ws -t 0 (($rubberTopPos[1]+$rubberBasePos[1])/2) $rubberFrwPos[2] rubberFfdLattice;
	xform -ws -t 0 (($rubberTopPos[1]+$rubberBasePos[1])/2) $rubberFrwPos[2] rubberFfdBase;
	xform -s $scaleFactor $scaleFactor $scaleFactor rubberFfdLattice;
	xform -s $scaleFactor $scaleFactor $scaleFactor rubberFfdBase;

	createNode -n RubberSetup -p FaceMotionSystem transform;
	createNode -n rubberLattice -p RubberSetup transform;
	parentConstraint $headJoint rubberLattice;
	scaleConstraint $headJoint rubberLattice;
	parent rubberFfdLattice rubberFfdBase rubberLattice; 
	
	setAttr -l 1 RubberSetup.v 0;
	if (`objExists squashFfd`)
		{
		//rubberFfd && squashFfd will not work well together, so instead have squashFfd only deform rubberFfd
		sets -rm squashFfdSet `sets -q squashFfdSet`;
		sets -add squashFfdSet rubberFfdLattice;
		}
	if (!`attributeExists RubberCtrlVis ctrlBox`)
		addAttr -k 1 -ln "RubberCtrlVis" -at bool -dv true ctrlBox;
	if (!`attributeExists RubberCtrlEnable ctrlBox`)
		addAttr -k 1 -ln "RubberCtrlEnable" -at bool -dv true ctrlBox;
	if (!`objExists RubberControls`)
		{
		createNode -n RubberControls -p ControlsSetup transform;
		connectAttr ctrlBox.RubberCtrlVis RubberControls.v;
		parentConstraint $headJoint RubberControls;
		scaleConstraint $headJoint RubberControls;
		createNode -n rubberOrigin transform;
		parent rubberOrigin RubberControls;
		}
	createNode -n RubberCtrlEnableReverse reverse;
	setAttr -type float3 RubberCtrlEnableReverse.input 1 1 1;
	connectAttr -f ctrlBox.RubberCtrlEnable RubberCtrlEnableReverse.inputX;
	connectAttr -f RubberCtrlEnableReverse.outputX rubberFfd.nodeState;
	}

asCreateFaceController $controlName $side 12;
rename ($controlName+"Subtract"+$side) ($controlName+"Origin"+$side);
asLockAttr ($controlName+"Origin"+$side) 0 1 1 1;
sets -add FaceControlSet ($controlName+"Origin"+$side);
xform -ws -t $pos[0] $pos[1] $pos[2] ($controlName+"Offset"+$side);
addAttr -k 1 -min 0 -dv $falloffRadius -ln falloffRadius -at double ($controlName+$side);
parent ($controlName+"Offset"+$side) RubberControls;
delete ($controlName+"Attach"+$side);
createNode -n ($controlName+"OriginReader"+$side) -p rubberOrigin transform;
pointConstraint ($controlName+"Origin"+$side) ($controlName+"OriginReader"+$side);
asFaceEnsureShaders;
sets -e -forceElement asFaceRedSG ($controlName+$side);
string $setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$controlName+$side+";";
$setAttrCmdExtra+="xform -a -os -t 0 0 0 "+$controlName+"Origin"+$side+";";
setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);

select -r rubberFfdLattice;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ($controlName+"latticeSoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($controlName+"latticeSoftModHandle"+$side)`;
$tempString=`listConnections ($softMod+".message")`;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") 0;
if (`objExists squashFfd`)
	catch (`reorderDeformers squashFfd ($controlName+"latticeSoftMod"+$side) rubberFfdLattice`);
if (`objExists squashFfdSet`)
	sets -add squashFfdSet ($controlName+$side);
parent $softModHandle RubberSetup;

setAttr -type float3 ($softModHandle+"Shape.origin") $pos[0] $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] $softModHandle;

connectAttr ($controlName+$side+".t") ($softModHandle+".t");
connectAttr ($controlName+$side+".r") ($softModHandle+".r");
connectAttr ($controlName+$side+".s") ($softModHandle+".s");
connectAttr ($controlName+$side+".falloffRadius") ($softMod+".falloffRadius");
connectAttr ($controlName+"OriginReader"+$side+".t") ($softMod+".falloffCenter");
select ($controlName+$side);
}

global proc asFaceSaveRubberFalloff ()
{
string $sel[]=`ls -sl`;
if ($sel[0]=="")
	error "Rubber Control must be selected";
if (!`sets -im FaceControlSet $sel[0]` || !`attributeExists falloffRadius $sel[0]`)
	error "Rubber Control must be selected";

string $existingCmd=`getAttr faceBuildPose.udAttr`;
string $tempString[];
tokenize $existingCmd ";" $tempString;
string $newCmd;
float $falloffRadius=`getAttr ($sel[0]+".falloffRadius")`;
$falloffRadius=`asRoundOff $falloffRadius 3`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] ("setAttr "+$sel[0]+"[.]falloffRadius *")`)
		$newCmd+=$tempString[$i]+";";
	}
$newCmd+="setAttr "+$sel[0]+".falloffRadius "+$falloffRadius+";";
setAttr -type "string" faceBuildPose.udAttr $newCmd;
print ("// Falloff radius stored to face buildPose\n");
}

global proc asFaceMirrorRubberControl ()
{
string $sel[]=`ls -sl`;
if ($sel[0]=="")
	error "Rubber Control to mirror, must be selected";
if (!`sets -im FaceControlSet $sel[0]` || !`attributeExists falloffRadius $sel[0]`)
	error "Rubber Control to mirror, must be selected";
if (!`gmatch $sel[0] "*_R"`)
	error "Rubber Control on Right side must be selected";
int $numChar=size($sel[0]);
string $controlName=`substring $sel[0] 1 ($numChar-2)`;

string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose faceSetup;
asFaceCreatePlacementLocator 1 $controlName;
asFaceCreateRubberControl;
eval($restorePoseCmd);
}

global proc asFaceMirrorRubberControl ()
{
string $sel[]=`ls -sl`;
if ($sel[0]=="")
	error "Rubber Control to mirror, must be selected";
if (!`sets -im FaceControlSet $sel[0]` || !`attributeExists falloffRadius $sel[0]`)
	error "Rubber Control to mirror, must be selected";
if (!`gmatch $sel[0] "*_R"`)
	error "Rubber Control on Right side must be selected";
int $numChar=size($sel[0]);
string $controlName=`substring $sel[0] 1 ($numChar-2)`;

string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose faceSetup;
asFaceCreatePlacementLocator 1 $controlName;
asFaceCreateRubberControl;
eval($restorePoseCmd);
}

global proc asFaceConvertSoftModToControl (int $convertingBack)
{
global string $gSelect;
string $sel[]=`ls -sl`;
asFaceEnsureAdvancedBase;
float $pos[3],$posSoftMod[3],$posControl[3],$currentT[3],$currentR[3],$currentS[3];
string $tempString[],$historyList[];
string $side;
int $multiply;
int $autoKeyState=`autoKeyframe -q -state`;
string $fitJoint,$restoreCmd,$setAttrCmdExtra,$softModSet;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*Handle*"`)
		$sel[0]=$sel[$i];

if ($convertingBack==1)
	{
	if (!`gmatch $sel[0] "convertedSoftModHandle_*"`)
		error "convertedSoftModHandle not selected";
	tokenize $sel[0] "_" $tempString;
	$fitJoint=$tempString[1];
	$side="_"+$tempString[2];
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	}
else
	{
	string $allBefore[]=`ls`;
	if (!`gmatch $sel[0] "softMod*"`)
		error "Selection is not a new SoftMod, name does not match \"softMod*\"";
	if ($convertingBack==0)
		{
		if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
			return;
		$fitJoint=`promptDialog -query -text`;
		}
	else if ($convertingBack==2)
		$fitJoint="Smile";
	if (`objExists $fitJoint` || $fitJoint=="")
		error "not a unique name";
	setToolTo $gSelect;

	//find $side, when tx=0
	float $locPos[3]=`getAttr ($sel[0]+".t")`;
	setAttr -type float3 ($sel[0]+".t") 0 0 0;
	float $pos[3]=`xform -q -ws -piv $sel[0]`;
	setAttr -type float3 ($sel[0]+".t") $locPos[0] $locPos[1] $locPos[2];
	$side="_M";
	if (!`checkBox -q -v asFaceIsMiddleControlCheckBox`)
		$side="_R";
	if ($pos[0]>0.001)
		error "SoftMod must be on Right side, or middle, currenly on Left side";

	$sel[0]=`rename $sel[0] ("convertedSoftModHandle_"+$fitJoint+$side)`;
	$tempString=`listConnections ("convertedSoftModHandle_"+$fitJoint+$side+".worldMatrix[0]")`;
	rename $tempString[0] ("convertedSoftMod_"+$fitJoint+$side);
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	string $deformObjs[]=`sets -q -no $softModSet`;
	$deformObjs=`stringArrayRemoveDuplicates $deformObjs`;

	$currentT=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t")`;
	$currentR=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r")`;
	$currentS=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s")`;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".t") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".r") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".s") 1 1 1;
	$posSoftMod=`xform -q -ws -piv ("convertedSoftModHandle_"+$fitJoint+$side)`;
	curve -n tempCurve -d 1 -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -k 0 -k 1;
	deformer -type wrap tempCurve;
	select -r tempCurve;
	select -add $geometry;
	AddWrapInfluence;

	$posControl=`xform -q -ws -t tempCurve.cv[0]`;
	createNode -n tempTransform transform;
	xform -ws -t $posControl[0] $posControl[1] $posControl[2] tempTransform;
	select tempTransform;
	int $color=6;
	if (size($deformObjs)>1)
		$color=9;
	asCreateFaceFitJoint $fitJoint `getAttr ("convertedSoftMod_"+$fitJoint+$side+".falloffRadius")` $color;
	softCluster $fitJoint $fitJoint 1 $side;
	
	if ($side=="_R")
		{
		//Mirror pose before doing left to ensure identical attachment
		string $restoreCmd=`asFaceMirror`;
		softCluster $fitJoint $fitJoint -1 "_L";
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_R;xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_L;";
	
		eval ($restoreCmd);
		if ($autoKeyState)
			autoKeyframe -state 1;
		}
	else
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_M;";


	delete tempCurve tempTransform;
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t") $currentT[0] $currentT[1] $currentT[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r") $currentR[0] $currentR[1] $currentR[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s") $currentS[0] $currentS[1] $currentS[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	//add to faceBuildPose
	setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);

	//FaceAllset
	string $allAfter[]=`ls`;
	string $allNew[];
	for ($i=0;$i<size($allAfter);$i++)
		if (!`stringArrayCount $allAfter[$i] $allBefore`)
			if (`objectType $allAfter[$i]`!="objectSet")
				$allNew[size($allNew)]=$allAfter[$i];
	sets -add FaceAllSet $allNew;
	sets -remove FaceAllSet `listRelatives -ad FaceFitSkeleton`;
	}

float $t[3]=`xform -q -ws -piv $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;

$pos=`xform -q -ws -t $fitJoint`;
string $softMod=`substitute "convertedSoftModHandle" $sel[0] "convertedSoftMod"`;
string $cluster=$fitJoint+"Cluster"+$side;
float $falloffRadius=`getAttr ($softMod+".falloffRadius")`;

float $falloffMode=`getAttr ($softMod+".falloffMode")`;
setAttr ($fitJoint+".falloffRadius") $falloffRadius;
setAttr ($fitJoint+".falloffMode") $falloffMode;

select $softModSet;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$vtxs=`ls -sl -fl`;
polySelectConstraint -m 0;

percent -v 0 $cluster $geometry;
asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;
if ($convertingBack)
	{
	select ($fitJoint+$side);
	asFaceMirrorClusterWeight;
	}
xform -ws -t $t[0] $t[1] $t[2] -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] ($fitJoint+$side);
select ($fitJoint+$side);
}

global proc asFaceConvertControlToSoftMod ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a face control";
$tempString=`listConnections ($sel[0]+".s")`;
if (!`gmatch $tempString[0] "*Cluster*"`)
	error "Selected object is not a \"cluster\" control";
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[0];
string $side="_"+$tempString[1];
if ($side=="_L")
	error "must be Right side";

string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrun" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;

float $falloffRadius=`getAttr ($fitJoint+".falloffRadius")`;
float $falloffMode=`getAttr ($fitJoint+".falloffMode")`;

if ($dialog=="UnPrun")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ($geometry+".vtx[0:999999]");
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

float $t[3]=`xform -q -ws -t $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;
float $pos[3]=`xform -q -ws -t $sel[0]`;
select -r $geometry;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ("convertedSoftMod_"+$sel[0])`;
string $softModHandle=`rename $tempString[1] ("convertedSoftModHandle_"+$sel[0])`;
$tempString=`listConnections ($softMod+".message")`;
string $softModSet=$tempString[0];
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
xform -piv ($pos[0]) $pos[1] $pos[2] $softModHandle;
xform -ws -t ($t[0]-$pos[0]) ($t[1]-$pos[1]) ($t[2]-$pos[2]) -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] $softModHandle;

if (`getAttr ($fitJoint+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!=$geometry)
			sets -add $softModSet $allFaceGeo[$i];
	}
select $softModHandle;
}

global proc string asFaceNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";
if ($nr==1) $letter="A";
if ($nr==2) $letter="B";
if ($nr==3) $letter="C";
if ($nr==4) $letter="D";
if ($nr==5) $letter="E";
if ($nr==6) $letter="F";
if ($nr==7) $letter="G";
if ($nr==8) $letter="H";
if ($nr==9) $letter="I";
return $letter;
}

global proc int asFaceLetterToNr (string $letter)
{
int $nr;
if ($letter=="") $nr=0;
if ($letter=="A") $nr=1;
if ($letter=="B") $nr=2;
if ($letter=="C") $nr=3;
if ($letter=="D") $nr=4;
if ($letter=="E") $nr=5;
if ($letter=="F") $nr=6;
if ($letter=="G") $nr=7;
if ($letter=="H") $nr=8;
if ($letter=="I") $nr=9;
return $nr;
}

global proc asChooseInput (string $textField)
{
int $confirmed;
float $tempFloat[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $txt,$dialog;
string $sel[]=`ls -sl`;
string $restoreSel[]=$sel;
string $tempString[];

if (!`gmatch $textField "*Joint*"`)
	{
	//Include children
	select -cl;
	string $children[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			select -add `listRelatives -ad -f -type transform $sel[$i]`;
	string $addedSel[]=`ls -sl`;
	$sel=`stringArrayCatenate $sel $addedSel`;
	$sel=`stringArrayRemoveDuplicates $sel`;

	//Not include non-mesh || non-nurbs (unless choose joint)
	string $shapes[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			{
			$nodeType="";
			$shapes=`listRelatives -s -ni -f $sel[$i]`;
			if (size($shapes))
				$nodeType=`nodeType $shapes[0]`;
			if ($nodeType!="nurbsSurface" && $nodeType!="mesh")
				$sel=`stringArrayRemove {$sel[$i]} $sel`;		
			}
	}
select $restoreSel;

$txt=$sel[0];

if (size($sel)>1)
	for ($i=1;$i<size($sel);$i++)
		$txt+=" "+$sel[$i];	

string $skinCluster;
//FaceGeometry validate
if ($textField=="asFaceGeometryTextField" && $sel[0]!="")
	{
	if (size($sel)>1)
		error "Face Geometry must be only 1 object";
	//Check zero xforms
	$tempString=`listHistory $sel[0]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			$skinCluster=$tempString[$y];
			textField -e -tx $skinCluster asFaceSkinClusterTextField;
			}
	if ($skinCluster=="")
		{
		$dialog=`confirmDialog -t "Confirm"
		-m "No SkinCluster found on this geometry"
		-b "Create New SkinCluster" -db "Create New SkinCluster"
		-b "Cancel" -ds "Cancel"`;
		if ($dialog!="Create New SkinCluster")
			return;
		select -cl;
		if (!`objExists $headJoint`)
			joint -n $headJoint;		
		textField -e -tx $headJoint asFaceHeadJointTextField;
		select $sel $headJoint;
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		select $sel;
		asChooseInput asFaceGeometryTextField;
		}
	}

//AllFaceGeo validate
if ($textField=="asFaceAllFaceGeoTextField" && $sel[0]!="")
	for ($i=0;$i<size($sel);$i++)
		{
		$tempString=`listRelatives -ni -s $sel[$i]`;
		if (!size($tempString))
			continue;
		if (!(`objectType $tempString[0]`=="mesh" || `objectType $tempString[0]`=="nurbsSurface"))
			continue;
		$tempString=`listHistory $sel[$i]`;
		$skinCluster="";
		for ($y=0;$y<size($tempString);$y++)
			if (`objectType $tempString[$y]`=="skinCluster")
				$skinCluster=$tempString[$y];
		if ($skinCluster=="")
			{
			if (!$confirmed)
				{
				$dialog=`confirmDialog -t "Confirm"
				-m "No SkinCluster found on some of the geometry"
				-b "Create New SkinClusters" -db "Create New SkinClusters"
				-b "Cancel" -ds "Cancel"`;
				if ($dialog!="Create New SkinClusters")
					return;
				}
			$confirmed=1;
			select -cl;
			if (!`objExists $headJoint`)
				joint -n $headJoint;
			select $sel[$i] $headJoint;
			$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
			}
		}

asFaceEnsureFitBase;

textField -e -tx $txt $textField;
//optionVar -sv $textField $txt;
asFaceUpdateInfo 0;
}

global proc asFaceAddIn (string $targets[], string $transform, int $mo)
{
string $trAddIn=$transform+"AddIn";
createNode -n $trAddIn transform;
string $tempString[]=`listRelatives -p $transform`;
parent $trAddIn $tempString[0];
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $trAddIn;
string $cmd="parentConstraint";
if($mo)
	$cmd+=" -mo";
for ($i=0;$i<size($targets);$i++)
	$cmd+=" "+$targets[$i];
$cmd+=" "+$trAddIn;
eval $cmd;

string $trs[]={"t","r","s"};
for ($i=0;$i<size($trs);$i++)
	{
	createNode -n ($trAddIn+$trs[$i]+"plusMinusAverage") plusMinusAverage;
	if ($trs[$i]=="s")
		setAttr ($trAddIn+$trs[$i]+"plusMinusAverage.operation") 3;
	connectAttr ($trAddIn+"."+$trs[$i]+"x") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dx");
	connectAttr ($trAddIn+"."+$trs[$i]+"y") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dy");
	connectAttr ($trAddIn+"."+$trs[$i]+"z") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dz");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"x")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dx");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"y")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dy");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"z")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dz");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dx") ($transform+"."+$trs[$i]+"x");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dy") ($transform+"."+$trs[$i]+"y");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dz") ($transform+"."+$trs[$i]+"z");
	}
}

global proc float asFaceGetScale ()
{
float $scale=1.5;
if (`objExists FaceFitSkeletonHeightShape`)
    {
    float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
    float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
    $scale=$pos1[1]-$pos2[1];
   	}
return $scale;
}

global proc asCreateFaceFitJoint (string $region, float $size, int $color)
{
string $sel[]=`ls -sl -fl`;
float $pos[3]=`xform -q -ws -t $sel[0]`;
float $centerErrorMargin=0.001;
if ($region=="mouthUpper" || $region=="mouthLower" || $region=="eyeBrow0"
	|| `gmatch $region "*Middle"` || $region=="noseTip" || $region=="noseLower")
	if ($pos[0]>$centerErrorMargin || $pos[0]<(-1*$centerErrorMargin))
		error ($region+" needs to be in the center, currently:"+$pos[0]+"\n");
int $jointNumber;
string $jointName;
for ($i=1;$i<99;$i++)
	{
	$jointNumber=$i;
	$jointName=$region+$jointNumber;
	if (!`objExists $jointName`)
		break;
	}
asFaceEnsureFitBase;
for ($i=0;$i<size($sel);$i++)
	{
	$jointName=$region;
	if (size($sel)>1)
		$jointName=$region+$jointNumber;
	$jointNumber++;
	$jointName=`asFaceCreateFitJoint $jointName $size $color`;
	$pos=`xform -q -ws -t $sel[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $jointName;
	}

if (`checkBox -q -ex ("asFace"+$region)`)
	checkBox -e -v 1 -ed 1 ("asFace"+$region);
hilite -r `ls -o $sel`; 
select $sel;
repeatLast -addCommand ("asCreateFaceFitJoint "+$region+" "+$size+" "+$color);

if (`gmatch $region "eyeBrow[0-9]"`)
	asAutoEyeBrowFalloff $region;
}

global proc asAutoEyeBrowFalloff (string $region)
{
float $posA[3],$posB[3];
float $mag;
int $nr=`substring $region 8 8`;
string $previousRegion="eyeBrow"+($nr-1);
if (!`objExists $previousRegion`)
	return;
$posA=`xform -q -ws -t $region`;
$posB=`xform -q -ws -t $previousRegion`;
$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
setAttr ($region+".falloffRadius") $mag;
float $previousRad=`getAttr ($previousRegion+".falloffRadius")`;
if ($mag>$previousRad || $previousRegion=="eyeBrow0")
	setAttr ($previousRegion+".falloffRadius") $mag;
}

global proc string asFaceCreateFitJoint (string $name, float $radius, int $color)
{
if (`objExists $name`)
	error ($name+" Already Exists");

if (!`objExists FaceFitFromSoftMods`)
	createNode -n FaceFitFromSoftMods -p FaceFitSkeleton transform;

select FaceFitFromSoftMods;
joint -n $name;
setAttr ($name+".overrideEnabled") 1;
setAttr ($name+".overrideColor") $color;
addAttr -k 1 -min 0 -dv $radius -ln "falloffRadius" -at double $name;
addAttr -k 1 -ln "falloffMode"  -at "enum" -en "volume:surface:" $name;
addAttr -k 1 -ln "interpolation"  -at "enum" -en "none:linear:smooth:spline:" $name;
if (`gmatch $name "lowerEye*"` || `gmatch $name "upperEye*"` || `gmatch $name "lowerLip*"` || `gmatch $name "upperLip*"`)
	;
else
	{
	setAttr ($name+".falloffMode") 1;
	setAttr ($name+".interpolation") 2;
	}
if (`gmatch $name "*Sculpt*"`)
	setAttr ($name+".falloffMode") 0;
return $name;
}

global proc asFaceUpdateInfo (int $read)
{
string $attrs[]={"Geometry","AllFaceGeo" ,"Eye_L","Eye_R","UpperTeeth","LowerTeeth","Tongue",
	"EyeBrow_L","EyeBrow_R","EyeLash_L","EyeLash_R","HeadJoint","SkinCluster"};
string $text;

for ($i=0;$i<size($attrs);$i++)
	{
	string $texField="asFace"+$attrs[$i]+"TextField";
	if(!`textField -q -ex $texField`)
		continue;
	if ($read)
		{
		$text="";

		if ($attrs[$i]=="HeadJoint") $text="Head_M";
		if (`attributeExists $attrs[$i] FaceFitSkeleton`)
			$text=`getAttr ("FaceFitSkeleton."+$attrs[$i])`;
		textField -e -tx $text $texField;
		}
	else
		{
		if (!`attributeExists $attrs[$i] FaceFitSkeleton`)
			addAttr -ln $attrs[$i] -dt "string" FaceFitSkeleton;
		setAttr -type "string" ("FaceFitSkeleton."+$attrs[$i]) `textField -q -tx $texField`;
		}
	}
}

global proc asCreateFaceController (string $name, string $side, int $color)
{
float $scale=`asFaceGetScale`/5.0;
string $tempString[]=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/15.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
rename $tempString[0] ($name+$side);
sets -add "FaceControlSet" ($name+$side);
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.castsShadows");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.receiveShadows");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.motionBlur");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.primaryVisibility");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.smoothShading");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.visibleInReflections");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.visibleInRefractions");
//disconnectAttr -na ($name+$side+"Shape.instObjGroups[0]") initialShadingGroup.dagSetMembers;
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") $color;
createNode -n ($name+"Attach"+$side) transform;
createNode -n ($name+"Offset"+$side) transform;
createNode -n ($name+"Subtract"+$side) transform;
parent ($name+$side) ($name+"Subtract"+$side);
parent ($name+"Subtract"+$side) ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);
if ($color==6)
	parent ($name+"Attach"+$side) Acontrols;
if ($color==7 || $color==8)
	parent ($name+"Attach"+$side) Bcontrols;
if ($color==10)
	parent ($name+"Attach"+$side) Ccontrols;

if ($color==6)
	sets -e -forceElement asFaceBlueSG ($name+$side);
if ($color==7)
	sets -e -forceElement asFaceGreenSG ($name+$side);
if ($color==8)
	sets -e -forceElement asFaceCyanSG ($name+$side);
if ($color==10)
	sets -e -forceElement asFaceBrownSG ($name+$side);
}
	
global proc asPingPong (string $trnPos, string $name, int $b, string $side, int $color, int $createJoint, int $bindSkin)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`/3.0;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint="FaceAttachToHead";

float $pos[]=`xform -q -ws -t $trnPos`;

if (!`objExists ClusterSetup`)
	createNode -n ClusterSetup -p FaceMotionSystem transform;
if (!`objExists Brs`)
	{
	createNode -n Brs -p Bcontrols transform;
	orientConstraint -mo $headJoint Brs;
	scaleConstraint -mo $headJoint Brs;
	}

//Alternative attach position (e.g eyeLid)
float $attachPos[]=$pos;
string $altAttPosXform="";
int $nrUpperEyeInner,$nrLowerEyeInner;
for ($nrUpperEyeInner=1;$nrUpperEyeInner<99;$nrUpperEyeInner++) if (!`objExists ("upperEyeInner"+($nrUpperEyeInner+1))`) break;
for ($nrLowerEyeInner=1;$nrLowerEyeInner<99;$nrLowerEyeInner++) if (!`objExists ("lowerEyeInner"+($nrLowerEyeInner+1))`) break;
if ($name=="upperEye1")
	$altAttPosXform="upperEyeInner"+($nrUpperEyeInner/2);
if ($name=="lowerEye1")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner/2);
if ($name=="upperEye2")
	$altAttPosXform="upperEyeInner"+($nrUpperEyeInner/4);	
if ($name=="lowerEye2")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner/4);	
if ($name=="upperEye3")
	$altAttPosXform="upperEyeInner"+($nrLowerEyeInner - ($nrLowerEyeInner/4));	
if ($name=="lowerEye3")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner - ($nrLowerEyeInner/4));	
//if ($name=="upperLip")
//	$altAttPosXform="upperEyeInner4";
if($altAttPosXform!="")
	{
	float $altAttachPos[]=`xform -q -ws -t $altAttPosXform`;
	$attachPos={$altAttachPos[0],$altAttachPos[1],$altAttachPos[2]};
	if ($side=="_L")
		$attachPos={$altAttachPos[0]*-1,$altAttachPos[1],$altAttachPos[2]};
	}

//Alternative control position (e.g lips)
float $controlPos[]=$pos;
string $altCtrlPosXform="";
int $nrUpperLipOuter,$nrLowerLipOuter;
for ($nrUpperLipOuter=1;$nrUpperLipOuter<99;$nrUpperLipOuter++) if (!`objExists ("upperLipOuter"+($nrUpperLipOuter+1))`) break;
for ($nrLowerLipOuter=1;$nrLowerLipOuter<99;$nrLowerLipOuter++) if (!`objExists ("lowerLipOuter"+($nrLowerLipOuter+1))`) break;
if ($name=="upperLip")
	$altCtrlPosXform="upperLipMiddle"+`lipLetterClosestToCenterInY upper`+"0";
if ($name=="lowerLip")
	$altCtrlPosXform="lowerLipMiddle"+`lipLetterClosestToCenterInY lower`+"0";
if ($name=="Lip")
	$altCtrlPosXform="lowerLipOuter"+$nrLowerLipOuter;
if ($name=="upperLipMid")
	$altCtrlPosXform="upperLipMiddle"+`lipLetterClosestToCenterInY upper`+($nrUpperLipOuter/2);
if($altCtrlPosXform!="" && `objExists $altCtrlPosXform`)
	{
	float $altControlPos[]=`xform -q -ws -t $altCtrlPosXform`;
	$controlPos=$altControlPos;
	$attachPos=$controlPos;
	}

//nurbsSphere controller
asCreateFaceController $name $side $color;
xform -ws -t ($controlPos[0]*$b) $controlPos[1] $controlPos[2] ($name+"Attach"+$side);

//Joint + Offset
if ($createJoint)
	{
	select -cl;
	joint -n ($name+"Joint"+$side);
	createNode -n ($name+"JointOffset"+$side) transform;
	parent ($name+"Joint"+$side) ($name+"JointOffset"+$side);
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"JointOffset"+$side);
	parent ($name+"JointOffset"+$side) $headJoint;
	}
if ($bindSkin)
	{
	string $bindToSkinCluster=$skinCluster;
	skinCluster -e -ai ($name+"Joint"+$side) -lw false -wt 0 $skinCluster;
	}


//Attach
string $tempString[]=`listRelatives -ni -s $geometry`;
if (!`objExists closestSampler`)
	createNode -n closestSampler closestPointOnMesh;
if (!`isConnected ($tempString[0]+".outMesh") closestSampler.inMesh`)
	connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
if (!`isConnected ($geometry+".worldMatrix[0]") closestSampler.inputMatrix`)
	connectAttr -f ($geometry+".worldMatrix[0]") closestSampler.inputMatrix;

setAttr -type float3 closestSampler.inPosition ($attachPos[0]*$b) $attachPos[1] $attachPos[2];
string $vtx=`getAttr closestSampler.result.closestVertexIndex`;
delete closestSampler;
select ($geometry+".vtx["+$vtx+"]");
ConvertSelectionToEdges;
string $edges[]=`ls -sl -fl`;
select $edges[0];
$tempString=`duplicateCurve -ch 1 -rn 0 -local 0`;
string $dupCurve=$tempString[0];
rename $dupCurve ($name+"Curve"+$side);
rename $tempString[1] ($name+"CurveEdge"+$side);
setAttr -l 1 ($name+"Curve"+$side+".v") 0;
parent ($name+"Curve"+$side) ClusterSetup;
createNode -n ($name+"PointOnCurveInfo"+$side) pointOnCurveInfo;
setAttr ($name+"PointOnCurveInfo"+$side+".turnOnPercentage") 1;
connectAttr -f ($name+"Curve"+$side+"Shape.worldSpace[0]") ($name+"PointOnCurveInfo"+$side+".inputCurve");
//determine PointOnCurveInfo.parameter
float $tempFloatA[]=`xform -q -ws -t ($name+$side)`;
float $tempFloatB[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAB=`mag<<$tempFloatA[0]-$tempFloatB[0],$tempFloatA[1]-$tempFloatB[1],$tempFloatA[2]-$tempFloatB[2]>>`;
setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 1;
float $tempFloatC[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAC=`mag<<$tempFloatA[0]-$tempFloatC[0],$tempFloatA[1]-$tempFloatC[1],$tempFloatA[2]-$tempFloatC[2]>>`;
if ($magAB<$magAC)
	setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 0;

//avoid double Xform
createNode -n ($name+"PlusMinusAverage"+$side) plusMinusAverage;
setAttr ($name+"PlusMinusAverage"+$side+".operation") 2;
connectAttr -f ($name+"PointOnCurveInfo"+$side+".position") ($name+"Attach"+$side+".t");
connectAttr -f Brs.r ($name+"Attach"+$side+".r");
connectAttr -f Brs.s ($name+"Attach"+$side+".s");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[1]");
disconnectAttr ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
parent -w ($name+"Offset"+$side);
connectAttr -f ($name+"PlusMinusAverage"+$side+".output3D") ($name+"Subtract"+$side+".t");
xform -ws -t ($controlPos[0]*$b) $controlPos[1] $controlPos[2] ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);

if ($createJoint)
	{
	connectAttr ($name+$side+".tx") ($name+"Joint"+$side+".tx");connectAttr ($name+$side+".ty") ($name+"Joint"+$side+".ty");connectAttr ($name+$side+".tz") ($name+"Joint"+$side+".tz");
	connectAttr ($name+$side+".rx") ($name+"Joint"+$side+".rx");connectAttr ($name+$side+".ry") ($name+"Joint"+$side+".ry");connectAttr ($name+$side+".rz") ($name+"Joint"+$side+".rz");
	connectAttr ($name+$side+".sx") ($name+"Joint"+$side+".sx");connectAttr ($name+$side+".sy") ($name+"Joint"+$side+".sy");connectAttr ($name+$side+".sz") ($name+"Joint"+$side+".sz");
	}
select -cl;
refresh;
}

global proc string lipLetterClosestToCenterInY (string $upperLower)
{
string $letter;
string $tempString[]=`ls -type joint ($upperLower+"LipMiddle*0_M")`;
string $closestJoint=$tempString[0];
float $minValue=999;
float $centerPos[]=`xform -q -ws -t ($upperLower+"LipCenter0_M")`;
for ($i=0;$i<size($tempString);$i++)
	{
	float $pos[]=`xform -q -ws -t $tempString[$i]`;
	float $absY=abs($centerPos[1]-$pos[1]);
	if ($absY<$minValue)
		{
		$minValue=$absY;
		$closestJoint=$tempString[$i];
		}
	}
$tempString[0]=`substitute ($upperLower+"LipMiddle") $closestJoint ""`;
$letter=`substitute "0_M" $tempString[0] ""`;
return $letter;
}

global proc softCluster (string $trnPos, string $name, int $b, string $side)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
//string $jawJoint=`textField -q -tx asFaceJawJointTextField`;
string $jawControl="Jaw_M";
float $falloffRadius=`getAttr ($name+".falloffRadius")`;
float $falloffMode=`getAttr ($name+".falloffMode")`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

select $allFaceGeo;
float $scale=`asFaceGetScale`/3.0;
float $pos[3]=`xform -q -ws -t $trnPos`;
float $tempFloat[];
int $numVtxs[];
int $infNr;
float $value;
float $skinPercents[];
string $skinClusterInfs[];
string $oppositeSide;
select -r $geometry;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ($name+"SoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($name+"SoftModHandle"+$side)`;
$tempString=`listConnections ($name+"SoftMod"+$side+".message")`;
string $softModSet=`rename $tempString[0] ($name+"SoftModSet"+$side)`;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

asPingPong $name $name $b $side 8 0 0;
//setAttr ($name+$side+"Shape.overrideColor") `getAttr ($name+".overrideColor")`;
parent ($name+"Attach"+$side) Acontrols;

setAttr -type float3 ($softModHandle+".t") 1 0 0;
//softMod -e -pr fails in batch, when affecting multiple meshes
//no longer pruning , as this gets tricky when user want to paint outside prune area
//if (`getAttr ($name+".overrideColor")`!=9)
//	softMod -e -pr $softMod;
//changed:trying to bring back -pruning
	dgdirty -a;
if (`getAttr ($name+".overrideColor")`!=9) // Prune softMode does not work well with multiAffectedObjects
	softMod -e -pr $softMod;
$tempString=`listConnections ($softMod+".message")`;
select `sets -q $tempString[0]`;
string $vtxs[]=`ls -sl -fl`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;

$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
string $cluster=$tempString[0];
string $clusterHandle=$tempString[1];
$tempString=`listRelatives -s $clusterHandle`;
string $clusterHandleShape=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].inputGeometry")`;
string $clusterGroupParts=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].groupId")`;
string $clusterGroupId=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
parent $clusterHandle ClusterSetup;
setAttr -type float3 ($clusterHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $clusterHandle;

asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;

setAttr -l 1 ($clusterHandle+".v") 0;
connectAttr ($name+$side+".t") ($clusterHandle+".t");
connectAttr ($name+$side+".r") ($clusterHandle+".r");
connectAttr ($name+$side+".s") ($clusterHandle+".s");

catch (`reorderDeformers $skinCluster $cluster $geometry`);
catch (`reorderDeformers asFaceBS $cluster $geometry`);

if (`getAttr ($name+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!=$geometry)
			{
			int $haveSkinCluster=0;
			$historyNodes=`listHistory -pdo 1 $allFaceGeo[$i]`;
			for ($y=0;$y<size($historyNodes);$y++)
				if (`nodeType $historyNodes[$y]`=="skinCluster")
					{
					$haveSkinCluster=1;
					$skinCluster=$historyNodes[$y];
					}
			if ($haveSkinCluster)
				catch (`reorderDeformers $skinCluster $cluster $allFaceGeo[$i]`);
			}
	}
}

global proc asFaceSoftModToCluster (string $softMod, string $cluster, string $vtxs[])
{
string $tempString[]=`listConnections ($softMod+".matrix")`;
string $softModHandle=$tempString[0];
setAttr ($softModHandle+".ty") 1;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
string $componentType="vtx";

string $deformMeshs[]=`ls -o $vtxs`;
$deformMeshs=`stringArrayRemoveDuplicates $deformMeshs`;
string $deformXforms[];
for ($i=0;$i<size($deformMeshs);$i++)
	{
	$tempString=`listRelatives -p $deformMeshs[$i]`;
	$deformXforms[$i]=$tempString[0];
	}
setAttr ($softMod+".envelope") 0;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshA"+$i) $deformMeshs[$i];
setAttr ($softMod+".envelope") 1;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshB"+$i) $deformMeshs[$i];
float $sofModDefaultPos[3]=`xform -q -os -piv $softModHandle`;
float $posA[3];
float $posB[3];
for ($i=0;$i<size($deformMeshs);$i++)
    {
		$componentType="vtx";
		if (`objectType $deformMeshs[$i]`=="lattice")
			$componentType="pt";
    string $historyNodes[]=`listHistory $deformMeshs[$i]`;
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 1;
    percent -v 0 $cluster ($deformMeshs[$i]+"."+$componentType+"[0:999999]");
    for ($y=0;$y<size($vtxs);$y++)
        {
        if (!`gmatch $vtxs[$y] ($deformXforms[$i]+"[.]"+$componentType+"*")`)
            continue;
        tokenize $vtxs[$y] "." $tempString;
        $posA=`xform -q -ws -t ("tempMeshA"+$i+"."+$tempString[1])`;
        $posB=`xform -q -ws -t ("tempMeshB"+$i+"."+$tempString[1])`;
        percent -v ($posB[1]-$posA[1]) $cluster $vtxs[$y];
        }
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 0;
     }
for ($i=0;$i<size($deformMeshs);$i++)
	delete ("tempMeshA"+$i) ("tempMeshB"+$i);
clear $vtxs;
}

global proc string asFaceMirror ()
{
string $restoreCmd,$oppositeControl;
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;
string $mirrorAttrs[]={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
string $controls[]=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	if (!`gmatch $controls[$i] "*_L"`)
		continue;
	for ($attr in $mirrorAttrs)
		{
		if (`getAttr -l ($controls[$i]+"."+$attr)`)
			continue;
		$oppositeControl=`substitute "_L" $controls[$i] "_R"`;
		$multiply=1;
		if ($attr=="tx" || $attr=="ry" || $attr=="rz")
			$multiply=-1;
	
		$restoreCmd+="setAttr "+$controls[$i]+"."+$attr+" "+`getAttr ($controls[$i]+"."+$attr)`+";";
		setAttr ($controls[$i]+"."+$attr) (`getAttr ($oppositeControl+"."+$attr)`*$multiply);
		}
	}
if ($autoKeyState)
	$restoreCmd+="autoKeyframe -state 1;";
return $restoreCmd;
}

global proc asFaceMirrorControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";
$tempString=`listConnections ($sel[0]+".s")`;
float $pos[]=`getAttr ($sel[0]+".t")`;
float $rot[]=`getAttr ($sel[0]+".r")`;
float $sca[]=`getAttr ($sel[0]+".s")`;
	asGoToBuildPose faceSetup;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	print "// Detected this controller to control a \"Cluster\", performing Mirror Cluster Weights\n";
	asFaceMirrorClusterWeight;
	}
else
	{
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	print "Detected this controller to control a \"Joint\", performing Mirror Skin Weights";
	}
setAttr -type float3 ($sel[0]+".t") $pos[0] $pos[1] $pos[2];
setAttr -type float3 ($sel[0]+".r") $rot[0] $rot[1] $rot[2];
setAttr -type float3 ($sel[0]+".s") $sca[0] $sca[1] $sca[2];
select $sel;
}

global proc asFaceMirrorClusterWeight ()
{
string $sel[]=`ls -sl`;
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a faceControl";
string $control=$sel[0];

string $restorePoseCmd;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $multiply;
int $numVtxs[]=`polyEvaluate -v $geometry`;
float $maxDist,$mag;
float $posA[3],$posB[3],$tempFloat[];
string $tempString[],$rightVtxs[];
string $cluster=`substitute "_R" $control "Cluster_R"`;
string $oppositeControl=`substitute "_R" $control "_L"`;
string $oppositeCluster=`substitute "_R" $cluster "_L"`;
if (!`gmatch $control "*_R"` || !`objExists $oppositeCluster`)
	return;
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$cluster+"Set";
string $oppositeClusterSet=`substitute "_R" $clusterSet "_L"`;
if (!`objExists $oppositeClusterSet`)
	return;

//Start off by pruning
setAttr -type float3 ($control+".t") 1 0 0;
cluster -e -pr $cluster;
setAttr -type float3 ($control+".t") 0 0 0;

//Mirror pose before doing left to ensure identical attachment
string $restoreCmd=`asFaceMirror`;

percent -v 0 $oppositeCluster ($geometry+".vtx[0:"+$numVtxs[0]+"]");
select `sets -q ($cluster+"Set")`;
$rightVtxs=`ls -sl -fl`;
$posA=`xform -q -ws -t $control`;
$maxDist=0;
for ($i=0;$i<size($rightVtxs);$i++)
	{
	$posB=`xform -q -ws -t $rightVtxs[$i]`;
	$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>$maxDist)
		$maxDist=$mag;
	}
$maxDist=$maxDist+($maxDist/20.0);

select $geometry;
sets -add ($oppositeCluster+"Set") $geometry;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp ($posA[0]*-1) $posA[1] $posA[2];
string $vtxs[]=`ls -sl -fl`;
polySelectConstraint -m 0;
//sets -add ($oppositeCluster+"Set") $vtxs;
createNode -n closestSampler closestPointOnMesh;
$tempString=`listRelatives -ni -s $geometry`;
connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
connectAttr -f ($geometry+".worldMatrix[0]") closestSampler.inputMatrix;
int $closestOppositeVtxNr;
global string $gMainProgressBar;
progressBar -e -st ("Mirroring Cluster for: "+$control) -bp -ii 1 -min 0 -max `size($vtxs)` $gMainProgressBar;
for ($i=0;$i<size($vtxs);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		break;
	progressBar -e -s 1 $gMainProgressBar;
	$posB=`xform -q -ws -t $vtxs[$i]`;
	setAttr -type float3 closestSampler.inPosition ($posB[0]*-1) $posB[1] $posB[2];
	$closestOppositeVtxNr=`getAttr closestSampler.result.closestVertexIndex`;
	$tempFloat=`percent -q -v $cluster ($geometry+".vtx["+$closestOppositeVtxNr+"]")`;

	if (!`sets -im $clusterSet ($geometry+".vtx["+$closestOppositeVtxNr+"]")`)
		$tempFloat[0]=0;

	percent -v $tempFloat[0] $oppositeCluster $vtxs[$i];
	}
progressBar -e -ep $gMainProgressBar;
setAttr -type float3 ($oppositeControl+".t") 1 1 1;
cluster -e -pr $oppositeCluster;
setAttr -type float3 ($oppositeControl+".t") 0 0 0;
delete closestSampler;

eval ($restoreCmd);
}

global proc int [] asFaceSelVtxIntArray ()
{
int $intArray[];
string $tempString[];
string $sel[]=`ls -sl -fl`;
for ($i=0;$i<size($sel);$i++)
	{
	tokenize $sel[$i] "[" $tempString;
	$intArray[$i]=`substitute "]" $tempString[1] ""`;
    	}
return $intArray;
}

global proc asHelpImage (string $region)
{
string $asScriptLocation=`asGetScriptLocation`;
if (`window -q -ex faceHelpImage`)
	deleteUI faceHelpImage;
window faceHelpImage;
scrollLayout -w 666 -h 10;

if (`gmatch $region "*asBSWizardStep*"`)
	$region="asBSWizard/"+$region;

formLayout asHelpFormLayout;
image -i ($asScriptLocation+"/AdvancedSkeleton5Files/div/images/help/"+$region+".jpg") asHelpImage;
if (`gmatch $region "*asBSWizardStep*"`)
	button -l "Toggle Default" -c asFaceTglDefault;

formLayout -e
	-af asHelpImage "right" 0
	-af asHelpImage "left" 0
	-af asHelpImage "top" 0
	-af asHelpImage "bottom" 0
	asHelpFormLayout;

//Video Link
string $helpUrl;
string $buttonLabel="Open Video Link";
if ($region=="asDeformSkinCageSliders")
	$helpUrl="https://youtu.be/uMaKwxKXygw";
if ($region=="asDeformSkinCageDWidth")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=153";
if ($region=="asDeformSubWrapCage" || $region=="asDeformSubWrapWrap")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=280";
if ($region=="asDeformSkinLoopsCreate" || $region=="asDeformSkinLoopsSelectAll"
	|| $region=="asDeformSkinLoopsBind" || $region=="asDeformSkinLoopsCutUp")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=151";
if ($region=="asMotionCaptureReadBvh" || $region=="asMotionCaptureConnect")
	{
	$helpUrl="https://sites.google.com/a/cgspeed.com/cgspeed/motion-capture/cmu-bvh-conversion";
	$buttonLabel="Open Link";
	}
if ($region=="asCorrectiveShapesCreate")
	$helpUrl="https://youtu.be/YOIyFB2nK90";
if ($region=="asCorrectiveShapesBake")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=327";
if ($region=="faceFitSkeletonNode")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=357";
if ($region=="asEditBlendShapesCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=663";
if ($region=="asTweakControllersCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=743";
if ($region=="asSelectorDesigner")
	$helpUrl="https://youtu.be/0dpLmKZbEJc";
if ($region=="asPoserDesigner")
	{
	$helpUrl="http://www.studiolibrary.com/";
	$buttonLabel="Open Link";
	}
if ($region=="asWalkDesigner")
	$helpUrl="https://youtu.be/jMTfxKArl1Q";

if ($helpUrl!="")
	{
	string $button=`button -w 200 -h 50 -l $buttonLabel -c ("showHelp -a \""+$helpUrl+"\"")`;
	formLayout -e
		-af $button "top" 715
		-af $button "left" 220
		asHelpFormLayout;
	}
showWindow;
window -e -h 808 faceHelpImage;
}

global proc asFaceTglDefault ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $curImage=`image -q -i asHelpImage`;
string $ann=`image -q -ann asHelpImage`;
if (!`gmatch $curImage "*asBSWizardStep*[0-9][.]*"`)
	return;
if ($ann=="")
	{
	image -e -ann $curImage asHelpImage;
	image -e -i ($asScriptLocation+"/AdvancedSkeleton5Files/div/images/help/asBSWizard/asBSWizardStep0.jpg") asHelpImage;
	}
else
	{
	image -e -ann "" asHelpImage;
	image -e -i $ann asHelpImage;
	}
}

global proc asFaceSquintByLattice ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $dist;
float $scale=`asFaceGetScale`;
float $pos[],$pos2[];
string $tempString[];
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	duplicate -rr -n ("eye_squint"+$side) $geometry;
	parent ("eye_squint"+$side) faceTargets;
	$tempString=`listRelatives -s ("eye_squint"+$side)`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];

	select ("eye_squint"+$side);
	$tempString=`lattice  -divisions 3 4 4 -objectCentered true  -ldv 2 2 2`;
	string $ffd=$tempString[0];
	string $lattice=$tempString[1];
	string $latticeBase=$tempString[2];

	$pos=`xform -q -ws -t FitEyeBall`;
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $lattice;
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $latticeBase;
	delete `scaleConstraint FitEyeBall $lattice`;
	delete `scaleConstraint FitEyeBall $latticeBase`;
	scale -r 2 2 2 $lattice;
	scale -r 2 2 2 $latticeBase;
	setAttr ($lattice+".sx") ($pos[0]*4*$b);
	setAttr ($latticeBase+".sx") ($pos[0]*4*$b);
 	select ($lattice+".pt[1:2][1:2][2]");
	scale -r -p $pos[0] $pos[1] $pos[2] 1 0.2 1 ;
	$pos=`xform -q -ws -t ($lattice+".pt[0][2][3]")`;
	$pos2=`xform -q -ws -t ($lattice+".pt[0][1][3]")`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	move -r 0 0 ($dist*0.2); 
	select ("eye_squint"+$side);
	DeleteHistory;
//	blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` ("eye_squint"+$side) 1 asFaceBS;
	}
}

global proc asFaceBsSdk (string $ctrl, float $driveValue, string $bs, float $drivenValue)
{
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl $driveValue;
setAttr $bs $drivenValue;
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl 0;
if ($driveValue>0)
	keyTangent -in 0 -itt linear -ott linear $bs;

//pre post infinity
string $nodes[]=`listConnections -s 1 -d 0 -scn 1 $bs`;
for ($i=0;$i<size($nodes);$i++)
	{
	$tempString=`nodeType -inherited $nodes[$i]`;
	if ($tempString[0]=="animCurve")
		{
		setAttr ($nodes[$i]+".preInfinity") 4;
		setAttr ($nodes[$i]+".postInfinity") 4;
		}
	}
}

global proc float[] asGetMidHeadPos ()
{
float $midHeadPos[];
//first look for joints, as the fig might be from before faceFitScaleCurve came about
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $headPos[]=`xform -q -ws -t $headJoint`;
string $tempString[]=`listRelatives -c $headJoint`;
if(size($tempString))
	{
	$temp=`xform -q -ws -t $tempString[0]`;
	$midHeadPos[0]=(($headPos[0]+$temp[0])/2.0);
	$midHeadPos[1]=(($headPos[1]+$temp[1])/2.0);
	$midHeadPos[2]=(($headPos[2]+$temp[2])/2.0);
	}
if (`objExists FaceFitSkeletonHeightShape`)
	{
	float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
	float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
	$midHeadPos={$headPos[0],($pos1[1]+$pos2[1])/2.0,$headPos[2]};
	}

return $midHeadPos;
}

global proc asFaceCtrlBox ()
{
if (`objExists ctrlBoxOffset`)
	delete ctrlBoxOffset;
float $scale=`asFaceGetScale`/3.0;
float $temp[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $midHeadPos[]=`asGetMidHeadPos`;
float $boxTZ=($midHeadPos[2]+($scale*1.3));
if (`objExists FitEyeBall`)
	{
	$temp=`xform -q -ws -t FitEyeBall`;
	$boxTZ=$temp[2];
	}

//setAttr FaceFitSkeletonShape.v 0;
//setAttr FaceFitSkeletonHeightShape.v 0;

$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBox;
createNode -n ctrlBoxOffset transform;
parent ctrlBox ctrlBoxOffset;
parent ctrlBoxOffset FaceMotionSystem;
parentConstraint -mo $headJoint ctrlBoxOffset;
scaleConstraint -mo $headJoint ctrlBoxOffset;
addAttr -k 1 -ln "limits" -at bool -dv true ctrlBox;
setAttr ctrlBoxShape.overrideEnabled 1;
setAttr ctrlBoxShape.overrideColor 17;

//Expand length down
move -r 0 -0.4 0 ctrlBoxShape.cv[2:3];
xform -ws -t ($scale*1.8) ($midHeadPos[1]-(0.3*$scale)) $boxTZ ctrlBox;
xform -s ($scale/2.0) $scale ($scale/2.0) ctrlBox;
makeIdentity -a 1 -t 0 -r 0 -s 1 ctrlBox;

//ctrlBoxTemplate
$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBoxTemplate;
parent ctrlBoxTemplate ctrlBox;
setAttr -type float3 ctrlBoxTemplate.t 0 0 0;
setAttr -type float3 ctrlBoxTemplate.s ($scale/6.0) ($scale/6.0) ($scale/6.0);
setAttr ctrlBoxTemplateShape.overrideEnabled 1;
setAttr ctrlBoxTemplateShape.overrideDisplayType 2;

//ctrlTemplate
duplicate -n ctrlTemplate ctrlBoxTemplate;
parent ctrlTemplate ctrlBoxTemplate;
transformLimits -tx -1 1 -ty -1 1 -tz 0 0 -etx 1 1 -ety 1 1 -etz 1 1 ctrlTemplate;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransYLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransYLimitEnable`);
setAttr ctrlTemplateShape.overrideDisplayType 0;
setAttr ctrlTemplate.rz 45;
setAttr -type float3 ctrlTemplate.s 0.2 0.2 0.2;
setAttr ctrlTemplateShape.overrideColor 17;
makeIdentity -a 1 -t 0 -r 1 -s 1 ctrlTemplate;
setAttr -l 1 -k 0 ctrlTemplate.tz;
setAttr -l 1 -k 0 ctrlTemplate.rx;
setAttr -l 1 -k 0 ctrlTemplate.ry;
setAttr -l 1 -k 0 ctrlTemplate.rz;
setAttr -l 1 -k 0 ctrlTemplate.sx;
setAttr -l 1 -k 0 ctrlTemplate.sy;
setAttr -l 1 -k 0 ctrlTemplate.sz;
setAttr -l 1 -k 0 ctrlTemplate.v;
sets -add FaceControlSet ctrlTemplate;

asFaceCreateCtrlBox "Brow_R" ($scale*-0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Brow_L" ($scale*0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Eye_R" ($scale*-0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Eye_L" ($scale*0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Cheek_R" ($scale*-0.25) 0 1;
asFaceCreateCtrlBox "Cheek_L" ($scale*0.25) 0 1;
asFaceCreateCtrlBox "Nose_R" ($scale*-0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Nose_L" ($scale*0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Mouth_M" 0 ($scale*-0.4) 2;
asFaceCreateCtrlBox "MouthCorner_R" ($scale*-0.25) ($scale*-1) 0;
asFaceCreateCtrlBox "MouthCorner_L" ($scale*0.25) ($scale*-1) 0;
scale -r 2 2 2 ctrlBoxMouth_M;
asFaceCreateCtrlBox "Tongue_M" 0 ($scale*-1.3) 2;
setAttr "ctrlBoxTongue_MShape.overrideVisibility" 0;
setAttr -l 1 -k 0 ctrlTongue_M.tx;
setAttr -l 1 -k 0 ctrlTongue_M.ty;

string $ctrls[]=`listRelatives -type transform -c ctrlBox`;
for ($i=0;$i<size($ctrls);$i++)
	setAttr ($ctrls[$i]+".v") 0;

addAttr -k 1 -ln "ACtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.ACtrlVis Acontrols.v;
addAttr -k 1 -ln "BCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.BCtrlVis Bcontrols.v;
addAttr -k 1 -ln "CCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.CCtrlVis Ccontrols.v;
addAttr -k 1 -ln "AimCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.AimCtrlVis Aimcontrols.v;
addAttr -k 1 -ln "SquashCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "RubberCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "RenderSpheres" -at bool -dv true ctrlBox;

delete ctrlBoxTemplate;
}

global proc asFaceCreateCtrlBox (string $name, float $x, float $y, int $half)
{
$tempString=`duplicate -rc ctrlBoxTemplate`;
rename $tempString[0] ("ctrlBox"+$name);
rename $tempString[1] ("ctrl"+$name);
setAttr -type float3 ("ctrlBox"+$name+".t") $x $y 0;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransYLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransYLimitEnable")`);

if ($half)
	{
	float $pos0[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[0]")`;
	float $pos2[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[2]")`;
	float $pos3[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[3]")`;
	if ($half==1)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[2]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos3[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[3]");
		transformLimits -tx -1 1 -ty 0 1 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	if ($half==2)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[1]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[0]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[4]");
		transformLimits -tx -1 1 -ty -1 0 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	}
}

global proc asKeepBlendShapes ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;

createNode -n keepTweakedBlendShapes transform;
setAttr keepTweakedBlendShapes.v 0;
string $udas[]=`listAttr -ud FaceFitSkeleton`;
string $keepShps[];
for ($i=0;$i<size($udas);$i++)
	{
	if (`gmatch $udas[$i] "*_tweaked"`)
		if (`getAttr ("FaceFitSkeleton."+$udas[$i])`)
			$keepShps[size($keepShps)]=`substitute "_tweaked" $udas[$i] ""`;
	}
for ($i=0;$i<size($keepShps);$i++)
	{
	setAttr ("asFaceBS."+$keepShps[$i]) 1;
	duplicate -n ($keepShps[$i]+"_tweaked") $geometry;
	parent ($keepShps[$i]+"_tweaked") keepTweakedBlendShapes;
	setAttr ("asFaceBS."+$keepShps[$i]) 0;
	}
}

global proc asRemoveInfluence (string $joint, string $skinCluster)
{
string $infJoints[]=`listConnections -s 1 -d 0 ($skinCluster+".matrix")`;
if (`stringArrayCount $joint $infJoints`)
	skinCluster -e -ri $joint $skinCluster;
}

global proc asBuildFitEyeBall ()
{
string $righEyeGeoText=`textField -q -tx asFaceEye_RTextField`;
if ($righEyeGeoText=="")
	error "No Eye Geometry choosen";
if (`objExists FitEyeBall`)
	error "FitEyeBall already exists";
int $hadBodyEye=0;
float $pos[],$rot[];
if (`objExists FKEye_R`)
	{
	$dialog=`confirmDialog -t "Confirm"
		-m "This will replace the Eyes from the Body-setup"
		-b "OK" -db "OK"
		-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		return;
	$hadBodyEye=1;
	string $skinClusters[]=`ls -type skinCluster`;
	for ($i=0;$i<size($skinClusters);$i++)
		{
		if (`objExists Eye_R`) asRemoveInfluence Eye_R $skinClusters[$i];
		if (`objExists Eye_L`) asRemoveInfluence Eye_L $skinClusters[$i];
		}
	$pos=`xform -q -ws -t Eye_R`;
	$rot=`xform -q -ws -ro Eye_R`;
	if (`objExists FKOffsetEye_R`) delete FKOffsetEye_R;
	if (`objExists FKOffsetEye_L`) delete FKOffsetEye_L;
	if (`objExists FKAimEye_R`) delete FKAimEye_R;
	if (`objExists FKAimEye_L`) delete FKAimEye_L;
	if (`objExists Eye_R`)delete Eye_R;
	if (`objExists Eye_L`) delete Eye_L;
	if (`objExists AimEye`) delete AimEye;
	if (`objExists Eye`) delete Eye;
	asRemoveUnusedfromBuildPose bodySetup;
	}
float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
if (!`objExists $headJoint`)
	error ("HeadJoint:\""+$headJoint+"\" not found");
asFitModeEnsureShaders;
spaceLocator -n FitEyeBall;
setAttr FitEyeBall.rotateOrder 2;
setAttr -type float3 FitEyeBallShape.localScale 1.5 1.5 1.5;
createNode -n FaceFitEyeBall -p FaceFitSkeleton transform;
parent FitEyeBall FaceFitEyeBall;
polySphere -n FitEyeSphere -r 0.5 -sx 8 -sy 8 -ax 0 1 0 -cuv 2 -ch 0;
setAttr FitEyeSphere.overrideEnabled 1;
setAttr FitEyeSphere.overrideDisplayType 2;
parent FitEyeSphere FitEyeBall;
sets -e -forceElement asWhiteSG FitEyeSphere;
sets -e -forceElement asBlackSG FitEyeSphere.f[56:63];
setAttr FitEyeSphere.rz -90;
setAttr -type float3 FitEyeBall.s (0.025*$height) (0.025*$height) (0.025*$height);

if ($hadBodyEye)
	{
	xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] FitEyeBall;
	}
else
	{
	$pos=`xform -q -ws -t $headJoint`;
	xform -ws -t $pos[0] $pos[1] $pos[2] FitEyeBall;
	setAttr -type float3 FitEyeBall.t ($pos[1]/-50.0) ($pos[1]/15.0) ($pos[1]/15.0);
	setAttr FitEyeBall.ry -90;
	}

//guestimate placement (and scale) based upon 1st selected geo
string $tempString[],$tempString2[],$eyeGeos[];
tokenize $righEyeGeoText $tempString;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*[.]*"`)
		$eyeGeos[size($eyeGeos)]=$tempString[$i];
if (size($eyeGeos))
	{
	$tempString=`duplicate -n tempEye $eyeGeos[0]`;
	$tempString2=`listRelatives -p $tempString[0]`;
	if ($tempString2[0]!="")
		$tempString=`parent -w $tempString[0]`;
	select $tempString[0];
	CenterPivot;
	float $pos[]=`xform -q -ws -piv $tempString[0]`;
	float $bb[]=`xform -q -bb $tempString[0]`;
	delete $tempString[0];
	if ($pos[1]>0)
		{
		parent -w FitEyeBall;
		if (!$hadBodyEye)
			xform -ws -t $pos[0] $pos[1] $pos[2] FitEyeBall;
		xform -os -s ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) FitEyeBall;
		parent FitEyeBall FaceFitEyeBall;
		}
	}


select FitEyeBall;
print ("// FitEyeBall created, place this to match the eye-ball of your character\n");
checkBox -e -ed 1 -v 1 asFaceEyeBall;
}

global proc asConnectTongueControl ()
{
string $tempString[];
string $axis,$connectTo;
for ($i=0;$i<3;$i++)
	{
	if ($i==0) $axis="X";
	if ($i==1) $axis="Y";
	if ($i==2) $axis="Z";
	for ($y=1;$y<4;$y++)
		{
		if (!`attributeExists ("rot"+$axis+$y) ctrlTongue_M`)
			addAttr -ln ("rot"+$axis+$y) -k 1 ctrlTongue_M;
		if (!`objExists ("faceRigTongue"+$y+"_M")`)
			continue;
		$connectTo="faceRigTongue"+$y+"_M.r"+`tolower $axis`;
		$tempString=`listConnections $connectTo`;
		if (!size($tempString))
			connectAttr ("ctrlTongue_M.rot"+$axis+$y) $connectTo;
		}
	}
for ($i=0;$i<3;$i++)
	{
	if ($i==0) $axis="X";
	if ($i==1) $axis="Y";
	if ($i==2) $axis="Z";
	if (!`attributeExists ("size"+$axis) ctrlTongue_M`)
		addAttr -ln ("size"+$axis) -dv 1 -k 1 ctrlTongue_M;
	for ($y=1;$y<4;$y++)
		{
		if (!`objExists ("faceRigTongue"+$y+"_M")`)
			continue;
		$connectTo="faceRigTongue"+$y+"_M.s"+`tolower $axis`;
		$tempString=`listConnections $connectTo`;
		if (!size($tempString))
			connectAttr ("ctrlTongue_M.size"+$axis) ($connectTo);
		}
	}
select -cl;
}

global proc asFaceEnsureFitBase ()
{
if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;
}

global proc asFaceEnsureShaders ()
{
string $colors[]={"asFaceBlue","asFaceBrown","asFaceGreen","asFaceCyan","asFaceRed"};
float $rs[]={0.0,0.541,0.000,0.0,0.4};
float $gs[]={0.0,0.282,0.275,0.5,0};
float $bs[]={1.0,0.200,0.098,0.5,0};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".ambientColor") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".incandescence") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asFaceEnsureAdvancedBase ()
{
asFaceEnsureShaders;
string $sel[]=`ls -sl`;
if (!`objExists FaceGroup`)
	error "FaceGroup does not exists, must build a Fit-system first";
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
if (!`objExists $headJoint`)
	error ("HeadJoint: \""+$headJoint+"\" Does not exists");
if (`objExists FaceMotionSystem`)
	setAttr FaceMotionSystem.v 1;
if (`objExists FaceMotionSystem`)
	return;

string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

//enable the GoTOBuildPose for Face button, part 1
int $hadFaceSetup=`objExists FaceMotionSystem`;

//top level nodes
createNode -n FaceMotionSystem -p FaceGroup transform;
createNode -n FaceDeformationSystem -p FaceGroup transform;
createNode -n ControlsSetup -p FaceMotionSystem transform;
createNode -n Acontrols transform;
createNode -n Bcontrols transform;
createNode -n Ccontrols transform;
createNode -n Aimcontrols transform;
parent Acontrols Bcontrols Ccontrols Aimcontrols ControlsSetup;

select FaceDeformationSystem;
joint -n FaceAttachToHead;
setAttr -l 1 FaceAttachToHead.v 0;
asAlign FaceAttachToHead $headJoint 1 0 0 0;
setAttr -type float3 FaceAttachToHead.jointOrient 90 0 90;
parentConstraint -mo $headJoint FaceAttachToHead;
scaleConstraint $headJoint FaceAttachToHead;
skinCluster -e -ai FaceAttachToHead -lw false -wt 0 $skinCluster;

//faceBuildPose
if (!`objExists faceBuildPose`)
	{
	createNode -n faceBuildPose dagPose;
	addAttr -ln udAttr -dt "string"  faceBuildPose;
	}

//Sets
select -cl;
sets -name FaceAllSet;
sets -name FaceControlSet;
if (`objExists "Sets"`)
	{
	sets -add "Sets" FaceAllSet;
	sets -add "Sets" FaceControlSet;
	}

//enable the GoTOBuildPose for Face button, part 2
if (!$hadFaceSetup)
	asUpdateButtonEnables;;

asFaceCtrlBox;
select $sel;
}

global proc asAdvancedSquash ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`/3.0;
float $value,$min,$max;
float $pos[3],$pos2[3];
string $name;
string $tempString[],$allFaceGeo[],$historyNodes[],$infs[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
string $allBefore[]=`ls`;

//squashHead
float $squashTopPos[3]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
float $squashBasePos[3]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
float $BaseToTopY=$squashTopPos[1]-$squashBasePos[1];

createNode -n SquashSetup -p FaceMotionSystem transform;
$tempString[0]=`curve -d 1 -p 1 1 1 -p 1 -1 1 -p -1 -1 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p -1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
rename $tempString[0] squashTop_M;
setAttr squashTop_MShape.overrideEnabled 1;
setAttr squashTop_MShape.overrideColor 13;
createNode -n squashTopOffset transform;
parent squashTop_M squashTopOffset;
xform -ws -t 0 $squashTopPos[1] 0 squashTopOffset;
xform -ws -s ($scale/0.75) ($scale/5.0) ($scale/5.0) squashTop_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashTop_M;
sets -add "FaceControlSet" squashTop_M;
duplicate -n SquashControls squashTopOffset;
rename SquashControls|squashTop_M squashBase_M;
xform -ws -t 0 $squashBasePos[1] 0 SquashControls;
duplicate -n squashMiddleOffset squashTopOffset;
rename squashMiddleOffset|squashTop_M squashMiddle_M;
xform -ws -t 0 (($squashBasePos[1]+$squashTopPos[1])/2) 0 squashMiddleOffset;
scale -r 1.5 1 1 squashMiddle_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashMiddle_M;
parent squashTopOffset squashMiddleOffset squashBase_M;

addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 squashTop_M;
createNode -n squashTopVolumeUC unitConversion;
setAttr squashTopVolumeUC.conversionFactor 0.1;
connectAttr squashTop_M.volume squashTopVolumeUC.input;

setAttr -l 1 -k 0 squashTop_M.rx;setAttr -l 1 -k 0 squashTop_M.ry;setAttr -l 1 -k 0 squashTop_M.rz;
setAttr -l 1 -k 0 squashTop_M.sx;setAttr -l 1 -k 0 squashTop_M.sy;setAttr -l 1 -k 0 squashTop_M.sz;
setAttr -l 1 -k 0 squashTop_M.v;
setAttr -l 1 -k 0 squashMiddle_M.rx;setAttr -l 1 -k 0 squashMiddle_M.ry;setAttr -l 1 -k 0 squashMiddle_M.rz;
setAttr -l 1 -k 0 squashMiddle_M.sx;setAttr -l 1 -k 0 squashMiddle_M.sy;setAttr -l 1 -k 0 squashMiddle_M.sz;
setAttr -l 1 -k 0 squashMiddle_M.v;
setAttr -l 1 -k 0 squashBase_M.sx;setAttr -l 1 -k 0 squashBase_M.sy;setAttr -l 1 -k 0 squashBase_M.sz;
setAttr -l 1 -k 0 squashBase_M.v;

select $allFaceGeo;
//Do not include wrapped on`s  (e.g eyebrows)
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$historyNodes=`listHistory -f 0 -pruneDagObjects 1 -lv 4 $allFaceGeo[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`objectType $historyNodes[$y]`=="wrap")
			select -d $allFaceGeo[$i];
	}

$tempString=`lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2`;
rename $tempString[0] squashFfd;
rename $tempString[1] squashFfdLattice;
rename $tempString[2] squashFfdBase;
$tempString=`listConnections squashFfd.message`;
rename $tempString[0] squashFfdSet;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdLattice;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdBase;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdLattice;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdBase;
scale -r 1.25 1.25 1.25 squashFfdLattice;
scale -r 1.25 1.25 1.25 squashFfdBase;
setAttr "squashFfd.outsideLattice" 1;
parent squashFfdBase squashBase_M;
createNode -n squashXup transform;
setAttr -type float3 squashXup.r 90 0 90;
select squashXup;
$pos=`xform -q -ws -t squashFfdLattice.pt[0][1][1]`;
joint -n squashIKX0 -p 0 $pos[1] 0;
select squashXup;
for ($i=1;$i<10;$i++)
    {
    $pos=`xform -q -ws -t squashFfdLattice.pt[0][$i][1]`;
    joint -n ("squashIKX"+$i) -p 0 $pos[1] 0;
    }
setAttr squashIKX1.segmentScaleCompensate 0;
$tempString=`ikHandle -n squashIKHandle -ccv 1 -ns 2 -sol ikSplineSolver -sj squashIKX1 -ee squashIKX9`;
rename $tempString[1] squashIKEffector;
rename $tempString[2] squashIKECurve;
for ($i=0;$i<5;$i++)
    {
    select -r squashIKECurve.cv[$i];
    $tempString=`newCluster " -envelope 1"`;
    rename $tempString[0] ("squashIKCluster"+$i);
    rename $tempString[1] ("squashIKClusterHandle"+$i);
    }  
select -cl;
for ($i=0;$i<10;$i++)
    select -add ("squashIKX"+$i);
select -add squashFfdLattice;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] squashIKSC;

skinPercent -tv squashIKX0 1 squashIKSC squashFfdLattice.pt[0:1][0:1][0:1];
skinPercent -tv squashIKX2 1 squashIKSC squashFfdLattice.pt[0:1][2][0] squashFfdLattice.pt[0:1][2][1];
skinPercent -tv squashIKX3 1 squashIKSC squashFfdLattice.pt[0:1][3][0] squashFfdLattice.pt[0:1][3][1];
skinPercent -tv squashIKX4 1 squashIKSC squashFfdLattice.pt[0:1][4][0] squashFfdLattice.pt[0:1][4][1];
skinPercent -tv squashIKX5 1 squashIKSC squashFfdLattice.pt[0:1][5][0] squashFfdLattice.pt[0:1][5][1];
skinPercent -tv squashIKX6 1 squashIKSC squashFfdLattice.pt[0:1][6][0] squashFfdLattice.pt[0:1][6][1];
skinPercent -tv squashIKX7 1 squashIKSC squashFfdLattice.pt[0:1][7][0] squashFfdLattice.pt[0:1][7][1];
skinPercent -tv squashIKX8 1 squashIKSC squashFfdLattice.pt[0:1][8][0] squashFfdLattice.pt[0:1][8][1];
skinPercent -tv squashIKX9 1 squashIKSC squashFfdLattice.pt[0:1][9:10][0:1];

delete `pointConstraint squashIKClusterHandle4 squashIKClusterHandle3`;
parent squashIKClusterHandle3 squashIKClusterHandle4;
move -r 0 ($scale*-0.1) 0 ;

parent squashIKClusterHandle4 squashTop_M;
parent squashIKClusterHandle2 squashMiddle_M;
parent squashIKClusterHandle0 squashIKClusterHandle1 squashIKX0 squashBase_M;

createNode -n squashIKCurveInfo curveInfo;
connectAttr squashIKECurveShape.worldSpace[0] squashIKCurveInfo.inputCurve;
createNode -n squashIKCurveInfoNormalize multiplyDivide;
setAttr squashIKCurveInfoNormalize.operation 2;
connectAttr squashIKCurveInfo.arcLength squashIKCurveInfoNormalize.input1X;
setAttr squashIKCurveInfoNormalize.input2X `getAttr squashIKCurveInfoNormalize.input1X`;
createNode -n squashIKScale multiplyDivide;
connectAttr squashIKCurveInfoNormalize.outputX squashIKScale.input1X;
createNode -n squashIKStretch multiplyDivide;
connectAttr squashIKScale.outputX squashIKStretch.input2X;
setAttr squashIKStretch.input1X `getAttr squashIKX2.tx`;

//connectAttr squashIKScale.outputX squashIKStretch.input1X;
connectAttr FaceAttachToHead.sx squashIKScale.input2X;
setAttr "squashIKScale.operation" 2;
for ($i=1;$i<10;$i++)
    connectAttr squashIKStretch.outputX ("squashIKX"+$i+".tx");
createNode -n squashVolume1Over multiplyDivide;
connectAttr squashIKScale.outputX squashVolume1Over.input2X;
setAttr "squashVolume1Over.input1X" 1;
setAttr "squashVolume1Over.operation" 2;
createNode -n squashVolumePow multiplyDivide;
connectAttr squashVolume1Over.outputX squashVolumePow.input1X;
setAttr "squashVolumePow.operation" 3;
setAttr "squashVolumePow.input2X" 0.5;
createNode -n squashBlendTwo blendTwoAttr;
setAttr squashBlendTwo.input[0] 1;
connectAttr squashVolumePow.outputX squashBlendTwo.input[1];
connectAttr squashTopVolumeUC.output squashBlendTwo.attributesBlender;
for ($i=2;$i<9;$i++)
    {
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sy");
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sz");
    }
    
parent squashFfdLattice squashIKECurve squashIKHandle SquashSetup;
parent squashIKX1 FaceAttachToHead;
parent SquashControls ControlsSetup;
parentConstraint -mo $headJoint SquashControls;
scaleConstraint $headJoint SquashControls;
delete squashXup;

setAttr -l 1 squashIKX1.v 0;
setAttr -l 1 squashFfdBase.v 0;
setAttr -l 1 squashIKHandle.v 0;
setAttr -l 1 squashIKX0.v 0;
for ($i=0;$i<5;$i++)
    setAttr -l 1 ("squashIKClusterHandle"+$i+".v") 0;

addAttr -k 0 -ln curveVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.curveVis;
connectAttr squashTop_M.curveVis squashIKECurve.v;
addAttr -k 0 -ln LatticeVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.LatticeVis;
connectAttr squashTop_M.LatticeVis squashFfdLattice.v;

//update buildPose
string $controls[]={"squashTop_M","squashMiddle_M","squashBase_M"};
string $setAttrCmd;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listAttr -k -shortNames $controls[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controls[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controls[$i]+"."+$tempString[$y]+" "+`getAttr ($controls[$i]+"."+$tempString[$y])`+";";
	}
string $existingCmd=`getAttr faceBuildPose.udAttr`;
setAttr -type "string" faceBuildPose.udAttr ($existingCmd+$setAttrCmd);

connectAttr ctrlBox.SquashCtrlVis SquashControls.v;
asUpdateAllSet $allBefore;
select squashTop_M;
}

global proc asOptimizeSquash ()
{
global string $gMainProgressBar;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $tempInt[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInt[0];

string $allHeadJoints[]=`listRelatives -ad -type joint FaceDeformationSystem`;
$tempString=`listRelatives -ad -type joint $headJoint`;
$allHeadJoints=`stringArrayCatenate $allHeadJoints $tempString`;
$allHeadJoints[size($allHeadJoints)]=$headJoint;
select -cl;
progressBar -e -st "Optimizing" -bp -ii 1 -min 0 -max $numVtx $gMainProgressBar;
for ($i=0;$i<$numVtx;$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;return;}

	string $vtx=$geometry+".vtx["+$i+"]";
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $vtx`;
	int $headVtx=0;
	for ($y=0;$y<size($infs);$y++)
		{
		if (`stringArrayCount $infs[$y] $allHeadJoints`)
			{
			$headVtx=1;
			break;
			}
		}
	if (!$headVtx)
		select -add $vtx;
	}
sets -rm squashFfdSet `ls -sl`;
InvertSelection;
progressBar -e -ep $gMainProgressBar;
print ("// Optimize complete, now only these selected vtx`s are affected by Squash\n");
}

//-- ASFace Procedures Ends Here --//

global proc string asGetLatestLocalScriptLocation ()
{
string $scriptLocation=`asGetScriptLocation`;
string $latestLocalScriptLocation=$scriptLocation;
string $tempString[];
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	tokenize $scriptLocation "/" $tempString;
	$latestLocalScriptLocation="";
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="AdvancedSkeleton5Files")
			break;
		else
			{
			if ($i>0)
				$latestLocalScriptLocation+="/";
			$latestLocalScriptLocation+=$tempString[$i];
			}
		}
	}
return $latestLocalScriptLocation;
}

global proc string asGetLatestLocalVersionAsString ()
{
string $latestLocalVersion=`asGetScriptVersionAsString`;
string $scriptLocation=`asGetScriptLocation`;
string $tempString[];
string $latestLocalASFile;
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	$latestLocalASFile=`asGetLatestLocalScriptLocation`+"/AdvancedSkeleton5.mel";
	$latestLocalVersion=`asGetScriptVersionFromFile $latestLocalASFile`;
	}
return $latestLocalVersion;
}

global proc asCheckForUpdates ()
{
if (!`about -win`)
	error "This is only avaiable in Windows. For updates, go to: www.animationstudios.com.au/advancedskeleton/downloads";
string $curl=`asGetScriptLocation`+"/AdvancedSkeleton5Files/bin/curl.e";
if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
text -e -en 0 -l "x.xxx" asUpdateFoundVersion;
checkBox -e -v 0 asBetaCheckBox;
button -e -en 0 asUpdateVersionButton;
waitCursor -st 1;
int $modifier=`getModifiers`;
float $versions[];
string $versionsText;

if ($modifier==13)
	{
	print ("// Checking online for new BETA version\n");
	checkBox -e -v 1 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton5Beta/latestBetaVersion.txt")`;
	}
else
	{
	print ("// Checking online for new version\n");
	checkBox -e -v 0 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton5/latestVersion.txt")`;
	}
string $latestVersionAsString=$versionsText;
float $latestVersion=$versionsText;

string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
float $latestInstalledVersion=`asGetScriptVersionFromFile ($sLoc+"/AdvancedSkeleton5.mel")`;
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton5.mel")`;

if ($latestVersion>$latestInstalledVersion)
	{
	text -e -en 1 -l $latestVersionAsString asUpdateFoundVersion;
	button -e -en 1 asUpdateVersionButton;
	print ("// New version found, click Update, to update to the new version\n");
	}
else
	print ("// Latest version("+$latestVersionAsString+"), is not greater than your latest installed version("+$latestInstalledVersionAsString+")\n");
waitCursor -st 0;
}

global proc string asGetLatestInstalledVersionScriptLocation ()
{
string $sLoc=`asGetScriptLocation`;
string $ts[];
int $numTok=`tokenize $sLoc "/" $ts`;
if ($ts[size($ts)-2]=="oldVersions")
	$sLoc=`substitute ("/"+$ts[$numTok-3]+"/"+$ts[$numTok-2]+"/"+$ts[$numTok-1]) $sLoc ""`;
return $sLoc;
}

global proc asUpdateVersion ()
{
waitCursor -st 1;
string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton5.mel")`;
string $curl=$sLoc+"/AdvancedSkeleton5Files/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeleton5Files/bin/7za.e";
string $newVersionAsString=`text -q -l asUpdateFoundVersion`;
string $newVersionFolder=$sLoc+"/AdvancedSkeleton5Files/newVersions/AdvancedSkeleton_v"+$newVersionAsString;
if (!`file -q -ex $newVersionFolder`)
	sysFile -md $newVersionFolder;
//download
string $newVersionZipFile=$newVersionFolder+"/AdvancedSkeleton5.zip";
//string $newVersionExtractedFolder=$newVersionFolder+"/AdvancedSkeleton5";
string $zipFileUrl="https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton5/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton5.zip";
if (`checkBox -q -v asBetaCheckBox`)
	$zipFileUrl="https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton5Beta/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton5.zip";
string $cmd="start\/wait \"Downloading\"  \""+$curl+"\" -k -o \""+$newVersionZipFile+"\" "+$zipFileUrl;
print ("// Starting Download:"+$cmd+";\n");
system ($cmd);
//confirm download
if (`file -q -ex $newVersionZipFile`)
	print ("// Downloaded sucessfully:"+$newVersionZipFile+";\n");
else
	error ("// Download failed, could not find:"+$newVersionZipFile+";\n");
//unzip
$cmd="start\/wait \"Unzipping\"  \""+$zip+"\" x \""+$newVersionZipFile+"\" -o\""+$newVersionFolder+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);
//confirm unzip
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton5.mel")`)
	print ("// Unzipped sucessfully:"+$newVersionFolder+"/AdvancedSkeleton5.mel;\n");
else
	error ("// Unzipp failed, could not find:"+$newVersionFolder+"/AdvancedSkeleton5.mel;\n");
//backup $latestInstalledVersion version
string $oldVersionsFolder=$sLoc+"/AdvancedSkeleton5Files/oldVersions/AdvancedSkeleton_v"+$latestInstalledVersionAsString;
print ("// Backing up old version: asCopyFilesInFolder \""+$oldVersionsFolder+"\" \""+$sLoc+"\";\n");
sysFile -md ($oldVersionsFolder+"/AdvancedSkeleton5Files");
asCopyFilesInFolder ($oldVersionsFolder+"/AdvancedSkeleton5Files") ($sLoc+"/AdvancedSkeleton5Files");
sysFile -cp ($oldVersionsFolder+"/AdvancedSkeleton5.mel") ($sLoc+"/AdvancedSkeleton5.mel");
//replace with new version
print ("// Replacing current version with the downloaded version: asCopyFilesInFolder \""+$sLoc+"\" \""+$newVersionFolder+";\n");
asCopyFilesInFolder $sLoc $newVersionFolder;
waitCursor -st 0;
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton5.zip")`)
	sysFile -del ($newVersionFolder+"/AdvancedSkeleton5.zip");
print ("// Updated from "+$latestInstalledVersionAsString+" to "+$newVersionAsString+"\n");
//Re-start
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
evalDeferred -lp ("source \""+$sLoc+"/AdvancedSkeleton5.mel\";AdvancedSkeleton5;");
}

global proc asCopyFilesInFolder (string $destFolder, string $sourceFolder)
{
global string $gMainProgressBar;
if (!`file -q -ex $destFolder`)
    sysFile -md $destFolder;
string $fileList[]=`getFileList -fld ($sourceFolder+"/")`;
if (`size($fileList)`==0)
	return;
progressBar -e -st "Copy files" -bp -ii 1 -min 0 -max (size($fileList)) $gMainProgressBar;
for ($i=0;$i<size($fileList);$i++)
    {
		progressBar -e -s 1 $gMainProgressBar;
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
    if ($fileList[$i]=="incrementalSave" || $fileList[$i]=="distributes" || `gmatch $fileList[$i] "[.]*"`
  		|| $fileList[$i]=="newVersions" || $fileList[$i]=="oldVersions" || $fileList[$i]=="asReleaser.mel" || `gmatch $fileList[$i] "*[.]psd"`)
        continue;
    if (`filetest -d ($sourceFolder+"/"+$fileList[$i])`)
			asCopyFilesInFolder ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i]);
    else
			if (!`sysFile -cp ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i])` && `about -win`)
				{
				error ("Failed to copy file, possible privileges issue. This is common if you downloaded AdvancedSkeleton from the Autodesk store\n"
					+"Follow the steps in the URL below, then redo the updates\n"
					+"https://db.tt/xGk7E5xU\n");
				progressBar -e -ep $gMainProgressBar;
				return;
				}
    }
progressBar -e -ep $gMainProgressBar;
}

global proc asDockWindow (int $dock)
{
int $asDock=`optionVar -q asDock`;
optionVar -iv asDock $dock;
if (`dockControl -q -ex AdvancedSkeletonDockControl`)
	{
	deleteUI -control AdvancedSkeletonDockControl;
	AdvancedSkeleton5;
	}
else if ($dock)
	dockControl -w 296 -fl 0 -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
}

global proc asDockWindowChangeFloatingState ()
{
optionVar -iv asDock (!`dockControl -q -ex AdvancedSkeletonDockControl`);
}

global proc asFitSkeletonImport ()
{
string $dialog;
if (`objExists FitSkeleton`)
	{
	$dialog=`confirmDialog -t "Confirm"
		-m "Replace FitSkeleton ?"
		-b "OK" -db "OK"
		-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		return;
	}

float $existingScale[];
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
string $removeExistingObjs[]={"FitSkeleton","FitSkeletonVisualizers","cylinders","boxes","locators","directions",
	"asRedSG","asRed2SG","asGreenSG","asGreen2SG","asBlueSG","asBlue2SG","asBlackSG","asWhiteSG","asBonesSG",
	"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asBlack","asWhite","asBones"};
for ($i=0;$i<size($removeExistingObjs);$i++)
	if (`objExists $removeExistingObjs[$i]`)
		delete $removeExistingObjs[$i];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/fitSkeletons/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asFitFiles`;
if (`file -q -ex $FitSkeletonFile`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
if ($existingScale[0]!=0)
	setAttr -type float3 FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
if (`objExists Group|Main` && !`objExists Group|Main|FitSkeleton` && `objExists FitSkeleton`)
	parent FitSkeleton Group|Main;
asFitSkeletonConnectControl;
asUpdateButtonEnables;
}


global proc asFitSkeletonLimbsImport ()
{
string $dialog;
string $tempString[],$tempString2[],$tempString3[];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asLimbFiles`;
float $existingScale[3]={1,1,1};
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
if (`file -q -ex $FitSkeletonFile`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
if (`objExists Main|FitSkeleton` && `objExists |FitSkeleton`)
	rename |FitSkeleton AdvancedSkeleton_FitSkeleton;
if (`objExists AdvancedSkeleton_FitSkeleton` && `objExists FitSkeleton`)
	{
	setAttr -type float3 AdvancedSkeleton_FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
	$tempString=`listRelatives -f -c -type transform AdvancedSkeleton_FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		tokenize $tempString[$i] "|" $tempString2;
		string $shortName=$tempString2[size($tempString2)-1];
		$tempString2=`ls -l $shortName`;
			{
			if (size($tempString2)>1)
				$dialog=`confirmDialog -t "Confirm"
				-m ($shortName+" already exist")
				-b "Replace" -db "Replace"
				-b "Merge" -ds "Merge"`;
			if ($dialog=="Replace")
				{
				for ($y=0;$y<size($tempString2);$y++)
					if ($tempString2[$y]!=$tempString[$i])
						{
						$tempString3=`listRelatives -p $tempString2[$y]`;
						delete $tempString2[$y];
						if ($tempString3[0]!="")
							parent $tempString[$i] $tempString3[0];
						else
							parent $tempString[$i] FitSkeleton;
						}
				}
			else if (`objExists Root`)
				parent $tempString[$i] Root;
			else
				parent $tempString[$i] FitSkeleton;
			}
		}
	//Transfer SDK`s to FitSkeleton;
	if (`attributeExists drivingSystem AdvancedSkeleton_FitSkeleton`)
		{
		$tempString=`listConnections AdvancedSkeleton_FitSkeleton.drivingSystem`;
		if (!`attributeExists drivingSystem FitSkeleton`)
			addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;
		for ($i=0;$i<size($tempString);$i++)
			connectAttr -na ($tempString[$i]+".drivingSystemOut") FitSkeleton.drivingSystem;
		string $uAs[]=`listAttr -ud AdvancedSkeleton_FitSkeleton`;
		for ($i=0;$i<size($uAs);$i++)
			{
			if (!`gmatch $uAs[$i] "drivingSystem_*"`)
				continue;
			if (!`attributeExists $uAs[$i] FitSkeleton`)
				addAttr -k 0 -ln $uAs[$i] -at bool -dv true -multi FitSkeleton;
			$tempString=`listConnections -p 1 ("AdvancedSkeleton_FitSkeleton."+$uAs[$i])`;
			for ($y=0;$y<size($tempString);$y++)
				connectAttr -f ("FitSkeleton."+$uAs[$i]+"["+$y+"]") $tempString[$y];
			}
		}
	delete AdvancedSkeleton_FitSkeleton;
	}
asFitSkeletonConnectControl;
asUpdateButtonEnables;
}

global proc asFitSkeletonExport ()
{
string $selJoints[]=`ls -sl -type joint `;
string $selJointsLongName[]=`ls -l -sl -type joint `;
int $fitSkeletonVisLocked=`getAttr -l FitSkeleton.v`;
string $tempString[],$tempString2[],$drivingSystems[],$previousFitSkeletonChildren[],$previousSelJointParents[];
string $asScriptLocation=`asGetScriptLocation`;
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletons/";

//Limb only, first check, to determine destinationDir
int $limbOnly=0;
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		$limbOnly=1;
	}
if ($limbOnly)
	$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
string $result[] = `fileDialog2 -fileFilter "*.ma" -dialogStyle 2 -dir $fitSkeletonsDir`;
string $file=$result[0];
if ($file=="")
	return;

$tempString=`listRelatives -p FitSkeleton`;
string $currentParent=$tempString[0];
if ($fitSkeletonVisLocked)
	setAttr -l 0 FitSkeleton.v;
setAttr FitSkeleton.v 1;
if (`objExists $currentParent`)
	parent -w FitSkeleton;
$tempString=`listConnections -s 0 -d 1 -type animCurve`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 1 -d 0 -type transform $tempString[$i]`;
	if ($tempString2[0]!="" && $tempString2[0]!="FitSkeleton")
		if (!`stringArrayCount $tempString2[0] $drivingSystems`)
			$drivingSystems[size($drivingSystems)]=$tempString2[0];
	}

//Limb only ?
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		{
		if (!`objExists previousFitSkeletonChildren`)
			{
			createNode -n previousFitSkeletonChildren transform;
			$previousFitSkeletonChildren=`listRelatives -c -type joint FitSkeleton`;
			parent $previousFitSkeletonChildren previousFitSkeletonChildren;
			}
		$tempString=`listRelatives -p $selJoints[$i]`;
		$previousSelJointParents[$i]=$tempString[0];
		parent $selJoints[$i] FitSkeleton;
		}
	}

select FitSkeleton;
if (size($drivingSystems))
	delete $drivingSystems;
file -force -options "v=0;" -typ "mayaAscii" -es $file;
if (size($drivingSystems))
	undo;

if (`objExists $currentParent`)
	parent FitSkeleton $currentParent;
if ($fitSkeletonVisLocked)
	setAttr -l 1 FitSkeleton.v;

//Limb only ? (restore)
for ($i=0;$i<size($selJoints);$i++)
	if ($previousSelJointParents[$i]!="")
		parent $selJoints[$i] $previousSelJointParents[$i];
if (`objExists previousFitSkeletonChildren`)
	{
	parent `listRelatives -c previousFitSkeletonChildren` FitSkeleton;
	delete previousFitSkeletonChildren;
	}

print ("// FitSkeleton exported to: \""+$file+"\"\n");
}

global proc asFitChangeLimbType ()
{
string $limbType=`optionMenu -q -v asLimbType`;
if ($limbType=="Spine" || $limbType=="Neck" || $limbType=="Tail")
	checkBox -e -v 1 asLimbMiddle;
else
	checkBox -e -v 0 asLimbMiddle;
}

global proc asFL ()
{
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
		optionVar -iv $framLayouts[$i] `frameLayout -q -cl $framLayouts[$i]`;

}

global proc asReferenceModelBrowser ()
{
global string $selectedNamespaceRadioButton;
string $sNRB=$selectedNamespaceRadioButton;
string $referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
int $referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
int $referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
string $ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
string $topNodesBefore[]=`ls -as`;

if (`asIsMayaLT`)
	error ("Maya LT does not have Reference, Import the model instead");
CreateReferenceOptions;

//Something in here Ran again, makes it work
global string $selectedNamespaceRadioButton;
$sNRB=$selectedNamespaceRadioButton;
$referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
$referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
$referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
$ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
CreateReference;

optionVar -sv referenceOptionsRenamePrefix $referenceOptionsRenamePrefix;
optionVar -iv referenceUseNamespacesDuringFileIO $referenceUseNamespacesDuringFileIO;
optionVar -iv referenceOptionsUseRenamePrefix $referenceOptionsUseRenamePrefix;
optionVar -sv ReferenceMergeOptionValue $ReferenceMergeOptionValue;
if ($sNRB!="")
	$selectedNamespaceRadioButton=$sNRB;
string $topNodesAfter[]=`ls -as`;
select -cl;
for ($i=0;$i<size($topNodesAfter);$i++)
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		select -add $topNodesAfter[$i];

//Hi layer
if (`objExists Hi`)
	{
	if(`objectType Hi`=="displayLayer")
		editDisplayLayerMembers -noRecurse Hi `ls -selection`;
	}
else
	{
	createDisplayLayer -name Hi -number 1 -nr;
	setAttr Hi.displayType 1;
	}
select -cl;
}

global proc asFitTglRLA ()
{
if (!`objExists Visualizers`)
	return;
string $tempString[];
string $visualizers[]=`listRelatives -ad -type transform Visualizers`;
int $onOff,$setOnOff;
for ($i=0;$i<size($visualizers);$i++)
	{
	$tempString=`listRelatives -s $visualizers[$i]`;
	if ($tempString[0]!="" || !`gmatch $visualizers[$i] "*Aim"`)
		continue;
	if (!$setOnOff)
		{
		$onOff=!`getAttr ($visualizers[$i]+".displayLocalAxis")`;
		$setOnOff=1;
		}
	setAttr ($visualizers[$i]+".displayLocalAxis") $onOff;
	}
}

global proc asJointsVisibility (int $onOff)
{
if (!`objExists Main`)
	return;
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asDisplayRigRLA (int $onOff)
{
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".displayLocalAxis") $onOff;
}

global proc asCreateFitSkeleton ()
{
if (`objExists FitSkeleton`)
	delete FitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1.5 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FitSkeleton;
setAttr FitSkeletonShape.overrideEnabled 1;
setAttr FitSkeletonShape.overrideColor 29;
scale -r -p 0 0 0 2 2 2 FitSkeleton.cv[0:7];
duplicate -n FitSkeletonHeight FitSkeleton;
parent FitSkeletonHeight FitSkeleton;
parent -add -s FitSkeletonHeightShape FitSkeleton;
delete FitSkeletonHeight;
move -r 0 17 0 FitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FitSkeleton.tx;setAttr -k 0 -l 1 FitSkeleton.ty;setAttr -k 0 -l 1 FitSkeleton.tz;
setAttr -k 0 -l 1 FitSkeleton.rx;setAttr -k 0 -l 1 FitSkeleton.ry;setAttr -k 0 -l 1 FitSkeleton.rz;
asEnsureFitSkeletonAttributes;
asFitSkeletonConnectControl;
select FitSkeleton;
}

global proc asEnsureFitSkeletonAttributes ()
{
float $gap=0.75;
if (`optionVar -ex asFitSkeletonGap`)
	$gap=`optionVar -q asFitSkeletonGap`;
if (!`attributeExists visGeoType FitSkeleton`)
	addAttr -k 1 -ln visGeoType -at "enum" -en "cylinders:boxes:spheres:bones" FitSkeleton;
if (!`attributeExists visCylinders FitSkeleton`)
	addAttr -k 0 -ln visCylinders -at bool FitSkeleton;
if (!`attributeExists visBoxes FitSkeleton`)
	addAttr -k 0 -ln visBoxes -at bool FitSkeleton;
if (!`attributeExists visSpheres FitSkeleton`)
	addAttr -k 0 -ln visSpheres -at bool FitSkeleton;
if (!`attributeExists visBones FitSkeleton`)
	addAttr -k 0 -ln visBones -at bool FitSkeleton;
if (!`attributeExists lockCenterJoints FitSkeleton`)
	addAttr -k 1 -ln lockCenterJoints -dv 1 -at bool FitSkeleton;
if (!`attributeExists visGap FitSkeleton`)
	addAttr -k 1 -ln visGap -at double -dv $gap -min 0 -max 1 FitSkeleton;
if (!`attributeExists visGeo FitSkeleton`)
	addAttr -k 1 -ln visGeo -at bool -dv 1 FitSkeleton;
}

global proc asEnsureFitBaseStruct ()
{
if (!`objExists FitSkeletonVisualizers`)
	createNode -n FitSkeletonVisualizers transform;
if (!`objExists Aims`)
	createNode -n Aims -p FitSkeletonVisualizers transform;
if (!`objExists Systems`)
	createNode -n Systems -p FitSkeletonVisualizers transform;
}

global proc asEnsureFitSystems ()
{
if (!`objExists Systems`)
	return;
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	asEnsureSystem $systems[$i];
}

global proc asFitSkeletonConnectControl ()
{
if (!`objExists FitSkeleton`)
	return;

if(`attributeExists visLocators FitSkeleton`)
	connectControl asVisLocators FitSkeleton.visLocators;
//if(`attributeExists visGeo FitSkeleton`)
//	connectControl asVisGeo FitSkeleton.visGeo;
if(`attributeExists visGeoType FitSkeleton`)
	connectControl asVisGeoType FitSkeleton.visGeoType;
if(`attributeExists visGap FitSkeleton`)
	connectControl asVisGap FitSkeleton.visGap;
if(`attributeExists lockCenterJoints FitSkeleton`)
	connectControl asLockCenterJoints FitSkeleton.lockCenterJoints;
if(`attributeExists visDirections FitSkeleton`)
	connectControl asVisDirections FitSkeleton.visDirections;
if(`attributeExists visDirectionFront FitSkeleton`)
	connectControl asVisDirectionFront FitSkeleton.visDirectionFront;

if(`attributeExists lockCenterJoints FitSkeleton`)
	asFitModeLockCenterJoints;
}

global proc asStraightEndLoc (string $loc, float $lenght)
{
//maintain the `direction` with the end loc
string $parent;
float $pos[]=`getAttr ($loc+".t")`;
$tempString=`listConnections -s 0 -d 1 ($loc+".message")`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		{
		if (`attributeExists "child" $tempString[$i]`)
			if (`isConnected ($loc+".message") ($tempString[$i]+".child")`)
				$parent=$tempString[$i];
		if (`attributeExists "otherChildren" $tempString[$i]`)
			for ($y=0;$y<`getAttr -s ($tempString[$i]+".otherChildren")`;$y++)
				if (`isConnected ($loc+".message") ($tempString[$i]+".otherChildren["+$y+"]")`)
					$parent=$tempString[$i];
		}

if ($parent!="")
	{
	float $pos2[]=`getAttr ($parent+".t")`;
	float $parentLenght=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if ($lenght==0)
		$lenght=$parentLenght;
	float $lenghtMuliplier=1;
	if ($lenght!=0)
		$lenghtMuliplier=$parentLenght*1/$lenght;
	if (`objExists ($loc+"End")`)
		{
		if (!`getAttr -l ($loc+"End.tx")`)
			setAttr ($loc+"End.tx") ($pos[0]+($pos[0]-$pos2[0])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.ty")`)
			setAttr ($loc+"End.ty") ($pos[1]+($pos[1]-$pos2[1])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.tz")`)
			setAttr ($loc+"End.tz") ($pos[2]+($pos[2]-$pos2[2])/$lenghtMuliplier);
		}
	}
}

global proc string asCreateLimbLoc (string $name, float $pos[], float $scale[],int $rotateOrder)
{
global int $asFitModeHierarchy;
int $isScapula;
if ($name=="Scapula")
	$isScapula=1;
string $tempString[];
//if ($name=="Basic")
//	$name="Basic1";
if (`objExists $name`)
	{
	for ($i=1;$i<999;$i++)
		if (!`objExists ($name+$i)`)
			break;
	$name=($name+$i);
	}

$tempString=`spaceLocator -n $name`;
$tempString=`parent ("|"+$tempString[0]) Markers`;
$name=$tempString[0];

setAttr -type float3 ($name+".s") $scale[0] $scale[1] $scale[2];
setAttr -type float3 ($name+"Shape.localScale") 0 1.5 1.5;
connectAttr FitSkeleton.visLocators ($name+"Shape.v");
setAttr ($name+".t") $pos[0] $pos[1] $pos[2];
if ($isScapula)
	{
	setAttr ($name+"Shape.overrideEnabled") 1;
	setAttr ($name+"Shape.overrideColor") 17;
	}

if (!$asFitModeHierarchy)
	{
	setAttr -k 0 ($name+".rx");
	setAttr -k 0 ($name+".ry");
	setAttr -k 0 ($name+".rz");
	}
setAttr ($name+".rotateOrder") $rotateOrder;

asEnsureLimbLocAttrs $name;
return $name;
}

global proc asEnsureLimbLocAttrs (string $name)
{
if (!`gmatch $name "*End*"`)
	{
	if (!`attributeExists twists $name`)
		{
		addAttr -k 1 -ln twists -at long -min 0 -max 10 $name;
		int $na=`getAttr -s triggerPlusMinusAverage.input1D`;
		connectAttr ($name+".twists") triggerPlusMinusAverage.input1D[$na];
		}
	if (!`attributeExists bendCtrls $name`)
		addAttr -k 1 -ln bendCtrls -at bool $name;
	setAttr -l 1 ($name+".bendCtrls");
	if (!`attributeExists "global" $name`)
		addAttr -k 1 -ln "global" -at bool $name;
	if (!`attributeExists child $name`)
		addAttr -ln child -at "message" $name;
	}
if (!`attributeExists otherChildren $name`)
	addAttr -m -indexMatters 0 -ln otherChildren -at "message" $name;
if (!`attributeExists worldUpObject $name`)
	addAttr -ln worldUpObject -at "message" $name;
if (!`attributeExists noMirror $name`)
	addAttr -ln noMirror -at bool $name;
if (!`attributeExists noMirrorBehaviour $name`)
	addAttr -ln noMirrorBehaviour -at bool $name;
if (!`attributeExists rot $name`)
	{
	addAttr  -k 0 -ln rot -numberOfChildren 3 -at double3 $name;
	addAttr  -p rot -ln rotX -at doubleAngle $name;
	addAttr  -p rot -ln rotY -at doubleAngle $name;
	addAttr  -p rot -ln rotZ -at doubleAngle $name;
	}
}

global proc asEnsureConnectAttr (string $source, string $destination)
{
if (!`isConnected $source $destination`)
	connectAttr -f $source $destination;
}

global proc asCreateRootLimb ()
{
string $limbType="Basic";
$sl=`asGetLimbLetter $limbType`;
string $locs[];
$locs[0]=`asCreateLimbLoc Root {0.0,5.0,0.0} {1,1,1} 0`;
$locs[1]=`asCreateLimbLoc ($locs[0]+"End") {0.0,7.0,0.0} {1,1,1} 0`;
setAttr -l 1 ($locs[0]+".tx");
setAttr -l 1 ($locs[1]+".tx");

//child connect
connectAttr ($locs[1]+".message") ($locs[0]+".child");

//system connect
$system=`asCreateSystem "Basic" $sl`;
connectAttr ($locs[0]+".message") ($system+".start");
connectAttr ($locs[0]+".message") ($system+".mid");
connectAttr ($locs[1]+".message") ($system+".end");
connectAttr ($locs[1]+".message") ($system+".endEnd");

asEnsureSystem $system;
}

global proc asUpdateButtonEnables ()
{
int $hasBodySetup=`objExists "Group"`;
int $hasFaceSetup=`objExists FaceMotionSystem`;
int $hasVisualizers=`objExists FitSkeletonVisualizers`;

//Body
checkBox -e -v $hasVisualizers asVisGeo;
optionMenu -e -en $hasVisualizers asVisGeoType;
floatSliderGrp -e -en $hasVisualizers asVisGap;

checkBox -e -m $hasBodySetup asRebuildConnections;
button -e -m $hasBodySetup asToggleFitSkeletonButton;
string $buildLabel="Build AdvancedSkeleton";
if ($hasBodySetup)
	$buildLabel="ReBuild AdvancedSkeleton";
button -e -l $buildLabel asBuildAdvancedSkeletonButton;

//Face
button -e -m $hasFaceSetup asToggleFitFaceButton;
rowLayout -e -m $hasFaceSetup asFaceRebuildKeepBSRowLayout;
$buildLabel="Build AdvancedFace";
if ($hasFaceSetup)
	$buildLabel="ReBuild AdvancedFace";
button -e -l $buildLabel asBuildAdvancedFaceButton;

text -e -m $hasFaceSetup asBodyText;
text -e -m $hasFaceSetup asFaceText;
button -e -m $hasFaceSetup asGoToBuildPoseFaceButton;
}

global proc asSceneOpened ()
{
global int $asFitModeScriptJobNr4;
$asFitModeScriptJob4Nr=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;
asOffFitMode;

asUpdateButtonEnables;
asFaceUpdateInfo 1;
}

global proc asOffFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr2[];
global int $asFitModeScriptJobNr3;
if (`headsUpDisplay -q -ex HUDFitMode`)
	headsUpDisplay -rem HUDFitMode;

if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr1;
	$asFitModeScriptJobNr1=0;
	}
if (`scriptJob -ex $asFitModeScriptJobNr3` && $asFitModeScriptJobNr3!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr3;
	$asFitModeScriptJobNr3=0;
	}
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
}


global proc asToggleFitModeFace ()
{
if (`headsUpDisplay -q -ex HUDFitModeFace`)
	{
	headsUpDisplay -rem HUDFitModeFace;
	button -e -l FitMode asToggleFitFaceButton;
	setAttr -l 0 FaceFitSkeleton.v;
	setAttr -l 1 FaceFitSkeleton.v 0;
	catchQuiet (`setAttr FaceMotionSystem.v 1`);
	catchQuiet (`setAttr FaceDeformationSystem.v 1`);
	}
else
	{
	string $hudLabel="Fit Mode (Face)";
	int $nextFreeBlock=`headsUpDisplay -nextFreeBlock 2`;
	headsUpDisplay -s 2 -b $nextFreeBlock -bs "medium" -l $hudLabel -lfs "large" HUDFitModeFace;
	button -e -l Cancel asToggleFitFaceButton;
	setAttr -l 0 FaceFitSkeleton.v;
	setAttr -l 1 FaceFitSkeleton.v 1;
	setAttr FaceMotionSystem.v 0;
	setAttr FaceDeformationSystem.v 0;
	}
}

global proc asToggleFitAdvanced (int $onOff)
{
if (!`objExists DeformationSystem`)
	return;
if ($onOff && !`objExists Visualizers`)
	{
	asEnsureFitBaseStruct;
	}
if (!$onOff && `objExists Visualizers`)
	delete Visualizers;
	
setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v $onOff;
setAttr MainShape.v (!$onOff);
setAttr MotionSystem.v (!$onOff);
setAttr DeformationSystem.v (!$onOff);

if ($onOff && `objExists DrivingSystem`)
	asUpdateDrivingSystemsToFitSkeleton;
}

global proc asCopyAttrProperties (string $sourceObjAttr, string $destObjAttr)
{
float $temp[];
string $tempString[];
tokenize $sourceObjAttr "[.]" $tempString;
string $sourceObj=$tempString[0];
string $sourceAttr=$tempString[1];
tokenize $destObjAttr "[.]" $tempString;
string $destObj=$tempString[0];
string $destAttr=$tempString[1];
if (`attributeQuery -node $sourceObj -minExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -min $sourceAttr`;
	addAttr -e -min $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -maxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -max $sourceAttr`;
	addAttr -e -max $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMinExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMin $sourceAttr`;
	addAttr -e -softMinValue $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMaxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMax $sourceAttr`;
	addAttr -e -softMaxValue $temp[0] $destObjAttr;
	}
}

global proc asUpdateDrivingSystemsToFitSkeleton ()
{
string $sel[]=`ls -sl`;
//Remove ewxisting FitSkeltonDrivingSystems first
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	if (`gmatch $systems[$i] "DS_*"`)
		delete $systems[$i];
string $drivingSystems[]=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	$ds="DS_"+$drivingSystems[$i];
	createNode -n $ds -p "Systems" transform;
	string $uAs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($uAs);$y++)
		{
		$dsd=$ds+"_"+$uAs[$y];
		createNode -n $dsd -p $ds transform;
		asLockAttr $dsd 1 1 1 1;
		addAttr -k 1 -ln $uAs[$y] -at double $ds;
		asCopyAttrProperties ($drivingSystems[$i]+"."+$uAs[$y]) ($ds+"."+$uAs[$y]);
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$uAs[$y])`;
		for ($z=0;$z<size($tempString);$z++)
			{
			duplicate -n ("Fit_"+$tempString[$z]) $tempString[$z];
			if (`sets -im AllSet ("Fit_"+$tempString[$z])`)
				sets -rm AllSet ("Fit_"+$tempString[$z]);
			addAttr -k 1 -ln ("standinAttr"+$z) -at double $dsd;
			connectAttr ("Fit_"+$tempString[$z]+".output") ($dsd+".standinAttr"+$z);
			}
		}
	}
select $sel;
}

global proc asFitModeEnsureShaders ()
{
string $colors[]={"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asWhite","asBlack","asBones"};
float $rs[]={1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.78};
float $gs[]={0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , 0.76};
float $bs[]={0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 1.0 , 1.0 , 0.0 , 0.72};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asCreateSamplerMesh (string $sourceObj)
{
//make a copy of the geometry, so we can freeze transforms and get correct sampler-results
string $tempString[];
duplicate -n samplerMesh $sourceObj;
$tempString=`listRelatives -f -ni -s samplerMesh`;
rename $tempString[0] samplerMeshShape;
asLockAttr samplerMesh 0 0 0 0;
$tempString=`listRelatives -p samplerMesh`;
if ($tempString[0]!="")
	parent -w samplerMesh;
$tempString=`listRelatives -s samplerMesh`;
for ($w=0;$w<size($tempString);$w++)
	if (`getAttr ($tempString[$w]+".intermediateObject")`)
		delete $tempString[$w];
makeIdentity -a 1 -t 1 -r 1 -s 1 samplerMesh;
}

global proc asSelectDeformJoints ()
{
string $sel[]=`ls -sl`;
if (`objExists "DeformSet"`)
	select `sets -q "DeformSet"`;
//Deselect end-joints
string $tempString[];
string $deformJoints[]=`ls -sl`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $deformJoints[$i]`;
	if ($tempString[0]=="")
		select -d $deformJoints[$i];
	}
for ($i=0;$i<size($deformJoints);$i++)
	if ($deformJoints[$i]=="Eye_R" || $deformJoints[$i]=="Eye_L" || $deformJoints[$i]=="Jaw_M")
		select -d $deformJoints[$i];
select -add $sel;
}

global proc asSetSmoothBindOptions ()
{
optionVar
-iv "multipleBindPosesOpt" 0
-iv "bindMethod" 1
-iv "bindTo" 2
-iv "skinMethod" 1
-iv "removeUnusedInfluences" 0
-iv "colorizeSkeleton" 0
-fv "maxInfl" 3
-iv "normalizeWeights" 2
-iv "obeyMaxInfl" 0;
SmoothBindSkinOptions;
}

global proc asOpenSelector ()
{
evalEcho ("source \""+`asGetScriptLocation`+"/AdvancedSkeleton5Files/Selector/biped.mel\"");
}

global proc asCreateTempNodes ()
{
createNode -n TempNodes transform;
string $tempNodes[]={"FKScapula_R","FKScapula_L","FKAnkle_L","FKAnkle_R","FKChest_M","FKElbow_L","FKElbow_R","FKHead_M","FKHip_L","FKHip_R","FKIndexFinger1_L","FKIndexFinger1_R","FKIndexFinger2_L","FKIndexFinger2_R","FKIndexFinger3_L","FKIndexFinger3_R","FKKnee_L","FKKnee_R","FKMiddleFinger1_L","FKMiddleFinger1_R","FKMiddleFinger2_L","FKMiddleFinger2_R","FKMiddleFinger3_L","FKMiddleFinger3_R","FKNeck_M","FKPinkyFinger1_L","FKPinkyFinger1_R","FKPinkyFinger2_L","FKPinkyFinger2_R","FKPinkyFinger3_L","FKPinkyFinger3_R","FKRingFinger1_L","FKRingFinger1_R","FKRingFinger2_L","FKRingFinger2_R","FKRingFinger3_L","FKRingFinger3_R","FKRoot_M","FKShoulder_L","FKShoulder_R","FKSpine1_M","FKThumbFinger1_L","FKThumbFinger1_R","FKThumbFinger2_L","FKThumbFinger2_R","FKThumbFinger3_L","FKThumbFinger3_R","FKToes_L","FKToes_R","FKWrist_L","FKWrist_R"};
for ($i=0;$i<size($tempNodes);$i++)
	createNode -n $tempNodes[$i] -p TempNodes transform;
select `listRelatives -ad TempNodes`;
}

global proc asFitSkeletonFromEdgeLoops ()
{
global string $gMove;
setToolTo $gMove;
float $pos[];
string $loc;
string $skinLoopSets[]=`sets -q SkinLoops`;
for ($i=0;$i<size($skinLoopSets);$i++)
	{
	$loc=`substitute "SkinLoops_" $skinLoopSets[$i] ""`;
	$loc=`substitute "_R" $loc ""`;
	$loc=`substitute "_M" $loc ""`;
	if (!`objExists $loc`)
		continue;
	select $skinLoopSets[$i];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $loc;
	}
select -cl;
}

global proc asCreateSkinLoop (int $mirroring)
{
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
string $fkControl=$sel[size($sel)-1];
if (!`gmatch $fkControl "FK*"`)
	error "No FK control selected";
float $pos[];
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
//float $mirrorTolerance=0.001*$scale;

int $neighboursInLoop;
string $mirrorFkControl;
string $tempString[],$tempString2[],$tempString3[],$mirrorVtxs[];

//validate complete loop
select -d $fkControl;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	select $tempString[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $tempString[$i];
	$tempString2=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString2);$y++)
		if (`stringArrayCount $tempString2[$y] $tempString`)
			$neighboursInLoop++;
	if ($neighboursInLoop!=2)
		{
		select $tempString[$i];
		if ($mirroring)
			error ("Not a complete loop, on mirrored side");
		else
			error ("Not a complete loop");
		}
	}

string $deformJoint=`substitute "FK" $fkControl ""`;
if (`objExists ("SkinLoops_"+$deformJoint)`)
	delete ("SkinLoops_"+$deformJoint);

if (!`objExists SkinLoops`)
	sets -em -name SkinLoops;
select $sel;
select -d $fkControl;
sets -name ("SkinLoops_"+$deformJoint);
sets -add  SkinLoops ("SkinLoops_"+$deformJoint);

if (`checkBox -q -v asCreateSkinLoopCheckBox` && !`gmatch $deformJoint "*_M"` && !$mirroring)
	{
	select ("SkinLoops_"+$deformJoint);
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	$tempString2=`ls -sl -o`;
	$tempString3=`listRelatives -p $tempString2[0]`;
	if (`objExists closestSampler`) delete closestSampler;
	if (`objExists samplerMesh`) delete samplerMesh;
	asCreateSamplerMesh $tempString3[0];
	createNode -n closestSampler closestPointOnMesh;
	connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
	
	for ($i=0;$i<size($tempString);$i++)
		{
		select $tempString[$i];
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		int $closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
		$mirrorVtxs[size($mirrorVtxs)]=$tempString2[0]+".vtx["+$closestVtxIndex+"]";
		}
	select $mirrorVtxs;
	ConvertSelectionToContainedEdges;
	if (`gmatch $deformJoint "*_R"`) $mirrorFkControl=`substitute "_R" $fkControl "_L"`;
	if (`gmatch $deformJoint "*_L"`) $mirrorFkControl=`substitute "_L" $fkControl "_R"`;
	select -add $mirrorFkControl;
	asCreateSkinLoop 1;
	}
if (`objExists closestSampler`) delete closestSampler;
if (`objExists samplerMesh`) delete samplerMesh;
print ("// SkinLoops_"+$deformJoint+" Created\n");
select $sel;
}

global proc asSelectAllSkinLoops ()
{
select SkinLoops;
select -add `ls -sl -o`;
}

global proc asDeleteCutUp ()
{
delete `listConnections CutUp.drawInfo`;
delete CutUp;
}

global proc asBindSkinLoops (int $createCutUp)
{
source removeUnusedInfluences;
global string $gMove;
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*[.]*"`)
		error ("Selection is not a object:"+$sel[$i]);
int $tempInt[],$twistJoints[];
int $haveSkinCluster,$numVtxs,$foundDownSideVtx,$loopAffectsCut;
float $circumference,$radius,$ratio;
float $pos[],$posA[],$posB[],$values[];
string $tempString[],$tempString2[],$deformJoints[],$parentJoints[],$childJoints[],$historyNodes[],$skinClusterJoints[],$infs[];
string $allJointChildren[],$edgeLoopVtxs[],$allEdgeLoopVtxs[],$neighbourVtxs[];
string $skinCluster,$weightTo,$cutName,$twistJoint;
string $skinLoopSets[]=`sets -q SkinLoops`;
$skinLoopSets=`sort $skinLoopSets`;

createNode -n CutUpWIP transform;
sets -em -n SkinLoopWeighted;
sets -em -n SkinLoopSpine;
if ($createCutUp && !`objExists CutUp`)
	{
	createDisplayLayer -e -name CutUp;
	setAttr CutUp.color 29;
	setAttr CutUp.displayType 2;
	}

string $skinLoopObjects[];
select SkinLoops;
$tempString=`ls -sl -o`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	if (!`stringArrayCount $tempString2[0] $skinLoopObjects`)
		$skinLoopObjects[size($skinLoopObjects)]=$tempString2[0];
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (!`stringArrayCount $sel[$i] $skinLoopObjects`)
		{
		print ("// SkinLoops not defined for \""+$sel[$i]+"\", skipping this\n");
		continue;
		}
	if ($createCutUp)
		{//temp geo, to maintain weights on original
		duplicate -n ($sel[$i]+"CutUp") $sel[$i];
		$tempString=`listRelatives -s ($sel[$i]+"CutUp")`;
		for ($w=0;$w<size($tempString);$w++)
			if (`getAttr ($tempString[$w]+".intermediateObject")`)
				delete $tempString[$w];
		$sel[$i]=$sel[$i]+"CutUp";
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			$tempString=`duplicate $skinLoopSets[$y]`;
			rename $tempString[0] ($skinLoopSets[$y]+"CutUp");

			select $skinLoopSets[$y];
			$tempString=`ls -sl -fl`;
			for ($t=0;$t<size($tempString);$t++)
				if (`gmatch $tempString[$t] ($sel[$i]+"[.]*")`)
					{
					sets -add ($skinLoopSets[$y]+"CutUp") $tempString[$t];
					sets -rm $skinLoopSets[$y] $tempString[$t];
					}
			}

		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			rename $skinLoopSets[$y] ($skinLoopSets[$y]+"Temp");
			rename ($skinLoopSets[$y]+"CutUp") $skinLoopSets[$y];
			}
		}
	$haveSkinCluster=0;
	$tempInt=`polyEvaluate -v $sel[$i]`;
	$numVtxs=$tempInt[0];
	if (!$createCutUp)
		$historyNodes=`listHistory $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	if (!$haveSkinCluster)
		{
		select Root_M $sel[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		$skinClusterJoints=`listConnections ($skinCluster+".matrix")`;
		$deformJoints[$y]=`substitute "SkinLoops_" $skinLoopSets[$y] ""`;
		$parentJoints[$y]=$childJoints[$y]="";
		$twistJoints[$y]=0;
		for ($x=1;$x<99;$x++)
			{
			tokenize $deformJoints[$y] "_" $tempString;
			if (`objExists ($tempString[0]+"Part"+$x+"_"+$tempString[1])`)
				$twistJoints[$y]=$x;
			else
				break;
			}
		$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$parentJoints[$y]=$tempString[0];
		$tempString=`listRelatives -c -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$childJoints[$y]=$tempString[0];
		if (!`stringArrayCount $deformJoints[$y] $skinClusterJoints`)
			{
			skinCluster -e -lw false -wt 0 -ai $deformJoints[$y] $skinCluster;
			$skinClusterJoints[size($skinClusterJoints)]=$deformJoints[$y];
			}
		if ($parentJoints[$y]!="")
			if (!`stringArrayCount $parentJoints[$y] $skinClusterJoints`)
				{
				skinCluster -e -lw false -wt 0 -ai $parentJoints[$y] $skinCluster;
				$skinClusterJoints[size($skinClusterJoints)]=$parentJoints[$y];
				}
		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		refresh;
		skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
		sets -add SkinLoopWeighted `ls -sl`;
		}
	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl`;
	select ($sel[$i]+".vtx[0:"+$numVtxs+"]");
	select -d $loopVtxs;
	$nonLoopVtx=`ls -sl -fl`;
	refresh;
	weightHammerVerts;

	select SkinLoops;
	ConvertSelectionToVertices;
	$allEdgeLoopVtxs=`ls -sl`;

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		$edgeLoopVtxs=`ls -sl -fl`;
		select $edgeLoopVtxs[0];
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $allEdgeLoopVtxs;
		$neighbourVtxs=`ls -sl -fl`;
		$allJointChildren=`listRelatives -ad -type joint $deformJoints[$y]`;
		for ($z=0;$z<size($neighbourVtxs);$z++)
			{
			if (`sets -im SkinLoopWeighted $neighbourVtxs[$z]`)
				continue;
			$foundDownSideVtx=0;
			select $neighbourVtxs[$z];
			$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $neighbourVtxs[$z]`;
			for ($q=0;$q<size($infs);$q++)
				{//size($infs)==1 means EndPiece
				if (`stringArrayCount $infs[$q] $allJointChildren` || size($infs)==1)
					{
					$cutName=$deformJoints[$y]+"_"+$infs[$q]+"_Cut";
					$foundDownSideVtx=1;
					break;
					}
				}
			if (`objExists ($cutName+"WIP")` || `objExists ($infs[$q]+"_"+$deformJoints[$y]+"_CutWIP")`)
				continue;
			if ($foundDownSideVtx)
				{
				$numSel=0;
				$previousNumSel=-1;
				for ($q=0;$q<100;$q++)
					{
					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
					select -d $allEdgeLoopVtxs;
					$numSel=size(`ls -sl -fl`);
					if ($numSel==$previousNumSel)
						break;
					$previousNumSel=$numSel;
					}
				refresh;
				$tempString=`ls -sl -fl`;
				createNode -n ($cutName+"WIP") -p CutUpWIP transform;
				select $tempString;
				if (!$createCutUp)
					{
					if (!$twistJoints[$y])
						{
						skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
						if (`gmatch $deformJoints[$y] "Spine[1-9]*"` || $deformJoints[$y]=="Chest_M" || $deformJoints[$y]=="Root_M")
							sets -add SkinLoopSpine `ls -sl`;
						}
					if ($twistJoints[$y]==2)// Only works with TwistJoints==2 For Now.
						{
						tokenize $deformJoints[$y] "_" $tempString2;
						for ($w=1;$w<$twistJoints[$y]+1;$w++)
							{
							$twistJoint=$tempString2[0]+"Part"+$w+"_"+$tempString2[1];
							if (!`stringArrayCount $twistJoint $skinClusterJoints`)
								{
								skinCluster -e -lw false -wt 0 -ai $twistJoint $skinCluster;
								$skinClusterJoints[size($skinClusterJoints)]=$twistJoint;
								}
							}
						for ($w=0;$w<size($tempString);$w++)
							{
							$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $tempString[$w]`;
							$values=`skinPercent -ignoreBelow 0.001 -q -v $skinCluster $tempString[$w]`;
							$tempString2=`listRelatives -ad -type joint $infs[0]`;
							if (`stringArrayCount $infs[1] $tempString2`)
								$ratio=$values[0];
							else
								$ratio=$values[1];
							tokenize $deformJoints[$y] "_" $tempString2;
							skinPercent -tv ($tempString2[0]+"Part1_"+$tempString2[1]) $ratio 
													-tv ($tempString2[0]+"Part2_"+$tempString2[1]) (1-$ratio)
													$skinCluster $tempString[$w];
							}
						}
					select $tempString;
					sets -add SkinLoopWeighted `ls -sl`;
					}
				if ($createCutUp)
					{
					ConvertSelectionToFaces;
					$tempString=`ls -sl`;
					if (`objExists $cutName`)
						delete $cutName;
					duplicate -n $cutName $sel[$i];
					asLockAttr $cutName 0 0 0 0;
					$tempString2=`listRelatives -s $cutName`;
					for ($w=0;$w<size($tempString2);$w++)
						if (`getAttr ($tempString2[$w]+".intermediateObject")`)
							delete $tempString2[$w];					
					parent $cutName $deformJoints[$y];
					editDisplayLayerMembers -noRecurse CutUp $cutName;
					select -cl;
					for ($q=0;$q<size($tempString);$q++)
						select -add `substitute $sel[$i] $tempString[$q] $cutName`;
					InvertSelection;
					delete;
					select $cutName;
					CenterPivot;
					//cap
					for ($r=0;$r<size($skinLoopSets);$r++)
						{
						select $skinLoopSets[$r];
						$tempString=`ls -sl -o`;
						$loopAffectsCut=0;
						for ($t=0;$t<size($tempString);$t++)
							{
							$tempString2=`listRelatives -p $tempString[$t]`;
							if ($tempString2[0]==$cutName)
								{
								$loopAffectsCut=1;
								break;
								}
							}
						if (!$loopAffectsCut)
							continue;
						select -d ($sel[$i]+".e[0:99999]");
						//get radius of loop
						$circumference=0;
						$tempString=`ls -sl -fl`;
						for ($t=0;$t<size($tempString);$t++)
							{
							select $tempString[$t];
							ConvertSelectionToVertices;
							$tempString2=`ls -sl -fl`;
							$posA=`xform -q -ws -t $tempString2[0]`;
							$posB=`xform -q -ws -t $tempString2[1]`;
							$circumference+=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
							}
						$radius=($circumference/3.14)/2.0;
						select $skinLoopSets[$r];
						select -d ($sel[$i]+".e[0:99999]");
						$tempString=`polyExtrudeEdge -constructionHistory 1 -keepFacesTogether 1 -pvx 1.927402496 -pvy 3.865962148 -pvz 0.184265554 -divisions 1 -twist 0 -taper 1 -offset 0 -thickness 0 -smoothingAngle 30`;
						$extrudedSel=`ls -sl`;
						setToolTo $gMove;
						$pos=`manipMoveContext -q -position "Move"`;
						scale -r -p $pos[0] $pos[1] $pos[2] 0.25 0.25 0.25;
						$posB=`xform -q -ws -piv $cutName`;
						spaceLocator -n tempLoc1;
						xform -ws -t $posB[0] $posB[1] $posB[1] tempLoc1;
						spaceLocator -n tempLoc2;
						xform -ws -t $pos[0] $pos[1] $pos[1] tempLoc2;	
						aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 tempLoc2 tempLoc1;
						parent $cutName tempLoc1;
						select $extrudedSel;
						move -r -ls -wd ($radius*0.5) 0 0;

						parent $cutName $deformJoints[$y];
						delete tempLoc1 tempLoc2;
						select $cutName;
						DeleteHistory;
						sets -rm $skinLoopSets[$r] ($cutName+".e[0:99999]");
						}
					}
				}
			}
		}

	if (!$createCutUp)
		{
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			//Check that skinLoops comes from this object
			$tempString=`sets -q $skinLoopSets[$y]`;
			if (!size($tempString))
				continue;
			tokenize $tempString[0] "[.]" $tempString;
			if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
			if ($tempString[0]!=$sel[$i])
				continue;

			select $skinLoopSets[$y];
			ConvertSelectionToVertices;
			$tempString2=`ls -sl`;
			$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
			if (size($tempString))
				skinPercent -tv $deformJoints[$y] 0.5 -tv $tempString[0] 0.5 $skinCluster `ls -sl`;
			GrowPolygonSelectionRegion;
			select -d $tempString2;
			weightHammerVerts;
			}
		//Extra hammer Spine
		select SkinLoopSpine;
		$tempString=`ls -sl`;
		if (size($tempString))
			weightHammerVerts;
		}
	if ($createCutUp)
		{
		delete $sel[$i];
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			if (`objExists $skinLoopSets[$y]`)
				delete $skinLoopSets[$y];
			rename ($skinLoopSets[$y]+"Temp") $skinLoopSets[$y];
			}
		}

	if (!$createCutUp)
		{
		select $sel[$i];
		removeUnusedInfluences;
		}
	}


delete CutUpWIP SkinLoopWeighted SkinLoopSpine;
select -cl;
catchQuiet (`select $sel`);
}

global proc string asStripSystemLetter (string $system)
{
string $systemNoLetter=$system;
int $numLetters=size($system);
if (`gmatch $system "*[A-Z]"`)
	$systemNoLetter=`substring $system 1 ($numLetters-1)`;
return $systemNoLetter;
}

global proc int asConfirmIfNotInBuildPose ()
{
if (!`objExists DeformSet`)
	return 1;
int $proceed=1;
int $maxTextLines=35;
int $numNonDef;
string $m;
string $deformJointsList[]=`sets -q DeformSet`;
string $checkAttr[]={"rx","ry","rz","sx","sy","sz"};
float $checkValues[]={0,0,0,1,1,1};
for ($i=0;$i<size($deformJointsList);$i++)
	for ($y=0;$y<size($checkAttr);$y++)
		{
		$value=`getAttr ($deformJointsList[$i]+"."+$checkAttr[$y])`;
		if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
			{
			$m+=$deformJointsList[$i]+"."+$checkAttr[$y]+" = "+$value+"\n";
			$numNonDef++;
			}
		if ($numNonDef>$maxTextLines)
			{
			$m+="...And more..\n\n";
			$y=999;
			$i=999;
			}
		}
if ($m!="")
	{
	$m+="It is reccomended that you Go to Build Pose";
	string $dialog=`confirmDialog -t "Not in Build Pose"
		-m $m
		-b "Go to Build Pose, and Proceed"
		-b "Just Proceed"
		-b "Cancel"
		-ds "Cancel" -db "Cancel"`;
	if ($dialog=="Go to Build Pose, and Proceed")
		{
		asGoToBuildPose bodySetup;
		refresh;
		}
	if ($dialog=="Go to Build Pose, and Proceed" || $dialog=="Just Proceed")
		$proceed=1;
	else
		$proceed=0;
	}
return $proceed;
}

global proc asLockAttr (string $object, int $trans, int $rot, int $scale, int $vis)
{
setAttr -l $trans -k (!$trans) ($object+".translateX");
setAttr -l $trans -k (!$trans) ($object+".translateY");
setAttr -l $trans -k (!$trans) ($object+".translateZ");
setAttr -l $rot -k (!$rot) ($object+".rotateX");
setAttr -l $rot -k (!$rot) ($object+".rotateY");
setAttr -l $rot -k (!$rot) ($object+".rotateZ");
setAttr -l $scale -k (!$scale) ($object+".scaleX");
setAttr -l $scale -k (!$scale) ($object+".scaleY");
setAttr -l $scale -k (!$scale) ($object+".scaleZ");
setAttr -l $vis -k (!$vis) ($object+".visibility");
}

global proc float asgetCharHeight ()
{
float $height;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
return $height;
}

global proc asCreateSkeleton ()
{
asCreateFromFitGeometry Bone;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;

float $scale;
float $pos[],$pos2[];
string $tempString[];
string $copyBones[]={"Pelvis","Ribs","Eye","Cup","Ankle","ToeBall"};
if (!`objExists WristBone_R`)
	$copyBones[size($copyBones)]="Wrist";
string $joint,$side,$childJoint;
for ($i=0;$i<size($copyBones);$i++)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $side="_M";
		if ($a==1) $side="_L";
		if ($a==2) $side="_R";
		$joint=$copyBones[$i]+$side;
		if ($copyBones[$i]=="Pelvis") $joint="Root"+$side;
		if ($copyBones[$i]=="Ribs") $joint="Chest"+$side;
		if ($copyBones[$i]=="ToeBall") $joint="Toes"+$side;
		if (!`objExists $joint` || !`objExists ($copyBones[$i]+"Bone")`)
			continue;
		createNode -n ($copyBones[$i]+"BoneParentConstraint"+$side) transform;
		parent ($copyBones[$i]+"BoneParentConstraint"+$side)  SkeletonGeometry;
		duplicate -n ($copyBones[$i]+"Bone"+$side) ($copyBones[$i]+"Bone");
		parent ($copyBones[$i]+"Bone"+$side) ($copyBones[$i]+"BoneParentConstraint"+$side);
		parentConstraint $joint ($copyBones[$i]+"BoneParentConstraint"+$side);
		setAttr ($copyBones[$i]+"Bone"+$side+".v") 1;
		sets -e -forceElement asBonesSG ($copyBones[$i]+"Bone"+$side);
		editDisplayLayerMembers -noRecurse PolySkeleton ($copyBones[$i]+"Bone"+$side);
		$childJoint=`asRlaChild $joint`;
		if ($copyBones[$i]=="Wrist" && `objExists ("MiddleFinger1"+$side)`) $childJoint=("MiddleFinger1"+$side);
		if ($childJoint!="")
			{
			$pos=`xform -q -ws -t $joint`;
			$pos2=`xform -q -ws -t $childJoint`;
			$scale=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			xform -os -a -s $scale $scale $scale ($copyBones[$i]+"Bone"+$side);
			}
		if ($side=="_L")
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($copyBones[$i]+"Bone"+$side);
		}

//PelvisBone
xform -ws -ro 0 0 0 PelvisBone_M;
$tempString=`listRelatives -type joint -c Root_M`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*_R"`)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		$pos2=`xform -q -ws -t Root_M`;
		xform -ws -t 0 (($pos[1]+$pos2[1])/2.0) (($pos[2]+$pos2[2])/2.0) PelvisBone_M;
		xform -os -a -s ($pos[0]*-1) ($pos[0]*-1) ($pos[0]*-1) PelvisBone_M;
		}

//Ribs
if (`objExists RibsBone_M`)
	{
	$pos=`xform -q -ws -t Root_M`;
	$scale=$pos[1]*0.18;
	if (`objExists Shoulder_R`)
		{
		$pos=`xform -q -ws -t Chest_M`;
		$pos2=`xform -q -ws -t Shoulder_R`;
		$scale=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		}
	xform -os -a -s $scale $scale $scale RibsBone_M;
	}

//MetaCarpals (Wrist)
string $deformJointsList[]=`sets -q "DeformSet"`;
float $childScale[3]={1,1,1};
for ($i=0;$i<size($deformJointsList);$i++)
	{
	string $children[]=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if ($childJoint!="" || size($children)==0)
		continue;
	if ($deformJointsList[$i]=="Root_M")
		continue;
	int $numChar=size($deformJointsList[$i]);
	string $sourceBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone"+`substring $deformJointsList[$i] ($numChar-1) 99`;
	for ($y=0;$y<size($children);$y++)
		{
		$numChar=size($children[$y]);
		string $childBone=`substring $children[$y] 1 ($numChar-2)`+"Bone"+`substring $children[$y] ($numChar-1) 99`;
		string $newBone=`substitute "Bone" $sourceBone ("Bone"+($y+1))`+"_"+$children[$y];
		if (!`objExists $sourceBone`)
			continue;
		duplicate -n $newBone $sourceBone;
		asLockAttr $newBone 0 0 0 0;
		$pos=`xform -q -ws -t $newBone`;
		if ($pos[0]>0)
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $newBone;
		delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $children[$y] $children[$y] $newBone`;
		if (`objExists $childBone`)
			$childScale=`getAttr ($childBone+".s")`;
		if (`gmatch $children[$y] "Cup_*"` && `objExists PinkyFinger1Bone_R`)
			$childScale=`getAttr PinkyFinger1Bone_R.s`;
		setAttr -type float3 ($newBone+".s") ($childScale[0]*1.5) ($childScale[1]*1.5) ($childScale[2]*1.5);
		$pos=`xform -q -ws -t $children[$y]`;
		$pos2=`xform -q -ws -t $deformJointsList[$i]`;
		$scale=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		setAttr ($newBone+".sx") $scale;
		}
	if (`objExists $sourceBone`)
		delete $sourceBone;
	}

//Ankle
if (`objExists Toes_R` && `objExists AnkleBone_R` && `objExists Ankle_R` && `objExists Heel`)
	{
	$pos=`xform -q -ws -t Heel`;
	xform -ws -t $pos[0] $pos[1] $pos[2] AnkleBone_R;
	$pos=`xform -q -ws -t Toes_R`;
	createNode -n tempAimAt transform;
	xform -ws -t $pos[0] 0 $pos[2] tempAimAt;
	delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene" tempAimAt AnkleBone_R`;
	delete tempAimAt;
	$pos=`xform -q -ws -t Toes_R`;
	$pos2=`xform -q -ws -t AnkleBone_R`;
	$scale=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	setAttr AnkleBone_R.sx $scale;
//	$childScale=`getAttr ToesBone_R.s`;
	float $childScaleY=`getAttr Toes.fat`*`getAttr Toes.fatZ`*2;
	setAttr AnkleBone_R.sz $childScaleY;
	$pos=`xform -q -ws -t Ankle_R`;
	setAttr AnkleBone_R.sy $pos[1];
	}

//ToeBallBone_R
if (`objExists ToeBallBone_R` && `objExists Toes_R` && `objExists ToesEnd_R`)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $side="_M";
		if ($a==1) $side="_L";
		if ($a==2) $side="_R";
		if (`objExists ("ToeBallBone"+$side)` && `objExists ("ToesBoneParentConstraint"+$side)`)
			delete ("ToesBoneParentConstraint"+$side);
		$pos=`xform -q -ws -t Toes_R`;
		xform -ws -t $pos[0] 0 $pos[2] ToeBallBone_R;
		createNode -n tempAimAt transform;
		$pos=`xform -q -ws -t ToesEnd_R`;
		xform -ws -t $pos[0] 0 $pos[2] tempAimAt;
		delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene" tempAimAt ToeBallBone_R`;
		delete tempAimAt;
		}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;

asMirrorGeometry Skeleton 0;

print ("Skeleton created\n");
select -cl;
}

global proc asDeleteSkeleton ()
{
string $deleteObjs[]={"SkeletonGeometry","PolySkeleton","Skeleton_Geometry","Mannequin_Geometry","Skeleton","tempAimAt"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateFromFitGeometry (string $geo)
{
//$geo=Box, Cyl, Bone
if (!`asConfirmIfNotInBuildPose`)
	return;
string $geoLongName="Boxes";
if ($geo=="Cyl")
	$geoLongName="Cylinders";
if ($geo=="Bone")
	$geoLongName="Skeleton";
string $sourceGeo=$geo;
if (`getModifiers`==4)
	$sourceGeo="Cyl";
if (`objExists ($geoLongName+"Geometry")`)
	error ("\""+$geoLongName+"Geometry\" Alread exists");
if (`objExists ("Poly"+$geoLongName)`)
	error ("\"Poly"+$geoLongName+"\" Alread exists");
createNode -n ($geoLongName+"Geometry") -p Geometry transform;
createDisplayLayer -e -name ("Poly"+$geoLongName);
setAttr ("Poly"+$geoLongName+".color") 14;
if ($geo=="Bone")
	setAttr ("Poly"+$geoLongName+".color") 21;

float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;
float $visGap=`getAttr FitSkeleton.visGap`;
float $pos[],$rot[];
if (`objExists asMirror`)
	delete asMirror;
checkBox -e -v 1 asVisGeo;
asFitGeometry;
setAttr FitSkeleton.visGap 1;
	dgdirty -a;
refresh;
setAttr FitSkeletonVisualizers.v 0;
refresh;

string $joint;
string $aimsAD[]=`listRelatives -ad -type transform Aims`;
for ($i=$y=0;$i<size($aimsAD);$i++)
	if (`gmatch $aimsAD[$i] ("*"+$sourceGeo+"*")`)
		{
		$joint=`substitute $sourceGeo $aimsAD[$i] ""`;
		string $side="_M";
		$pos=`xform -q -ws -t $aimsAD[$i]`;

		if ($pos[0]<$sideTreshold*-1)
			$side="_R";
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==-1 && $side=="_M") continue;
			if ($b==-1 && $side=="_R") $side="_L";

			if (!`objExists ($joint+$side)`)//could be `noMirror`
				continue;

			duplicate -n ($aimsAD[$i]+$side) $aimsAD[$i];
			editDisplayLayerMembers -noRecurse ("Poly"+$geoLongName) ($aimsAD[$i]+$side);
			setAttr ($aimsAD[$i]+$side+".v") 1;
			createNode -n asMirror transform;
			parent ($aimsAD[$i]+$side) asMirror;
			if ($side=="_L")
				{
				setAttr asMirror.sx -1;
				polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($aimsAD[$i]+$side);
//				setAttr ($aimsAD[$i]+$side+".sz") (`getAttr ($aimsAD[$i]+$side+".sz")`*-1);
				}
			parent -w ($aimsAD[$i]+$side);
			delete asMirror;
			createNode -n ($aimsAD[$i]+"ParentConstraint"+$side) -p ($geoLongName+"Geometry") transform;
			asAlign ($aimsAD[$i]+"ParentConstraint"+$side) ($aimsAD[$i]+$side) 1 1 0 0;
			parentConstraint -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			scaleConstraint  -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			parent ($aimsAD[$i]+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			setAttr ($aimsAD[$i]+$side+"Shape.overrideEnabled") 0;
			asLockAttr ($aimsAD[$i]+$side) 1 1 0 0;
//			if ($geo=="Box")
//				asMirrorGeometry Boxes 0; // slower, but looks better
//			refresh;
			}
		}
setAttr FitSkeleton.visGap $visGap;
delete FitSkeletonVisualizers;
}

global proc asCreatePolyBoxes ()
{
asCreateFromFitGeometry Box;
float $fitSkeletonScale=`getAttr FitSkeleton.sx`;
float $mag;
float $scale[3],$posA[3],$posB[3];
string $toes,$heel,$childLabel;
string $tempString[];
string $deformJointsList[]=`sets -q "DeformSet"`;
for ($i=0;$i<size($deformJointsList);$i++)
	{
	int $numChar=size($deformJointsList[$i]);
	string $joint=`substring $deformJointsList[$i] 1 ($numChar-2)`;
	string $side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`objExists ($joint+"Box"+$side)`)
		continue;
	if (`gmatch $deformJointsList[$i] "*Eye*"`)
		continue;
	createNode -n ($joint+"BoxParentConstraint"+$side) -p BoxesGeometry transform;
	duplicate -n ($joint+"Box"+$side) RootBox_M;
	parent ($joint+"Box"+$side) ($joint+"BoxParentConstraint"+$side);
	setAttr -type float3 ($joint+"Box"+$side+".s") 1 1 1;
	xform -ws -t 0 0.875 -0.875 ($joint+"Box"+$side+".vtx[0]");
	xform -ws -t 0 0.875 0.875 ($joint+"Box"+$side+".vtx[1]");
	xform -ws -t 1 0.875 -0.875 ($joint+"Box"+$side+".vtx[2]");
	xform -ws -t 1 0.875 0.875 ($joint+"Box"+$side+".vtx[3]");
	xform -ws -t 1 -0.875 -0.875 ($joint+"Box"+$side+".vtx[4]");
	xform -ws -t 1 -0.875 0.875($joint+"Box"+$side+".vtx[5]");
	xform -ws -t 0 -0.875 -0.875 ($joint+"Box"+$side+".vtx[6]");
	xform -ws -t 0 -0.875 0.875 ($joint+"Box"+$side+".vtx[7]");
	parentConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	scaleConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	$scale={0.1,1,1};
	$scale[1]=`getAttr ($joint+$side+".fat")`*`getAttr ($joint+$side+".fatY")`*$fitSkeletonScale;
	$scale[2]=`getAttr ($joint+$side+".fat")`*`getAttr ($joint+$side+".fatZ")`*$fitSkeletonScale;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	$mag=0;
	for ($y=0;$y<size($tempString);$y++)
		{
		$posA=`xform -q -ws -t $deformJointsList[$i]`;
		$posB=`xform -q -ws -t $tempString[$y]`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($mag>$scale[0]) {
		$scale[0]=$mag;}
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$tempString=`listRelatives -c -type joint $joint`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Ball*"`)
				$toes=$tempString[$y];
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			}
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$posA=`xform -q -ws -t $deformJointsList[$i]`;
		$scale[0]=$posA[1];
		}
	setAttr -type float3 ($joint+"Box"+$side+".s") $scale[0] $scale[1] $scale[2];
	if (`gmatch $deformJointsList[$i] "*Ankle*"` && `objExists $toes` && `objExists ($toes+"Box"+$side)` && `objExists $heel`)
		{
		polySubdivideFacet -dv 1 -m 0 -ch 0 ($joint+"Box"+$side);
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[0]")`;
		xform -ws -t $posA[0] $posA[1] $posA[2] ($joint+"Box"+$side+".vtx[12]");
		$posB=`xform -q -ws -t ($toes+"Box"+$side+".vtx[1]")`;
		xform -ws -t $posB[0] $posB[1] $posB[2] ($joint+"Box"+$side+".vtx[10]");
		xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) ($joint+"Box"+$side+".vtx[8]");

		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[6]")`;
		xform -ws -t $posA[0] 0 $posA[2] ($joint+"Box"+$side+".vtx[2]");
		$posB=`xform -q -ws -t ($toes+"Box"+$side+".vtx[7]")`;
		xform -ws -t $posB[0] 0 $posB[2] ($joint+"Box"+$side+".vtx[3]");
		xform -ws -t (($posA[0]+$posB[0])/2.0) 0 (($posA[2]+$posB[2])/2.0) ($joint+"Box"+$side+".vtx[11]");

		$posA=`xform -q -ws -t $heel`;
		$posB=`xform -q -ws -t ($joint+"Box"+$side+".vtx[15]")`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		move -r -os -wd 0 ($mag*-1) 0 ($joint+"Box"+$side+".vtx[4:5]") ($joint+"Box"+$side+".vtx[15]");

		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[7]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[7]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[6]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[6]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[5]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[5]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[4]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[4]");
		}
	}

asMirrorGeometry Boxes 0;
print "// PolyBoxes created\n";
select -cl;
}

global proc asDeletePolyBoxes ()
{
if (`objExists "BoxesGeometry"`)
	delete "BoxesGeometry";
if (`objExists "PolyBoxes"`)
	delete "PolyBoxes";
}

global proc asCreateBoolean ()
{
global string $gMainProgressBar;
int $vs[];
string $tempString[],$tempString2[],$boxes[];
string $dupObj,$dupBox,$joint,$puppet,$restoreVisCmd;

if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	refresh;
	}
string $dialog=`confirmDialog -t "Boolean"
	-m "Attempt to Boolean selected geometry with PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "BoxesGeometry"`)
	error "No BoxesGeometry in scene !";
$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}


string $objs[]=`ls -sl`;
if (size($objs)<1)
	error "No Objects Selected !";

if (!`objExists Bool`)
	{
	createDisplayLayer -e -name Bool;
	setAttr Bool.color 21;
	setAttr Bool.displayType 2;
	}
dgdirty -a;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Creating Booleans" -bp -ii 1 -min 0 -max (size($objs)) $gMainProgressBar;
for ($i=0;$i<size($objs);$i++)
	{
	$restoreVisCmd+="setAttr "+$objs[$i]+".v "+`getAttr ($objs[$i]+".v")`+";";
	setAttr ($objs[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($objs);$i++)
	{
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
		$joint=`substitute "Box" $boxes[$y] ""`;
		if (`objExists ($tempString[0]+"Bool"+"_"+$tempString[1])`)
			warning ("Object \""+$tempString[0]+"Bool"+"_"+$tempString[1]+"\" Already exists...\n");
		$bool=`createNode -n ($tempString[0]+"Bool"+"_"+$tempString[1]) transform`;
		delete $bool;
		$dupObj=$objs[$i]+"_"+$boxes[$y];
		duplicate -n $dupObj $objs[$i];
		$tempString=`listRelatives -p $dupObj`;
		if ($tempString[0]!="")
			parent -w $dupObj;
		setAttr ($dupObj+".visibility") 0;
		$dupBox=$objs[$i]+"_"+$boxes[$y]+"Box";
		duplicate -n $dupBox $boxes[$y];
		asLockAttr $dupBox 0 0 0 0;
		parent -w $dupBox;
		select -r $dupObj $dupBox;
		refresh;
		$tempString=`polyBoolOp -n $dupObj -op 3 -ch 0 $dupObj $dupBox`;
		if (`objExists $dupObj`) delete $dupObj;
		if (`objExists $dupBox`) delete $dupBox;
		rename $tempString[0] $bool;
		$vs=`polyEvaluate -v $bool`;
		if (!$vs[0])
			delete  $bool;
		else
			{
			parent $bool $joint;
			editDisplayLayerMembers -noRecurse Bool $bool;
			}
		}
	}
eval ($restoreVisCmd);
progressBar -e -ep $gMainProgressBar;

print ("// Boolean created\n");
select -cl;
}

global proc asDeleteBoolean ()
{
string $all[]=`ls -r 1 -type transform "*Bool_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Bool`)
	delete Bool;
}

global proc asCreateWarp ()
{
global string $gMainProgressBar;
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
string $dialog=`confirmDialog -t "Warp"
	-m "Attempt to Warp selected geometry to PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	}
if (!`objExists Warp`)
	{
	createDisplayLayer -e -name Warp;
	setAttr Warp.color 28;
	setAttr Warp.displayType 2;
	}
int $sideFactor,$isEndJoint,$divisions;
int $tempInt[];
float $pos[],$facePos[];
string $restoreVisCmd;
string $tempString[],$tempString2[],$boxes[];
string $sel[]=`ls -sl`;
string $wrapBox,$SG;
string $multiSGs[];
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
createNode -n closestSampler closestPointOnMesh;

$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	$restoreVisCmd+="setAttr "+$sel[$i]+".v "+`getAttr ($sel[$i]+".v")`+";";
	setAttr ($sel[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -ni -s $sel[$i]`;
	string $meshNode=$tempString[0];
	$tempString=`listConnections ($tempString[0]+".instObjGroups")`;
	if ($tempString[0]!="")
		$SG=$tempString[0];
	else
		{
		//faceAssigned shaders
		for ($y=0;$y<`getAttr -s ($meshNode+".instObjGroups.objectGroups")`;$y++)
			{
			if($y==0)
				{
				//temp copy of mesh, so we can freeze xforms
				$tempString=`duplicate -n tempMesh $sel[$i]`;
				setAttr -l 0 tempMesh.tx;setAttr -l 0 tempMesh.ty;setAttr -l 0 tempMesh.tz;
				setAttr -l 0 tempMesh.rx;setAttr -l 0 tempMesh.ry;setAttr -l 0 tempMesh.rz;
				setAttr -l 0 tempMesh.sx;setAttr -l 0 tempMesh.sy;setAttr -l 0 tempMesh.sz;
				setAttr -l 0 tempMesh.v 0;
				catchQuiet (`parent -w tempMesh`);
				makeIdentity -a 1 -t 1 -r 1 -s 1 tempMesh;
				connectAttr -f tempMesh.outMesh closestSampler.inMesh;
				}
			$tempString=`listConnections -type shadingEngine ($meshNode+".instObjGroups.objectGroups["+$y+"].objectGrpColor")`;
			if ($tempString[0]!="")
				$multiSGs[size($multiSGs)]=$tempString[0];
			}
		}
	progressBar -e -st ("Creating Warps for:"+$sel[$i]) -bp -ii 1 -min 0 -max (size($boxes)) $gMainProgressBar;
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;return;}
		progressBar -e -s 1 $gMainProgressBar;
		if (`gmatch $boxes[$y] "*_L_*"`)
			$sideFactor=-1;
		else
			$sideFactor=1;
		$joint=`substitute "Box" $boxes[$y] ""`;
		tokenize $boxes[$y] "_" $tempString;
		for ($z=1;$z<99;$z++)
			if (!`objExists ($tempString[0]+"Warp"+$z+"_"+$tempString[1])`)
				break;
		$warpBox=$tempString[0]+"Warp"+$z+"_"+$tempString[1];
		$isEndJoint=0;
		$tempString=`listRelatives -type joint -c $joint`;
		if (!size($tempString))
			$isEndJoint=1;
		else if (!`sets -im DeformSet $tempString[0]`)
			$isEndJoint=1;			
		duplicate -n $warpBox $boxes[$y];
		setAttr -k 1 -l 0 ($warpBox+".tx");setAttr -k 1 -l 0 ($warpBox+".ty");setAttr -k 1 -l 0 ($warpBox+".tz");
		setAttr -k 1 -l 0 ($warpBox+".rx");setAttr -k 1 -l 0 ($warpBox+".ry");setAttr -k 1 -l 0 ($warpBox+".rz");
		parent $warpBox	$joint;
		$divisions=2;
		if ($joint=="Head_M")
			$divisions=4;
		catch (`polySmooth -mth 0 -dv $divisions -bnr 1 -c 1 -kb 1 -ksb 1 -khe 1 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $warpBox`);
		scale -r -ocp 1 0.7 0.7 ($warpBox+".e[0:15]");
		scale -r -ocp 1 0.9 0.9 ($warpBox+".vtx[34:50]") ($warpBox+".vtx[52]") ($warpBox+".vtx[54]") ($warpBox+".vtx[56]") ($warpBox+".vtx[58]") ($warpBox+".vtx[60]") ($warpBox+".vtx[62]") ($warpBox+".vtx[64]") ($warpBox+".vtx[74:89]");
		select $sel[$i];
		select -add $warpBox;
		transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

		select $warpBox;
		DeleteHistory;

		//round ends
		if (size($multiSGs))
			{
			$tempInt=`polyEvaluate -f $warpBox`;
			for ($z=0;$z<$tempInt[0];$z++)
				{
				if (`progressBar -q -ic $gMainProgressBar`)
					{progressBar -e -ep $gMainProgressBar;return;}
				$pos=`xform -q -ws -t ($warpBox+".f["+$z+"]")`;
				$facePos[0]=$facePos[1]=$facePos[2]=0;
				for ($a=0;$a<size($pos);$a=$a+3)
					{$facePos[0]+=$pos[$a];$facePos[1]+=$pos[$a+1];$facePos[2]+=$pos[$a+2];}
				$facePos[0]/=(size($pos)/3);$facePos[1]/=(size($pos)/3);$facePos[2]/=(size($pos)/3);
				setAttr closestSampler.inPosition $facePos[0] $facePos[1] $facePos[2];
				int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
				for ($a=0;$a<size($multiSGs);$a++)
					if (`sets -im $multiSGs[$a] ($sel[$i]+".f["+$closestFaceIndex+"]")`)
						sets -e -forceElement $multiSGs[$a] ($warpBox+".f["+$z+"]");
				}

			}
		else
			{
			$tempString=`listRelatives -ni -s $warpBox`;
			sets -e -forceElement $SG $tempString[0];
			}

		editDisplayLayerMembers -noRecurse Warp $warpBox;
		refresh;
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
progressBar -e -ep $gMainProgressBar;
eval ($restoreVisCmd);

print ("// Warp created\n");
select -cl;
}

global proc asDeleteWarp ()
{
string $all[]=`ls -r 1 -type transform "*Warp*_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Warp`)
	delete Warp;
}

global proc asCreateMannequin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists MannequinGeometry`)
	error "MannequinGeometry already exists";
createNode -n MannequinGeometry transform;
parent MannequinGeometry "Geometry";

if (!`objExists Mannequin`)
	{
	createDisplayLayer -e -name Mannequin;
	setAttr Mannequin.color 24;
	setAttr Mannequin.displayType 2;
	editDisplayLayerMembers -noRecurse Mannequin  MannequinGeometry;
	}
float $charHeight=`asgetCharHeight`;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
float $temp[],$temp2[],$temp3[];
int $sideFactor;
vector $childVec;
string $skipJoints[]={"Spine[0-9]*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*"};

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
setAttr Mannequin_Geometry.v 0;
setAttr Skeleton_Geometry.v 0;

$tempString=`listRelatives -c -type transform Mannequin_Geometry`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;

for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if (`gmatch $deformJointsList[$i] "Wrist_*"`)
		for ($y=0;$y<size($children);$y++)
			if (`gmatch $children[$y] "MiddleFinger1_*"`)
				$childJoint=$children[$y];
	if ($childJoint=="")
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	int $skipMe=0;

	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}
	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;

	//spine
	if ($deformJointsList[$i]=="Root_M" || `gmatch $deformJointsList[$i] "*Spine[0-9]*"` || `gmatch $deformJointsList[$i] "*Chest*"` || `gmatch $deformJointsList[$i] "*Head_*"`)
		{
		if (`gmatch $deformJointsList[$i] "Head_*"`)
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Head`;
		else
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Root`;
		$poly=$tempString[0];
//		parentConstraint $deformJointsList[$i] $poly;
		delete `parentConstraint $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		xform -os -s ($lenght/1) ($charHeight/10) ($charHeight/10) $poly;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}

	

	for ($y=0;$y<size($skipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $skipJoints[$y]`)
			$skipMe=1;
	if ($skipMe) continue;

	if (`gmatch $deformJointsList[$i] "*Ankle*"` || `gmatch $deformJointsList[$i] "Toes*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Foot`;
		$poly=$tempString[0];
		xform -ws -t $temp[0] 0 $temp[2] $poly;
		xform -os -s ($lenght/1) ($lenght/1) ($lenght/1) $poly;
		//take on -ws .ry
		$temp3=`xform -q -ws -ro $deformJointsList[$i]`;
		if (`gmatch $deformJointsList[$i] "*Ankle*"`)
			$temp3=`xform -q -ws -ro $childJoint`;
		xform -ws -ro 0 ($temp3[1]-90) 0 $poly;
		//move forward
		move -r -os -wd 0 0 ($lenght/-4.0) $poly;
//		parentConstraint -mo $deformJointsList[$i] $poly;
		delete `parentConstraint -mo $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	else
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Limb") Mannequin_Limb`;
		$poly=$tempString[0];
		xform -os -s ($lenght) ($lenght/2) ($lenght/2) $poly;
		if (`gmatch $deformJointsList[$i] "Wrist*"`)
			setAttr ($poly+".sy") (`getAttr ($poly+".sy")`*3);
		if (`gmatch $deformJointsList[$i] "Toes*"`)
			setAttr ($poly+".sz") (`getAttr ($poly+".sz")`*3);
		if (`gmatch $deformJointsList[$i] "*Finger*"`)
			xform -os -s $lenght ($charHeight/70) ($charHeight/70) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($lenght*1.1) ($charHeight/10) ($charHeight/10) $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`)
			{
			setAttr ($poly+".sx") (`getAttr ($poly+".sx")`*-1);
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $poly;
			}
//		parentConstraint $deformJointsList[$i] $poly;
		delete `parentConstraint $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($poly+"Shape.opposite") 0;
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Sphere`;
	$poly=$tempString[0];
	xform -os -s ($lenght/2) ($lenght/2) ($lenght/2) $poly;
	if (`gmatch $deformJointsList[$i] "*Finger*"`)
		xform -os -s ($charHeight/50) ($charHeight/50) ($charHeight/50) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "Wrist*"`)
		xform -os -s ($charHeight/20) ($charHeight/20) ($charHeight/20) $poly;
	if (`gmatch $deformJointsList[$i] "Shoulder_*"` || `gmatch $deformJointsList[$i] "Hip_*"`)
		xform -os -s ($charHeight/7) ($charHeight/7) ($charHeight/7) $poly;

//	parentConstraint $deformJointsList[$i] $poly;
	delete `parentConstraint $deformJointsList[$i] $poly`;
	parent $poly MannequinGeometry;
	catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//	scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	refresh;
	}
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;

if (`objExists shaderMannequin`) delete shaderMannequin;
if (`objExists shaderMannequinSG`) delete shaderMannequinSG;
shadingNode -n shaderMannequin -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name shaderMannequinSG;
connectAttr -f shaderMannequin.outColor shaderMannequinSG.surfaceShader;
setAttr -type float3 shaderMannequin.color 0.78 0.63 0.42;
setAttr shaderMannequin.ambientColor -type double3 0.53 0.42 0.25;

sets -e -forceElement shaderMannequinSG MannequinGeometry;


print ("// Mannequin created\n");
select -cl;
}

global proc asDeleteMannequin ()
{
string $deleteObjs[]={"MannequinGeometry","Mannequin_Geometry","Mannequin","wood","woodSG","woodShader"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asHidePolyBoxes (int $onOff)
{
if (!`objExists "BoxesGeometry"`)
	error "BoxesGeometry does not exists !\n";
setAttr -l 0 "BoxesGeometry.visibility";
setAttr -l ($onOff) "BoxesGeometry.visibility" (!$onOff);
if (!$onOff)
	setAttr -l ($onOff) "BoxesGeometry.visibility";
}

global proc asMirrorGeometry (string $geometry, int $L2R)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
int $vs[];
float $scale[3],$pos[3];
string $box,$matchBox;
string $allPCs[]=`listRelatives -type transform -c ($geometry+"Geometry")`;
for ($i=0;$i<size($allPCs);$i++)
	{
	$box=`substitute "ParentConstraint" $allPCs[$i] ""`;
	if ($L2R)
		$matchBox=`substitute "_L" $box "_R"`;
	else
		$matchBox=`substitute "_R" $box "_L"`;

	if ($box==$matchBox || `gmatch $box "*_M"`)
		continue;

	if (!`objExists $matchBox`)
		continue;

	$scale=`getAttr ($box+".scale")`;
	setAttr -type float3 ($matchBox+".scale") $scale[0] $scale[1] $scale[2];
	$vs=`polyEvaluate -v $box`;
	for ($y=0;$y<$vs[0];$y++)
		{
		$pos=`xform -q -ws -t ($box+".vtx["+$y+"]")`;
		xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($matchBox+".vtx["+$y+"]");
		}
	}
}

global proc asMirrorControlCurves (int $L2R, string $set)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
string $controlObjects[]=`sets -q $set`;
string $shapes[];
string $oppositeShape,$oppositeControlObject;
float $pos[];
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	if ($shapes[0]=="")
		continue;
	$objType=`objectType $shapes[0]`;
	if ($objType!="nurbsCurve")
		continue;

	if ($L2R)
		{
		if (!`gmatch $shapes[0] "*_L*"`)
			continue;
		}
	else
		{
		if (!`gmatch $shapes[0] "*_R*"`)
			continue;
		}

	if ($L2R)
		{
		$oppositeShape=`substitute "_L" $shapes[0] "_R"`;
		$oppositeControlObject=`substitute "_L" $controlObjects[$i] "_R"`;
		}
	else
		{
		$oppositeShape=`substitute "_R" $shapes[0] "_L"`;
		$oppositeControlObject=`substitute "_R" $controlObjects[$i] "_L"`;
		}

	if (!`objExists $oppositeShape`)
		continue;

	$form=`getAttr ($shapes[0]+".form")`;
	$spans=`getAttr ($shapes[0]+".spans")`;
	$degrees=`getAttr ($shapes[0]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;

	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($shapes[0]+".cv["+$y+"]")`;
		if ($y==0)	$z=2;
		if ($y==1)	$z=3;
		if ($y==2)	$z=0;
		if ($y==3)	$z=1;
		if ($y==4)	$z=2;
		if ($set=="SkinCageCurvesSet")
			{
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$z+"]");
			if ($y==2)
				xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv[4]");
			}
		else
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$y+"]");
		}

	//Mirror slideJoints
	if ($set=="SkinCageCurvesSet")
		{
		string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $controlObjects[$i]`;
		int $haveSliderJoint[4];
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
				$haveSliderJoint[$y]=1;
			else
				$haveSliderJoint[$y]=0;
		if ($haveSliderJoint[0] || $haveSliderJoint[1] || $haveSliderJoint[2] || $haveSliderJoint[3])
			{
			select $oppositeControlObject;
			asCreateSliders;
			//mirror .slide values
			for ($y=0;$y<4;$y++)
				{
				string $sliderJoint=$skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y;
				string $oppositeSliderJoint;
				if ($L2R) $oppositeSliderJoint=`substitute "_L" $sliderJoint "_R"`;
				else $oppositeSliderJoint=`substitute "_R" $sliderJoint "_L"`;
				if ($y==0) $oppositeSliderJoint=`substitute "0" $oppositeSliderJoint "2"`;
				if ($y==1) $oppositeSliderJoint=`substitute "1" $oppositeSliderJoint "3"`;
				if ($y==2) $oppositeSliderJoint=`substitute "2" $oppositeSliderJoint "0"`;
				if ($y==3) $oppositeSliderJoint=`substitute "3" $oppositeSliderJoint "1"`;
				if (`objExists $sliderJoint` && `objExists $oppositeSliderJoint`)
					setAttr ($oppositeSliderJoint+".slide") `getAttr ($sliderJoint+".slide")`;
				}
			}
		else // sliders might have been deleted, this should also mirror
			{
			string $oppositeSkinCurveSliderInfo[]=`asSkinCurveSliderInfo $oppositeControlObject`;
			int $oppositeHaveSliderJoint[4];
			for ($y=0;$y<4;$y++)
				if (`objExists ($oppositeSkinCurveSliderInfo[0]+"_"+$oppositeSkinCurveSliderInfo[1]+"Slider"+$y)`)
					$oppositeHaveSliderJoint[$y]=1;
			if ($oppositeHaveSliderJoint[0] || $oppositeHaveSliderJoint[1] || $oppositeHaveSliderJoint[2] || $oppositeHaveSliderJoint[3])
				{
				select $oppositeControlObject;
				asDeleteSliders;
				}
			}
		}
	}
select $sel;
}

global proc asScaleControlCurves ()
{
//scale selected if any control curves are selected, otherwice scale all
float $scale=`floatField -q -v ScaleCCFloatField`;
string $controlObjects[];
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (`sets -im ControlSet $sel[$i]`)
		$controlObjects[size($controlObjects)]=$sel[$i];
if (!size($controlObjects))
	$controlObjects=`sets -q "ControlSet"`;
string $controlCurves[];
string $tempString[];
for ($i=0;$i<size($controlObjects);$i++)
	{
	$tempString=`listRelatives -s $controlObjects[$i]`;
	if (!size($tempString))
		continue;
	select -cl;
	refresh;
	select -cl;
	for ($y=0;$y<100;$y++)
		select -add ($tempString[0]+".cv["+$y+"]");
	scale -r $scale $scale $scale;
	}
select $sel;
}

global proc string[] asSkinCurveSliderInfo (string $skinCurve)
{
string $info[];//[0]=$deformJoint [1]=start/middle/end [2]=restoreWeightsToJoint
string $childJoint;
string $tempString[];
tokenize $skinCurve "_" $tempString;
string $deformJoint=$tempString[0]+"_"+$tempString[1];
$info[0]=$deformJoint;
if (`gmatch $skinCurve "*_middleProfile"`)
	$info[1]="middle";
if (`gmatch $skinCurve "*_startProfile"`)
	$info[1]="start";
if (`gmatch $skinCurve "*_endProfile"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile1"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile[2-9]"`)
	{
	//First some traversing to find the childJoint
	$tempString=`listRelatives -c -type joint $deformJoint`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
		if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
		}
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -c -type joint $childJoint`;
		$childJoint="";
		for ($i=0;$i<size($tempString);$i++)
			{
			if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
			if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
			}
		}
	//Then see if it`s the lastTwister
	int $stringLenght=`size $skinCurve`;
	int $twistNr=`substring $skinCurve $stringLenght $stringLenght`;
	string $nextTwistProfile=`substring $skinCurve 1 ($stringLenght-1)`+($twistNr+1);
	if (!`objExists $nextTwistProfile`)
		{
		$info[0]=$childJoint;
		$info[1]="start";
		}
	}
//[2]=restoreWeightsToJoint
if (`gmatch $skinCurve "*_twistProfile1"`)
	{
	tokenize $skinCurve "_" $tempString;
	string $twistJoint=$tempString[0]+"Part1_"+$tempString[1];
	if (`objExists $twistJoint`)
		$info[2]=$twistJoint;
	else
		$info[2]=$info[0];
	}
else
	{
	$tempString=`listRelatives -p $info[0]`;
	if (`gmatch $skinCurve "*_endProfile"`)
		$info[2]=$info[0];
	else
		$info[2]=$tempString[0];
	}
return $info;
}

global proc asCreateMoCap ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
if (`objExists "MoCap"`)
	error "MoCap skeleton already exists !";
if (!`objExists "Main"`)
	error "No AdvancedSKeleton In Scene!";
string $deformJoints[]=`listRelatives -type joint -ad "DeformationSystem"`;
string $keyDeformJoints[],$tempString[],$parent[],$names[],$extra[];
string $extr;
for ($a=$i=0;$a<size($deformJoints);$a++)
	{
	if (`gmatch $deformJoints[$a] "*_50"`)
		continue;
	if (`gmatch $deformJoints[$a] "*Slider[0-9]*"`)
		continue;
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $deformJoints[$a]`)
			continue;
	tokenize $deformJoints[$a] "_" $tempString;
	$extr="FKExtra"+$tempString[0]+"_"+$tempString[1];
	if (`gmatch $deformJoints[$a] "*Part[0-9]*"`)
		continue;
	$keyDeformJoints[$i]=$deformJoints[$a];
	$extra[$i]=$extr;
	$tempString[0]=$keyDeformJoints[$i];
	for ($y=0;$y<99;$y++)
		{
		$tempString=`listRelatives -p $tempString[0]`;
		if (!`gmatch $tempString[0] "*Part[0-9]*"`)
			{
			tokenize $tempString[0] "_" $tempString;
			$parent[$i]=$tempString[0]+"_MoCap_"+$tempString[1];
			break;
			}
		}
	tokenize $keyDeformJoints[$i] "_" $tempString;
	string $name=$tempString[0]+"_MoCap_"+$tempString[1];
	if (!`stringArrayCount $name $names`)
		{
		$names[$i]=$name;
		$i++;
		}
	}

string $topJoint;
for ($i=0;$i<size($names);$i++)
	{
	select -cl;
	joint -n $names[$i];
	if ($i==size($names)-1)
		{
		createNode -n "MoCap" transform;
		createNode -n "CenterOffset" transform;
		asAlign "CenterOffset" RootExtraX_M 1 0 0 0;
		parent "MoCap" "Group";
		parent "CenterOffset" "MoCap";
		parent $names[$i] "CenterOffset";
		connectAttr ($names[$i]+".translate") ("RootExtraX_M.translate");
		$topJoint=$names[$i];
		}
	asAlign $names[$i] $keyDeformJoints[$i] 1 1 1 0;
	setAttr ($names[$i]+".rotateOrder") 1;
	if (`objExists $extra[$i]`)
		setAttr ($extra[$i]+".rotateOrder") 1;
	}

for ($i=0;$i<size($names);$i++)
	{
	if (`objExists $parent[$i]`)
		parent $names[$i] $parent[$i];
	}
for ($i=0;$i<size($names);$i++)
	{
	if (`objExists ($names[$i]+"_blendColor")`)
		delete ($names[$i]+"_blendColor");
	createNode -n ($names[$i]+"_blendColor") blendColors;
	connectAttr ($names[$i]+".rotate") ($names[$i]+"_blendColor.color1");
	addAttr -k 1 -ln "blend" -at double -min 0 -max 1 -dv 1 $names[$i];
	connectAttr ($names[$i]+".blend") ($names[$i]+"_blendColor.blender");
	if (`objExists $extra[$i]`)
		connectAttr ($names[$i]+"_blendColor.output") ($extra[$i]+".rotate");
	}
setAttr "MoCap.translateZ" ($charHeight/-3);
//orientConstraint -mo $topJoint "RootExtraX_M";
select $sel;
}

global proc asSetAllFK ()
{
string $controlSetMembers[]=`sets -q ControlSet`;
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".FKIKBlend") 0;
}

global proc float asGetSceneFps () 
{
float $fps;
string $fpsName=`currentUnit -q -time`;
if ($fpsName=="game") $fps=15;
if ($fpsName=="film") $fps=24;
if ($fpsName=="pal") $fps=25;
if ($fpsName=="ntsc") $fps=30;
if ($fpsName=="show") $fps=48;
if ($fpsName=="palf") $fps=50;
if ($fpsName=="ntscf") $fps=60;
if ($fpsName=="millisec") $fps=1000;
if ($fpsName=="sec") $fps=1;
if ($fpsName=="min") $fps=0.0166667;
if ($fpsName=="hour") $fps=0.000277778;
if (`gmatch $fpsName "*fps"`)
	$fps=`substitute "fps" $fpsName ""`;
return $fps;
}

global proc asReadBVH ()
{
global string $gMainProgressBar;
string $filename=`fileDialog -dm "*.bvh"`;
if (!`file -q -ex $filename`)
	return;

if (!`objExists bvhFile`)
	createNode -n bvhFile transform;

select -cl;
string $topNodesBefore[]=`ls -as`;

int $i=-1;
int $x,$lineNum,$frameNr,$motionBegin,$motionHasBegun;
int $jointNum,$chNum;
int $numChannels[];
float $offsetX,$offsetY,$offsetZ,$value;
float $rot[];
$fileId=`fopen $filename "r"`;
string $nextLine = `fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionBegin)
		$lineNum++;
	$nextLine = `fgetline $fileId`;
	}
$motionBegin=0;
fclose $fileId;
$fileId=`fopen $filename "r"`;
$nextLine = `fgetline $fileId`;
string $joints[],$buffer[],$channels[],$localChannels[];
float $currentTime=`currentTime -q`;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
currentTime -e -20;

progressBar -e -st "AdvancedSkeleton" -bp -ii 1 -min 0 -max ($lineNum+1) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
while ( size( $nextLine ) > 0 )
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		fclose $fileId;
		}

	tokenize $nextLine $buffer;
	if (`gmatch $nextLine "*}*"`)
		pickWalk -d up;
	if (`gmatch $nextLine "*JOINT*"` || `gmatch $nextLine "*ROOT*"` || `gmatch $nextLine "*End Site*"`)
		{
		$i++;
		$joints[$i]=$buffer[1];
		if ($joints[$i]=="Site")
			$joints[$i]=$joints[$i]+$i;
		joint -n ("MoCap"+$joints[$i]);
		setAttr ("MoCap"+$joints[$i]+".rotateOrder") 2;
		if (`gmatch $nextLine "*JOINT*"`)
			setKeyframe ("MoCap"+$joints[$i]+".rotate");
		}
	if (`gmatch $nextLine "*OFFSET*"`)
		{
		$offsetX=$buffer[1];
		$offsetY=$buffer[2];
		$offsetZ=$buffer[3];
		setAttr -type float3 ("MoCap"+$joints[$i]+".translate") $offsetX $offsetY $offsetZ;
		}
	if (`gmatch $nextLine "*CHANNELS*"`)
		{
		$numChannels[$i]=$buffer[1];
		for ($x=2;$x<size($buffer);$x++)
			$channels[$i]=$channels[$i]+`asReWord $buffer[$x]`+";";
		}

	if ($motionBegin)
		$motionHasBegun=1;
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionHasBegun)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$jointNum=0;
		tokenize $channels[$jointNum] ";" $localChannels;
		$chNum=-1;
		for ($y=0;$y<size($buffer);$y++)
			{
			$chNum++;
			if ($chNum>$numChannels[$jointNum]-1)
				{
				$jointNum++;
				if (`gmatch $joints[$jointNum] "Site*"`)
					$jointNum++;
				tokenize $channels[$jointNum] ";" $localChannels;
				$chNum=0;
				}
			$value=$buffer[$y];
//			currentTime -e ($frameNr+1);
			if (`gmatch $localChannels[$chNum] "*rotate*"`)
				{
				if ($localChannels[$chNum]=="rotateX")
					$rot[0]=$value;
				if ($localChannels[$chNum]=="rotateY")
					$rot[1]=$value;
				if ($localChannels[$chNum]=="rotateZ")
					$rot[2]=$value;
				if ($chNum==2 || $chNum==5)
					{
					asSetMoCapRot ("MoCap"+$joints[$jointNum]) $rot;
					setKeyframe -t $frameNr ("MoCap"+$joints[$jointNum]+".rotate");
					}
				}
			else
				setKeyframe -v $value -t $frameNr ("MoCap"+$joints[$jointNum]+"."+$localChannels[$chNum]);
			}
		$frameNr++;
		}
	$nextLine = `fgetline $fileId`;
	}
progressBar -e -ep $gMainProgressBar;
currentTime -e $currentTime;
autoKeyframe -state $autoKeyframe;
fclose $fileId;

string $topNodesAfter[]=`ls -as`;
string $moCapTopNode;
for ($i=0;$i<size($topNodesAfter);$i++)
	{
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		{
		$moCapTopNode=$topNodesAfter[$i];
		parent $moCapTopNode bvhFile;
		}
	}

//clean statics
string $bhvJoints[]=`listRelatives -ad -type joint bvhFile`;
select $bhvJoints;
delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1;

//Scale to match Root height
string $tempString[]=`listConnections -scn 1 ($moCapTopNode+".ty")`;
if ($tempString[0]!="")
	{
	$tyAnimCurve=$tempString[0];
	string $tempString[]=`listRelatives -c -type joint DeformationSystem`;
	string $root=$tempString[0];
	float $rootHeigh=`getAttr ($root+".ty")`;
	float $keyValues[]=`keyframe -in 0 -q -vc $tyAnimCurve`;
	float $scaleFactor=$rootHeigh/$keyValues[0];
	setAttr -type float3 bvhFile.s $scaleFactor $scaleFactor $scaleFactor;
	}
//Scale keys to match frameRate
float $bvhFps=`floatField -q -v asBVHfps`;
float $sceneFps=`asGetSceneFps`;
float $scaleTime=$sceneFps/$bvhFps;
string $animCurves[];
select -cl;
for ($i=0;$i<size($bhvJoints);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -scn 1 -type animCurve $bhvJoints[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		selectKey -add -k -t "0:99999" $animCurves[$y];
	}
scaleKey -iub false -ts $scaleTime -tp 0 -fs $scaleTime -fp 0 -vs 1 -vp 0 -animation keys ;

playbackOptions -min 0 -ast 0 -max ($frameNr*$scaleTime) -aet ($frameNr*$scaleTime);
currentTime 0;

select -cl;
}

global proc asDeleteMocap ()
{
if (`objExists MoCap`)
	delete MoCap;
delete `ls -type blendColors "*_MoCap_*_blendColor"`;
}

global proc asDeleteBHV ()
{
if (`objExists bvhFile`)
	delete bvhFile;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asAutoMapMocap ()
{
float $charHeight=`asgetCharHeight`;
string $tempString[]=`listRelatives -c -type joint bvhFile`;
string $bvhTopJoint=$tempString[0];
$tempString=`listRelatives -c -type joint CenterOffset`;
string $moCapTopJoint=$tempString[0];
$tempString=`pointConstraint $bvhTopJoint $moCapTopJoint`;
setAttr ($tempString[0]+".offsetZ") ($charHeight/3);

catch (`orientConstraint -mo $bvhTopJoint $moCapTopJoint`);

catch (`orientConstraint -mo MoCapRightUpLeg Hip_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftUpLeg Hip_MoCap_L`);
catch (`orientConstraint -mo MoCapRightLeg Knee_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftLeg Knee_MoCap_L`);
catch (`orientConstraint -mo MoCapRightFoot Ankle_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftFoot Ankle_MoCap_L`);
catch (`orientConstraint -mo MoCapRightToeBase Toes_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftToeBase Toes_MoCap_L`);

catch (`orientConstraint -mo MoCapLowerBack Root_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine Spine1_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine1 Chest_MoCap_M`);
catch (`orientConstraint -mo MoCapRightShoulder Scapula_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftShoulder Scapula_MoCap_L`);
catch (`orientConstraint -mo MoCapRightArm Shoulder_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftArm Shoulder_MoCap_L`);
catch (`orientConstraint -mo MoCapRightForeArm Elbow_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftForeArm Elbow_MoCap_L`);
catch (`orientConstraint -mo MoCapRightHand Wrist_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftHand Wrist_MoCap_L`);

catch (`orientConstraint -mo MoCapRThumb ThumbFinger2_MoCap_R`);
catch (`orientConstraint -mo MoCapLThumb ThumbFinger2_MoCap_L`);

catch (`orientConstraint -mo MoCapNeck1 Neck_MoCap_M`);
catch (`orientConstraint -mo MoCapHead Head_MoCap_M`);
}

global proc asDeleteMocapMap ()
{
delete `listRelatives -ad -type constraint MoCap`;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asSetMoCapRot (string $obj, float $rot[])
{
setAttr -type float3 ($obj+".rotate") 0 0 0;
float $rotX=$rot[0];
float $rotY=$rot[1];
float $rotZ=$rot[2];
rotate -r -os 0 0 $rotZ $obj;
rotate -r -os $rotX 0 0 $obj;
rotate -r -os 0 $rotY 0 $obj;
}

global proc string asReWord (string $bvhWord)
{
if ($bvhWord=="Xposition")
	return "translateX";
if ($bvhWord=="Yposition")
	return "translateY";
if ($bvhWord=="Zposition")
	return "translateZ";
if ($bvhWord=="Xrotation")
	return "rotateX";
if ($bvhWord=="Yrotation")
	return "rotateY";
if ($bvhWord=="Zrotation")
	return "rotateZ";
return "";
}

global proc asCreatePartialJoints ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $dialog=`confirmDialog -t "Confirm"
	-m "Create Partial Joints for all deformJoints ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "DeformSet"`)
	return;

float $charHeight=`asgetCharHeight`;
int $sideFactor;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $children[],$partialJoints[],$zero[],$parents[],$buffer[],$tempString[];
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$children=`listRelatives -type joint -c $deformJointsList[$i]`;
	$parents=`listRelatives -type joint -p $deformJointsList[$i]`;
	if (!size($children) || !size($parents) || `gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	select $deformJointsList[$i];
	tokenize $deformJointsList[$i] "_" $buffer;
	$partialJoints[$i]=$buffer[0]+"50_"+$buffer[1];
	$partialJoints[$i]=$buffer[0]+"_"+$buffer[1]+"_50";
	$zero[$i]=$buffer[0]+"_"+$buffer[1]+"_00";
	if (`objExists $partialJoints[$i]`)
		error ("PartialJoints already exists");
	joint -n $partialJoints[$i];
	parent $partialJoints[$i] $parents[0];
	setAttr ($partialJoints[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $partialJoints[$i];
	sets -add "DeformSet" $partialJoints[$i];
	select $parents[0];
	createNode -n $zero[$i] transform;
	parent $zero[$i] $parents[0];
	setAttr -type float3 ($zero[$i]+".t") 0 0 0;
	setAttr -type float3 ($zero[$i]+".r") 0 0 0;
	setAttr ($zero[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $zero[$i];
	$tempString=`orientConstraint $zero[$i] $deformJointsList[$i] $partialJoints[$i]`;
	$tempString=`pointConstraint $deformJointsList[$i] $partialJoints[$i]`;
	setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
	}
select -cl;
for ($i=0;$i<size($deformJointsList);$i++)
	if (`gmatch $partialJoints[$i] "*_?_50"`)
		select -add $partialJoints[$i];
}

global proc asDeletePartialJoints ()
{
if (!`objExists "DeformSet"`)
	return;

string $DeformationSystemNodes[]=`listRelatives -ad "DeformationSystem"`;
for ($i=0;$i<size($DeformationSystemNodes);$i++)
	if (`attributeExists partialJoint $DeformationSystemNodes[$i]`)
		delete $DeformationSystemNodes[$i];
}

global proc asPopulateDrivingSystemsPopupMenu (string $action)
{
string $popupMenu="as"+$action+"DrivingSystemsPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
int $numKeys,$delete;
if ($action=="Delete") $delete=1;
float $keyValues[];
string $cmd,$animCurve;
string $drivingSystems[],$tempString[],$attrs[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	//$menu1s
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph") $sm=0;
	$lev1Menu=`menuItem -sm $sm -l $drivingSystems[$i]`;
	if ($action=="Graph")
		{
		string $udAttrs[]=`listAttr -ud $drivingSystems[$i]`;
		$cmd="select ";
		for ($attr in $udAttrs)
			{
			$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$attr)`;
			for ($node in $tempString)
				$cmd+=$node+" ";
			}
		$cmd+=";GraphEditor;";
		menuItem -e -c $cmd $lev1Menu;
		continue;
		}

	//$menu2s
	$attrs=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		setParent -menu $lev1Menu;
		$lev2Menu=`menuItem -sm $sm -l $attrs[$y]`;
	
		//$menu3s
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$attrs[$y])`;
		$animCurve=$tempString[0];
		$numKeys=`keyframe -q -keyframeCount $animCurve`;
		for ($x=0;$x<$numKeys;$x++)
			{
			$keyValues=`keyframe -in $x -q -fc $animCurve`;
			$keyValues[0]=`asRoundOff $keyValues[0] 3`;
			if($keyValues[0]==0)
				continue;
			$cmd="asEditDrivingSystem "+$delete+" "+$drivingSystems[$i]+" "+$attrs[$y]+" "+$keyValues[0];
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 0 -l $keyValues[0] -c $cmd`;
			}
		}
	}
}

global proc asAutoFindAndEditDrivingSystem ()
{
string $drivingSystems[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
string $drivingSystem="";
string $driveAttr="";
float $driveValue=0;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	string $udAttrs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($udAttrs);$y++)
		{
		float $value=`getAttr ($drivingSystems[$i]+"."+$udAttrs[$y])`;
		$value=`asRoundOff $value 3`;
		if ($value!=0)
			{
			if ($drivingSystem!="")
				error ("Found multiple driver values set: "+$drivingSystem+"."+$driveAttr+" AND "+$drivingSystems[$i]+"."+$udAttrs[$y]);
			$drivingSystem=$drivingSystems[$i];
			$driveAttr=$udAttrs[$y];
			$driveValue=$value;
			}
		}
	}
if ($drivingSystem=="")
	warning "Either right click on this button to edit specific drive-values, or set a driver-value, and click the button";
else
	asEditDrivingSystem 0 $drivingSystem $driveAttr $driveValue;
}

global proc asEditDrivingSystem (int $delete, string $obj, string $attr, float $value)
{
int $numDriven;
float $drivenValues[];
string $stripName;
string $drivenObjs[],$drivenAttrs[],$drivenSdkNode[];
string $tempString2[];
string $tempString[]=`listConnections -scn 1 ($obj+"."+$attr)`;
setAttr ($obj+"."+$attr) $value;
for ($i=0;$i<size($tempString);$i++)
	if (size(`ls -type animCurve $tempString[$i]`))	
		{
		tokenize $tempString[$i] "_" $tempString2;
		$drivenSdkNode[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+"_";
			}
		$stripName=`substring $tempString[$i] 5 99`;
		if (`gmatch $stripName "[0-9]*"`)
			$stripName=`substring $stripName 2 99`;
		tokenize $stripName "_" $tempString2;
		$drivenObjs[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+"_";
			}
		string $drivenAttr=$tempString2[size($tempString2)-1];
		if (`gmatch $drivenAttr "*[0-9]"`)
			{
			int $numChars=size($drivenAttr);
			$drivenAttr=`substring $drivenAttr 1 ($numChars-1)`;
			}
		$drivenAttrs[$numDriven]=$drivenAttr;
		$drivenValues[$numDriven]=`getAttr ($drivenSdkNode[$numDriven]+"."+$drivenAttrs[$numDriven])`;
		$numDriven++;
		}

asGoToBuildPose bodySetup;

if ($delete)
	{
	//remove entry in buildPose
	string $buildPoseCmd=`getAttr buildPose.udAttr`;
	tokenize $buildPoseCmd ";" $tempString;
	string $newBuildPoseCmd="";
	for ($i=0;$i<size($tempString);$i++)
		if (!`gmatch $tempString[$i] ("setAttr "+$obj+"."+$attr+"*")`)
			$newBuildPoseCmd+=$tempString[$i]+";";
	setAttr -type "string" buildPose.udAttr $newBuildPoseCmd;
	//remove associated SdkXforms (that dont have another drivers driving them as well)
	$tempString=`listConnections -scn 1 -s 0 -d 1 ($obj+"."+$attr)`;
	for ($i=0;$i<size($tempString);$i++)
		if (size(`ls -type animCurve $tempString[$i]`))
			{
			$tempString2=`listConnections -scn 1 -s 0 -d 1 ($tempString[$i]+".output")`;
			$SdkXform=$tempString2[0];
			$tempString2=`listConnections -scn 1 -s 1 -d 0 $SdkXform`;
			if(size($tempString2)==1)
				{
				parent `listRelatives -c $SdkXform` `listRelatives -p $SdkXform`;
				delete $SdkXform;
				}
			}
	//remove attr
	deleteAttr ($obj+"."+$attr);
	//remove controller if there`s no attributes left
	$tempString=`listAttr -ud $obj`;
	if (!size($tempString))
		delete $obj;
	return;
	}

for ($i=0;$i<size($drivenObjs);$i++)
	setAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i]) $drivenValues[$i];
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
headsUpDisplay -s 2 -b 0 -bs "medium" -l ("Editing Driving System:  "+$obj+"."+$attr+"="+$value) -lfs "large" HUDEDSMode;
rowLayout -e -en 1 asDSEditChoicesRowLayout;

//select one of the drivenControls, to hint what to modify
select $drivenObjs;
}

global proc asDrivingSystemEditCancel ()
{
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
rowLayout -e -en 0 asDSEditChoicesRowLayout;
asGoToBuildPose bodySetup;
}

global proc asDrivingSystemEditApply ()
{
asCreateDrivingSystem;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
rowLayout -e -en 0 asDSEditChoicesRowLayout;
}

global proc asCreateDrivingSystemLayout ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global string $asDSAltPivot;
global int $asDSAdvancedOptions;
string $tempString[];
tokenize $asDSMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asDSMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asDSMessage+=$tempString[$i]+"\n";
	$asDSMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout -adj 0;
columnLayout -adj 0;
	text -l $asDSMessage;
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 1 asDSInputsColumnLayout;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 asDSAttrNameTextField;
		setParent..;
	rowLayout -nc 3 asDSControlNameRowLayout;
		text -w 100 -l "Control Name:";
		textField -w 80 asDSObjNameTextField;
		setParent..;
	rowLayout -en 0 -nc 4 asDSUseControlRowLayout; 
	    separator -w 5 -st none;
	    checkBox -w 95 -l "Use Control:"
	    	-onc "optionMenu -e -en 1 asDSObjNameOptionMenu;rowLayout -e -en 0 asDSControlNameRowLayout;"
	    	-ofc "optionMenu -e -en 0 asDSObjNameOptionMenu;rowLayout -e -en 1 asDSControlNameRowLayout;"
	    	asDSUseControlCheckBox;
    	optionMenu -en 0 asDSObjNameOptionMenu;
		setParent..;
	if ($asDSAdvancedOptions)
		{
		separator;
		text -l "Attribute limits:";
		rowLayout -en 1 -nc 8;
			checkBox -w 40 -v 1 -l "min:" asDSAttrHasMin;
			floatField -w 30 -v 0 -pre 1 asDSAttrMin;
			separator -w 10 -st none;
			checkBox -w 40 -v 1 -l "max:" asDSAttrHasMax;
			floatField -w 30 -v 10 -pre 1 asDSAttrMax;
			setParent..;
		separator -h 5 -st none;
		checkBox -l "Use Soft limits" -v 1 asDSAttrSoftLimits;
		}
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 0;
	rowLayout -nc 3 asDSMirrorRowLayout;
			text -w 100 -l "Mirror:";
    	checkBox -l "" -v 1 asDSMirrorCheckBox;
		setParent..;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asCreateDrivingSystemGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;

//populate asDSObjNameOptionMenu
string $drivingSystems[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
if (size($drivingSystems))
	rowLayout -e -en 1 asDSUseControlRowLayout;
setParent -menu asDSObjNameOptionMenu;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (`gmatch $drivingSystems[$i] "*_L"`)
		continue;
	menuItem -l $drivingSystems[$i];
//	int $numChar=size($drivingSystems[$i]);
//	string $subString=`substring $drivingSystems[$i] 1 ($numChar-2)`;
//	menuItem -l $subString;
	}

//fill out fields if we are editing
if ($asDSObjName!="")
	{
	textField -e -ed 0 -tx $asDSAttrName asDSAttrNameTextField;
	rowLayout -e -en 0 asDSControlNameRowLayout;
	checkBox -e -en 1 -v 1 asDSUseControlCheckBox;
	optionMenu -e -en 1 -v $asDSObjName asDSObjNameOptionMenu;
	columnLayout -e -m 0 asDSInputsColumnLayout;

	string $oppositeObjName="";
	if (`gmatch $asDSObjName "*_R"`) $oppositeObjName=`substitute "_R" $asDSObjName "_L"`;
	if (`gmatch $asDSObjName "*_L"`) $oppositeObjName=`substitute "_L" $asDSObjName "_R"`;
	if (!`objExists $oppositeObjName`)
		{
		checkBox -e -v 0 asDSMirrorCheckBox;
		rowLayout -e -en 0 asDSMirrorRowLayout;
		}
	}
}

global proc string asCreateSDKXform (string $drivenObj)
{
global string $asDSAltPivot;
string $tempString[]=`listRelatives -p $drivenObj`;
string $parent=$tempString[0];
string $child=$drivenObj;
int $isFace=0;
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObj`)
		$isFace=1;

string $sdkXform;
if (`gmatch $parent "*Extra*"`)
	{
	$child=$parent;
	$tempString=`listRelatives -p $parent`;
	$parent=$tempString[0];
	}
for ($y=1;$y<99;$y++)
	{
	$sdkXform="SDK"+$y+$drivenObj;
	if (!`objExists $sdkXform`)
		break;
	}
createNode -n $sdkXform -p $parent transform;
sets -add AllSet $sdkXform;
setAttr ($sdkXform+".rotateOrder") `getAttr ($drivenObj+".rotateOrder")`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1;

//$asDSAltPivot
// could be _R, but should be _L
if (`gmatch $drivenObj "*_L"` && `gmatch $asDSAltPivot "*_R"`)
	$asDSAltPivot=`substitute "_R" $asDSAltPivot "_L"`;
if ($asDSAltPivot!="" && `objExists $asDSAltPivot`)
	{
	createNode -n ($sdkXform+"AltPivotOffset1") transform;
	createNode -n ($sdkXform+"AltPivotOffset2") transform;
	sets -add AllSet ($sdkXform+"AltPivotOffset1") ($sdkXform+"AltPivotOffset2");
	asAlign ($sdkXform+"AltPivotOffset1") $asDSAltPivot 1 1 0 1;
	asAlign ($sdkXform+"AltPivotOffset2") $sdkXform 1 1 0 0;
	asAlign $sdkXform $asDSAltPivot 1 1 0 1;
	$tempString=`listRelatives -p $sdkXform`;
	parent ($sdkXform+"AltPivotOffset1") $tempString[0];
	parent $sdkXform ($sdkXform+"AltPivotOffset1");
	parent ($sdkXform+"AltPivotOffset2") $sdkXform;
	parent $child ($sdkXform+"AltPivotOffset2");
	}
else if (!$isFace)
	parent $child $sdkXform;

//connect Face $sdkXform
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
if ($isFace)
	{
	int $numChar=size($child);
	string $fitJoint=`substring $child 1 ($numChar-2)`;
	string $side=`substring $child ($numChar-1) 99`;
	string $destinaton=$fitJoint+"Joint"+$side;
	if (!`objExists $destinaton`)
		$destinaton=$fitJoint+"Cluster"+$side+"Handle";
	if (!`objExists ($fitJoint+"DSPlust"+$side)`)
		for ($y=0;$y<size($trs);$y++)
			{
			createNode -n ($fitJoint+"DSPlus"+$trs[$y]+$side) plusMinusAverage;
			connectAttr ($child+"."+$trs[$y]) ($fitJoint+"DSPlus"+$trs[$y]+$side+".input3D[0]");
			for ($z=0;$z<size($xyz);$z++)
				connectAttr -f ($fitJoint+"DSPlus"+$trs[$y]+$side+".output3D"+$xyz[$z]) ($destinaton+"."+$trs[$y]+$xyz[$z]);
			int $numExisting=`getAttr -s ($fitJoint+"DSPlus"+$trs[$y]+$side+".input3D")`;
			connectAttr ($sdkXform+"."+$trs[$y]) ($fitJoint+"DSPlus"+$trs[$y]+$side+".input3D["+$numExisting+"]");
			}
	}
return $sdkXform;
}

global proc asCreateDrivingSystemGetName ()
{
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global float $asDSAttrMin;
global float $asDSAttrMax;
global int $asDSMirror;
int $result;
$asDSAttrName=`textField -q -tx asDSAttrNameTextField`;
if (`rowLayout -q -en asDSControlNameRowLayout`)
	$asDSObjName=`textField -q -tx asDSObjNameTextField`;
else
	$asDSObjName=`optionMenu -q -v asDSObjNameOptionMenu`;
$asDSAttrHasMin=1;
$asDSAttrHasMax=1;
$asDSAttrSoftLimits=1;
$asDSAttrMin=0;
$asDSAttrMax=10;
if (`checkBox -q -ex asDSAttrHasMin`) $asDSAttrHasMin=`checkBox -q -v asDSAttrHasMin`;
if (`checkBox -q -ex asDSAttrHasMax`) $asDSAttrHasMax=`checkBox -q -v asDSAttrHasMax`;
if (`checkBox -q -ex asDSAttrSoftLimits`) $asDSAttrSoftLimits=`checkBox -q -v asDSAttrSoftLimits`;
if (`floatField -q -ex asDSAttrMin`) $asDSAttrMin=`floatField -q -v asDSAttrMin`;
if (`floatField -q -ex asDSAttrMax`) $asDSAttrMax=`floatField -q -v asDSAttrMax`;
$asDSMirror=`checkBox -q -v asDSMirrorCheckBox`;
}

global proc string[] asCreateDrivingSystem ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global string $asDSAltPivot;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global int $asDSMirror;
global int $asDSAdvancedOptions;
global int $asBuilding;
global int $asRebuilding;
global float $asDSAttrMin;
global float $asDSAttrMax;

$asDSAdvancedOptions=0;
int $modifier=`getModifiers`;
if ($modifier==4)
	$asDSAdvancedOptions=1;
int $isFace=0;
string $sel[]=`ls -sl`;
string $sdkXforms[];

int $isEditing,$reusingSdkXform;
float $runValues[],$pos[],$drivenValues[];
float $poseValue,$currentValue,$maxDistAmoungDrivens,$minX,$maxX,$minY,$maxY,$minZ,$maxZ,$difX,$difY,$difZ,$controlScale,$min,$dist;
string $parent,$child,$obj,$drivenObj,$drivenAttr,$m,$controllerName,$sdkXform,$side,$oppositeSide;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$drivens[],$sdkDrivens[],$runObjAttrs[],$checkObjAttr[],$drivenObjs[],$buildPoseCmds[],$runCmds[];
string $existingSdkXforms[];
float $driverValue=10;
float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;

//Do we come from AdvancedSkeleton BUILD Mode ?
int $comeFromASBuild=0;
if ($asBuilding || $asRebuilding)
	$comeFromASBuild=1;
else
	{
	$asDSObjName="";
	$asDSAttrName="";
	}

//Do we come from EditDrivingSystemMode ?
int $comeFromEDSMode=0;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	$tempString[0]=`headsUpDisplay -q -l HUDEDSMode`;
	tokenize $tempString[0] "[:]" $tempString;
	$tempString[1]=`strip $tempString[1]`;
	tokenize $tempString[1] "=" $tempString;
	$driverValue=$tempString[1];
	tokenize $tempString[0] "[.]" $tempString;
	$asDSObjName=$tempString[0];
	$asDSAttrName=$tempString[1];
	$comeFromEDSMode=1;
	}

//Find driven attribute(s)
//get $buildPoseCmds
$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}

for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<size($buildPoseCmds);$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
	{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			tokenize $objAttr "." $tempString3;
			$obj=$tempString3[0];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;

			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				{
				$tempString2=`listRelatives -p $obj`;
				if ($tempString2[0]=="DrivingSystem")
					error ("Found \""+$checkObjAttr[$z]+"\", which is a DrivingSystem attribute. To modify this right>click on the \"Edit\" button");
				else
					{
					//Creating new DrivingSystem
					$drivens[size($drivens)]=$checkObjAttr[$z];
					if (!`stringArrayCount $obj $drivenObjs`)
						$drivenObjs[size($drivenObjs)]=$obj;
					}
				if (`gmatch $checkObjAttr[$z] "*_L*[.]*"`)
					error ("Found modified values on the Left side ("+$checkObjAttr[$z]+"), Only modify Right side (or middle)");
				}
			}
		}
	}
if (size($drivens)==0)
	error ("Found no driven attributes, all controls are in Build-Pose");

string $buildPoseNode="buildPose";
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObjs[0]`)
		{
		$isFace=1;
		$buildPoseNode="faceBuildPose";
		}

if ($comeFromEDSMode)
	{
	$isEditing=1;
	$m="Edit:  "+$asDSObjName+"."+$asDSAttrName+"="+$driverValue+"\n\n";
	for ($i=0;$i<size($drivens);$i++)
		{
		float $value=`getAttr $drivens[$i]`;
		$value=`asRoundOff $value 3`;
		$m+=$drivens[$i]+" = "+$value+"\n";	
		}
	}
else
	{
	$m="Create system to drive these attributes?\n\n";
	for ($i=0;$i<size($drivens);$i++)
		{
		float $value=`getAttr $drivens[$i]`;
		$value=`asRoundOff $value 3`;
		$m+=$drivens[$i]+" = "+$value+"\n";
		}
	}

$asDSMessage=$m;

if (!$comeFromASBuild)
	{
	string $dialogResult=`layoutDialog -t "Confirm" -ui asCreateDrivingSystemLayout`;
	if ($dialogResult!="OK")
		return {""};
	}

$side="_M";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	if (`gmatch $drivenObjs[$i] "*_R"`) $side="_R";
	if (`gmatch $drivenObjs[$i] "*_L"`) $side="_L";
	if ($side!="_M") break;
	}
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1 && !$asDSMirror)
		continue;
	if ($b==-1 && $side=="_M")
		continue;
	if      ($b==-1 && $side=="_R") {$side="_L";$oppositeSide="_R";}
	else if ($b==-1 && $side=="_L") {$side="_R";$oppositeSide="_L";}
	for ($i=0;$i<size($drivenObjs);$i++)
		if ($b==-1)
			$drivenObjs[$i]=`substitute $oppositeSide $drivenObjs[$i] $side`;
	for ($i=0;$i<size($drivens);$i++)
		if ($b==-1)
			$drivens[$i]=`substitute $oppositeSide $drivens[$i] $side`;

	string $controllerName=$asDSObjName;
	if (!`gmatch $controllerName "*_[A-Z]"`)
		$controllerName+=$side;
	if ($asDSObjName=="")
		for ($y=1;$y<99;$y++)
			{
			$controllerName="DrivingSystem"+$y+$side;
			if (!`objExists $controllerName`)
				break;
			}
	string $attrName=$asDSAttrName;
	if ($attrName=="")
		for ($y=1;$y<99;$y++)
			{
			$attrName="driver"+$y;
			if (!`attributeExists $attrName $controllerName`)
				break;
			}


//	if ($b==-1){$side=$oppositeSide;if ($side=="_R") $oppositeSide="_L";if ($side=="_L") $oppositeSide="_R";}
	if (`objExists $controllerName`) //use-existing-Control
		{
//		$controllerName=$asDSObjName;
		if ($b==-1) $controllerName=`substitute $oppositeSide $controllerName $side`;
		}
	else
		asCreateDrivingSystemController $controllerName $drivenObjs;

	if (!`attributeExists $attrName $controllerName`)
		{
		addAttr -k 1 -ln $attrName -at double $controllerName;
		if ($asDSAttrHasMin && $asDSAttrSoftLimits)
			addAttr -e -ln "test2" -hasSoftMinValue 1 -softMinValue $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMin && !$asDSAttrSoftLimits)
			addAttr -e -ln "test2" -min $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && $asDSAttrSoftLimits)
			addAttr -e -ln "test2" -hasSoftMaxValue 1 -softMaxValue $asDSAttrMax ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && !$asDSAttrSoftLimits)
			addAttr -e -ln "test2" -max $asDSAttrMax ($controllerName+"."+$attrName);
		}
	else
		{
		if ($driverValue<0)
			addAttr -e -softMinValue $driverValue ($controllerName+"."+$attrName);
		else if ($driverValue>10)
			addAttr -e -softMaxValue $driverValue ($controllerName+"."+$attrName);
		}

	for ($i=0;$i<size($drivens);$i++)
		{
		tokenize $drivens[$i] "[.]" $tempString;
		$drivenAttr=$tempString[1];
		$reusingSdkXform=0;
		if ($drivenObj!=$tempString[0])//first attr in new obj
			{
			$drivenObj=$tempString[0];
			
			//See if there is a existing SDKXfrom for this driver/target combo
			$existingSdkXforms=`ls ("SDK*"+$drivenObj)`;
			for ($y=0;$y<size($existingSdkXforms);$y++)
				{
				$tempString2=`listConnections -scn 1 -s 1 -d 0 $existingSdkXforms[$y]`;
				for ($z=0;$z<size($tempString2);$z++)
					{
					$tempString3=`listConnections -scn 1 -s 1 -d 0 -p 1 $tempString2[$z]`;
					for ($a=0;$a<size($tempString3);$a++)
						if ($tempString3[$a]==$controllerName+"."+$attrName)
							{
							$sdkXform=$existingSdkXforms[$y];
							$reusingSdkXform=1;
							}
					}
				}
			if (!$reusingSdkXform)
				$sdkXform=`asCreateSDKXform $drivenObj`;
			$sdkDrivens[$i]=$sdkXform+"."+$drivenAttr;
			}
		$sdkDrivens[$i]=$sdkXform+"."+$drivenAttr;
		$sdkXforms[size($sdkXforms)]=$sdkXform;
		}
	
	if ($b==1)
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;

	if ($b==-1)	//use asMirror to get mirrorValues
		{
		string $restorePoseCmd=`asGetRestorePoseCmd`;
		if (`window -q -ex tempWindow`)
			deleteUI tempWindow;
		window tempWindow;
		columnLayout;
		optionMenu tempWindowOptionMenu;
			menuItem -l ":";
		text -l "ControlSet " tempWindowControlSetsText;
		optionVar -sv asMOSide "asMOSideR2L";
		optionVar -sv asMOSpace "asMOSpaceMain";
		optionVar -sv asMOAxis "asMOAxisX";
		optionVar -sv asMOSelOnly "asMOSelOnlyAll";
		if ($isFace)
			text -e -l "FaceControlSet " tempWindowControlSetsText;
		asMirror tempWindow;
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;
		deleteUI tempWindow;
		eval($restorePoseCmd);
		}

	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValues[$i] -dv $driverValue -cd ($controllerName+"."+$attrName) $sdkDrivens[$i];
	string $restorePoseCmd=`asGetRestorePoseCmd`;
	if ($isFace)
		asGoToBuildPose faceSetup;
	else
		asGoToBuildPose bodySetup;
	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v `getAttr $drivens[$i]` -dv 0 -cd ($controllerName+"."+$attrName) $sdkDrivens[$i];
	for ($i=0;$i<size($sdkDrivens);$i++)
		setInfinity -pri cycleRelative -poi cycleRelative $sdkDrivens[$i];
	eval($restorePoseCmd);
	if (!$isEditing)
		setAttr -type "string" ($buildPoseNode+".udAttr") (`getAttr ($buildPoseNode+".udAttr")`+";setAttr "+$controllerName+"."+$attrName+" 0;");
	//AltPivot attribute
	for ($i=0;$i<size($sdkDrivens);$i++)
		{
		if ($asDSAltPivot=="")
			continue;
		$tempString=`listConnections $sdkDrivens[$i]`;
		addAttr -ln altPivot -dt "string" $tempString[0];
		setAttr -type "string" ($tempString[0]+".altPivot") $asDSAltPivot;
		}
	}
select -cl;
if ($isFace)
	asGoToBuildPose faceSetup;
else
asGoToBuildPose bodySetup;
asOptimizeDrivingSystemControllers;
if (!$asBuilding && !$asRebuilding)
	asDrivingSystemToFitSkeleton;
return $sdkXforms;
}

global proc asOptimizeDrivingSystemControllers ()
{
string $sel[]=`ls -sl`;
int $numChar;
float $maxDist,$maxY;
float $pos[3],$pos2[3];
string $constraintTo,$deformJoint,$rlaChild,$endJoint;
string $tempString[],$animCurves[],$allDrivenObjs[],$allDrivenDeformJoints[],$longNames[],$parents[];
createNode -n tempSamplerOffset transform;
createNode -n tempSampler -p tempSamplerOffset transform;

if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($a=0;$a<size($drivingSystems);$a++)
	{
	if (`objExists ($drivingSystems[$a]+"_parentConstraint1")`)
		delete ($drivingSystems[$a]+"_parentConstraint1");
	asLockAttr $drivingSystems[$a] 0 0 0 1;

	//Find common ancestors
	clear $allDrivenDeformJoints;
	clear $longNames;
	$animCurves=`listConnections -s 0 -d 1 -type animCurve $drivingSystems[$a]`;	
	for ($i=0;$i<size($animCurves);$i++)
		{
		tokenize $animCurves[$i] "_" $tempString;
		$numChar=`size $animCurves[$i]` - `size($tempString[size($tempString)-1])` - 1;
		$allDrivenObjs[$i]=`substring $animCurves[$i] 4 $numChar`;
		if (`gmatch $allDrivenObjs[$i] "[0-9]*"`)
			$allDrivenObjs[$i]=`substring $allDrivenObjs[$i] 2 99`;
		$deformJoint=$allDrivenObjs[$i];
		if (`gmatch $allDrivenObjs[$i] "FK*"`)
			$deformJoint=`substitute "FK" $allDrivenObjs[$i] ""`;
		if (!`stringArrayCount $deformJoint $allDrivenDeformJoints`)
			$allDrivenDeformJoints[size($allDrivenDeformJoints)]=$deformJoint;
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$tempString=`ls -l $allDrivenDeformJoints[$i]`;
		$longNames[$i]=$tempString[0];
		select $drivingSystems[$a];
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 1 0 $allDrivenDeformJoints[$i] $drivingSystems[$a];
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		tokenize $longNames[$i] "|" $parents;
		for ($y=size($parents)-2;$y>-1;$y--)
			{
			$numOthersHaveThisParent=0;
			for ($z=0;$z<size($longNames);$z++)
			if (`gmatch $longNames[$z] ("*|"+$parents[$y]+"|*")`)
				$numOthersHaveThisParent++;
			if ($numOthersHaveThisParent==size($longNames))
				{
				$constraintTo=$parents[$y];
				$i=999;$y=-999;$z=999;
				}
			}
		}

	delete `parentConstraint $drivingSystems[$a] tempSamplerOffset`;
	$pos=`xform -q -ws -t $constraintTo`;
	$maxDist=0;
	$maxY=0;
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$endJoint=$allDrivenDeformJoints[$i];
		$rlaChild=`asRlaChild $allDrivenDeformJoints[$i]`;
		if ($rlaChild!="")
			$endJoint=$rlaChild;
		$pos2=`xform -q -ws -t $endJoint`;
		float $mag=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		if ($mag>$maxDist)
			$maxDist=$mag;
		delete `pointConstraint $endJoint tempSampler`;
		float $yValue=`getAttr tempSampler.ty`;
		$yValue=`abs($yValue)`;
		if ($yValue>$maxY)
			$maxY=$yValue;
		if ($maxY<$maxDist/2.0) $maxY=$maxDist/2.0; // cap at half lenght
		}
	if ($maxDist<0.01) $maxDist=0.5;
	if ($maxY<0.01) $maxY=0.5;

	delete `pointConstraint $constraintTo $drivingSystems[$a]`;
	if (`objExists ($drivingSystems[$a]+"_aimConstraint1")`)
		delete ($drivingSystems[$a]+"_aimConstraint1");
	parentConstraint -mo $constraintTo $drivingSystems[$a];
	setAttr -type float3 ($drivingSystems[$a]+".s") ($maxDist*1.2) ($maxY*1.2) 1;
	asLockAttr $drivingSystems[$a] 1 1 1 1;
	}
if (`objExists tempSamplerOffset`)
	delete tempSamplerOffset;

select $sel;
}

global proc asCreateDrivingSystemController (string $objName, string $drivenObjs[])
{
int $isChildOfOtherDriven;
string $tempString[],$tempString2[];
string $constraintTo="Root_M";

$tempString=`circle -n $objName -c 0 0 0 -nr 0 0 1 -sw 180 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
$objName=$tempString[0];
scale -r -1 1 1 ($objName+".cv[0:10]");
sets -add AllSet $objName;
sets -add AllSet ($objName+"Shape");
sets -add ControlSet $objName;
setAttr ($objName+"Shape.overrideEnabled") 1;
setAttr ($objName+"Shape.overrideColor") 17;
if (!`objExists DrivingSystem`)
	{
	createNode -n DrivingSystem -p MotionSystem transform;
	connectAttr Main.drvSysVis DrivingSystem.v;
	sets -add AllSet DrivingSystem;
	}
parent $objName DrivingSystem;

string $deformJoint=$drivenObjs[0];
if (`gmatch $drivenObjs[0] "FK*"`)
$deformJoint=`substitute "FK" $drivenObjs[0] ""`;
if (`objExists $deformJoint`)
	$constraintTo=$deformJoint;
asAlign $objName $drivenObjs[0] 1 1 0 0;
string $rlaChild=`asRlaChild $deformJoint`;
if (`objExists $rlaChild`)
	{
	float $scale=`getAttr ($rlaChild+".tx")`;
	setAttr -type float3 ($objName+".s") $scale $scale $scale;
//	scale -r $scale $scale $scale ($objName+".cv[0:10]");
	}

string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
//if (`objExists ($objName+"_pointConstraint1")`)
//	delete ($objName+"_pointConstraint1");
if (`objExists $constraintTo`)
	parentConstraint -mo $constraintTo $objName;
eval($restorePoseCmd);
asLockAttr $objName 1 1 1 1;
}

global proc asCreateAngleAttrs (string $joint)
{
string $sel[]=`ls -sl`;
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
float $charHeight=`asgetCharHeight`;
int $sideFactor=1;
if (`gmatch $joint "*_L"`)
	$sideFactor=-1;
string $FKjoint=$joint;
if (`objExists ("FK"+$joint)`)
	$FKjoint="FK"+$joint;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $RGB[]={"R","G","B"};
string $posNegs[]={"Pos","Neg"};
for ($i=0;$i<size($XYZ);$i++)
	{
	addAttr -k 1 -ln ("angle"+$XYZ[$i]) -at double $joint;
	addAttr -k 0 -ln ("angle"+$XYZ[$i]) -at double $FKjoint;
	setAttr -e -channelBox true ("FK"+$joint+".angle"+$XYZ[$i]);
	connectAttr -f ($joint+".angle"+$XYZ[$i]) ($FKjoint+".angle"+$XYZ[$i]);
	}
if (!`objExists AngleSystem`)
	{
	createNode -n AngleSystem -p MotionSystem transform;
	setAttr AngleSystem.inheritsTransform 0;
	}

string $tempString[]=`listRelatives -p $joint`;
string $parent=$tempString[0];

createNode -n ($joint+"AngleSamplerBaseParent") -p AngleSystem transform;
createNode -n ($joint+"AngleSamplerBase") -p ($joint+"AngleSamplerBaseParent") transform;
pointConstraint $parent ($joint+"AngleSamplerBaseParent");
orientConstraint $parent ($joint+"AngleSamplerBaseParent");
delete `orientConstraint $joint ($joint+"AngleSamplerBase")`;
pointConstraint $joint ($joint+"AngleSamplerBase");

for ($i=1;$i<size($XYZ);$i++)
	for ($y=0;$y<size($posNegs);$y++)
		{
		string $loc=$joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y];
		spaceLocator -n $loc;
		parent $loc ($joint+"AngleSamplerBase");
		setAttr -type float3 ($loc+".t") 0 0 0;
		setAttr -type float3 ($loc+".r") 0 0 0;
		setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
		}
setAttr ($joint+"AngleSamplerYPos.tz") ($sideFactor*-1*0.7071104);
setAttr ($joint+"AngleSamplerYNeg.tz") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZPos.ty") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZNeg.ty") ($sideFactor*-1*0.7071104);

createNode -n ($joint+"AngleSamplerRotate") -p ($joint+"AngleSamplerBase") transform;
orientConstraint $joint ($joint+"AngleSamplerRotate");

string $loc=$joint+"AngleSamplerEnd";
spaceLocator -n $loc;
parent $loc ($joint+"AngleSamplerRotate");
setAttr -type float3 ($loc+".t") ($sideFactor*0.7071104) 0 0;
setAttr -type float3 ($loc+".r") 0 0 0;
setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);

for ($y=0;$y<size($posNegs);$y++)
	{
	createNode -n ($joint+"OneMinus"+$posNegs[$y]) plusMinusAverage;
	setAttr ($joint+"OneMinus"+$posNegs[$y]+".operation") 2;
	setAttr -type float3 ($joint+"OneMinus"+$posNegs[$y]+".input3D[0]") 1 1 1;
	}
//Y & Z
for ($i=1;$i<size($XYZ);$i++)
	{
	for ($y=0;$y<size($posNegs);$y++)
		{
		createNode -n ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]) distanceBetween;
		connectAttr -f ($joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y]+"Shape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point1");
		connectAttr -f ($joint+"AngleSamplerEndShape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point2");
		connectAttr -f ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".distance") ($joint+"OneMinus"+$posNegs[$y]+".input3D[1].input3D"+$xyz[$i]);
		}
	createNode -n ($joint+"AngleCondition"+$XYZ[$i]) condition;
	setAttr ($joint+"AngleCondition"+$XYZ[$i]+".operation") 2;
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".firstTerm");
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".secondTerm");
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".colorIfTrue"+$RGB[$i]);
	createNode -n ($joint+"AngleInverse"+$XYZ[$i]) unitConversion;
	setAttr ($joint+"AngleInverse"+$XYZ[$i]+".conversionFactor") -1;
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleInverse"+$XYZ[$i]+".input");
	connectAttr -f ($joint+"AngleInverse"+$XYZ[$i]+".output") ($joint+"AngleCondition"+$XYZ[$i]+".colorIfFalse"+$RGB[$i]);
	connectAttr -f ($joint+"AngleCondition"+$XYZ[$i]+".outColor.outColor"+$RGB[$i]) ($joint+".angle"+$XYZ[$i]);
	}
//X
createNode -n ($joint+"AngleXMultiplyDivide") multiplyDivide;
setAttr ($joint+"AngleXMultiplyDivide.operation") 2;
setAttr -type float3 ($joint+"AngleXMultiplyDivide.input2") 90 1 1;
if (`objExists ("TwistBalancer"+$joint)`) // tapping into existing twist system
	connectAttr -f ("TwistBalancer"+$joint+".rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
else // create twist deriver
	{
	select ($joint+"AngleSamplerBase");
	joint -n ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXUnTwistEnd");
	setAttr ($joint+"AngleXUnTwistEnd.tx") ($charHeight/12.0*$sideFactor);
	select ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXBalancer");
	orientConstraint -mo ($joint) ($joint+"AngleXBalancer");
	ikHandle -n ($joint+"AngleXUnTwistIK") -ns 2 -sol "ikRPsolver" -sj ($joint+"AngleXUnTwist") -ee ($joint+"AngleXUnTwistEnd");
	parent ($joint+"AngleXUnTwistIK") ($joint+"AngleSamplerBase");
	parentConstraint -mo $joint ($joint+"AngleXUnTwistIK");
	createNode -n ($joint+"AngleXUnTwistPoleVec") -p ($joint+"AngleSamplerBase") transform;
	poleVectorConstraint ($joint+"AngleXUnTwistPoleVec") ($joint+"AngleXUnTwistIK");
	connectAttr -f ($joint+"AngleXBalancer.rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
	}
connectAttr ($joint+"AngleXMultiplyDivide.output.outputX") ($joint+".angleX");

setAttr -l 1 ($joint+"AngleSamplerBaseParent.v") 0;
eval($restorePoseCmd);
select $sel;
}

global proc string asCreateBlendedAttribute (string $drivers[])
{
string $sel[]=`ls -sl`;
string $tempString[],$driverObjs[],$driverAttrs[];
string $attr;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];
	$attr+=$driverAttrs[$i];
	if (`getAttr $drivers[$i]`>=0)
		$attr+="Pos";
	else
		$attr+="Neg";
	if ($i<size($drivers)-1)
		$attr+="_";
	}

createNode -n BlendedCorrectiveDriver transform;
addAttr -ln driverObj -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverObj $driverObjs[0];
addAttr -ln driverAttr -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverAttr $attr;

if (`attributeExists $attr $driverObjs[0]`)
	{
	select $sel;
	return $attr;
	}

addAttr -k 0 -ln $attr -at double $driverObjs[0];
setAttr -e -channelBox true ($driverObjs[0]+"."+$attr);
if (!`gmatch $driverObjs[0] "FK*"` && `objExists ("FK"+$driverObjs[0])`)
	{
	addAttr -k 0 -ln $attr -at double ("FK"+$driverObjs[0]);
	setAttr -e -channelBox true ("FK"+$driverObjs[0]+"."+$attr);
	connectAttr ($driverObjs[0]+"."+$attr) ("FK"+$driverObjs[0]+"."+$attr);
	}

string $mpd,$sr;
string $previousOutput=$driverObjs[0]+"."+$driverAttrs[0];
for ($i=1;$i<size($drivers);$i++)
	{
	$sr=$driverObjs[0]+$attr+"SetRange"+$i;
	$mpd=$driverObjs[0]+$attr+"MultiplyDivide"+$i;
	createNode -n $sr setRange;
	connectAttr -f $previousOutput ($sr+".valueX");
	connectAttr -f ($driverObjs[$i]+"."+$driverAttrs[$i]) ($sr+".valueY");
	setAttr -type float3 ($sr+".max") 1 1 1;
	setAttr ($sr+".oldMaxX") `getAttr ($sr+".valueX")`;
	setAttr ($sr+".oldMaxY") `getAttr ($sr+".valueY")`;
	addAttr -k 1 -ln dvX -at double -dv `getAttr ($sr+".valueX")` $sr;
	addAttr -k 1 -ln dvY -at double -dv `getAttr ($sr+".valueY")` $sr;

	createNode -n $mpd multiplyDivide;
	connectAttr ($sr+".outValueX") ($mpd+".input1.input1X");
	connectAttr ($sr+".outValueY") ($mpd+".input2.input2X");
	if (`getAttr ($sr+".valueX")`<0)	//reverse negative numbers X
		{
		setAttr ($sr+".minX") 1;
		setAttr ($sr+".maxX") 0;
		setAttr ($sr+".oldMinX") (`getAttr ($sr+".oldMaxX")`);
		setAttr ($sr+".oldMaxX") 0;
		}
	if (`getAttr ($sr+".valueY")`<0)	//reverse negative numbers Y
		{
		setAttr ($sr+".minY") 1;
		setAttr ($sr+".maxY") 0;
		setAttr ($sr+".oldMinY") (`getAttr ($sr+".oldMaxY")`);
		setAttr ($sr+".oldMaxY") 0;
		}
	$previousOutput=($mpd+".outputX");
	}
connectAttr -f $previousOutput ($driverObjs[0]+"."+$attr);
select $sel;
return $attr;
}

global proc string[] asSetBlendedAttribute (string $driverObj, string $driverAttr, float $value, int $getDriversMode)
{
string $tempString[],$drivers[];
int $connectedToMultDiv=1;
string $plug=$driverObj+"."+$driverAttr;
float $dvs[];
while ($connectedToMultDiv)
	{
	$connectedToMultDiv=0;
	$tempString=`listConnections -s 1 -d 0 -scn 1 $plug`;
	string $nodeA=$tempString[0];
	if(size($tempString)>0)
		{
		if (`objectType $nodeA`=="multiplyDivide")
		{
		$connectedToMultDiv=1;
		$plug=$nodeA+".input1.input1X";
		}
		else if (`objectType $nodeA`=="setRange")
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueY")`;
			$drivers[size($drivers)]=$tempString[0];
			$dvs[size($dvs)]=`getAttr ($nodeA+".dvY")`;
			
			$tempString=`listConnections -s 1 -d 0 -p 0 -scn 1 ($nodeA+".valueX")`;
			string $nodeB=$tempString[0];
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueX")`;
			if (`objectType $nodeB`=="multiplyDivide")
				{
				$connectedToMultDiv=1;
				$plug=$nodeA+".valueX";
				}
			else
				{
				$drivers[size($drivers)]=$tempString[0];
				$dvs[size($dvs)]=`getAttr ($nodeA+".dvX")`;
				}
			}
		}
	
	}

//For inbetweens, just find the values were all inputs are equal, and sum up to total
if ($value<1)
	for ($i=0;$i<size($dvs);$i++)
		{
		float $temp=`pow $dvs[$i] 2`;
		$dvs[$i]=`sqrt($temp*$value)`;
		}

for ($i=0;$i<size($drivers);$i++)
	if (!$getDriversMode)
		{
		string $setDriver=$drivers[$i];
		if (`gmatch $setDriver "*[.]angle*"`)// blended angles
			{
			tokenize $setDriver "[.]" $tempString;
			string $driverObj=$tempString[0];
			string $driverAttr=$tempString[1];
			asSetRotationFromAngle $driverObj $driverAttr $dvs[$i];
			}
		else
			{
			string $FKDriver="FK"+$drivers[$i];
			if (`objExists $FKDriver`)
				$setDriver=$FKDriver;
			setAttr $setDriver $dvs[$i];
			}
		}
$drivers=`sort $drivers`;
return $drivers;
}

global proc string asCreateCorrectiveShape ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl -o`;
string $tempString[],$tempString2[];
if(size($sel)==0)
	error "No mesh selected, select geometry on your character";
if (size($sel)>1)
	error "More than 1 object selected, Only 1 object must be selected";
if (`gmatch $sel[0] "*__*"`)
	error "Selected object IS a Corrective Shape. Select geometry on your character";
if ($sel[0]!="")
	if (`objectType $sel[0]`=="mesh")
		$sel=`listRelatives -p $sel[0]`;
$tempString=`listRelatives -ni -s $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not geometry";
if (`objectType $tempString[0]`!="mesh")
	error "Selected object is not a mesh";

string $controlSetMembers[]=`sets -q ControlSet`;
//As below v3.9.7 had bug where EyeOrientOffset_L was in FaceControlSet
if (`objExists FaceControlSet`)
	if (`objExists EyeOrientOffset_L`)
		if (`sets -im FaceControlSet EyeOrientOffset_L`)
			sets -rm FaceControlSet EyeOrientOffset_L;

//string $tr[]={"t","r"};
//string $xyz[]={"x","y","z"};
string $drivers[],$keyableAttr[];
string $objAttr;
float $poseValue,$currentValue;
//Find driving attribute(s)
string $buildPoseCmds[],$runCmds[];
//get $buildPoseCmds
$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}
string $runObjAttrs[],$checkObjAttr[];
float $runValues[];
for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<2;$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKExtra*"`)//must filter FKExtraJaw_M & FKExtraEye_*, so just filter all Extra
				continue;
			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;
			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				$drivers[size($drivers)]=$checkObjAttr[$z];
			}
		}
	}
if (size($drivers)==0)
	error ("Found no driving attribute, all values are in Build-Pose");

for ($i=0;$i<size($drivers);$i++)
	{
	string $nonFKDriver=`substitute "FK" $drivers[$i] ""`;
	if (`objExists $nonFKDriver`)
//		if (!`gmatch $drivers[0] "FK*[.]translate*"`) //(FK*.t* dont have zero default values)
			$drivers[$i]=$nonFKDriver;
	}

tokenize $drivers[0] "[.]" $tempString;
string $deformObj=$sel[0];
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $directDriverAttr=$driverAttr;
float $dv=`getAttr $drivers[0]`;
float $idv=0;

//angle driver
if (`checkBox -q -v asCorrectiveAngleCheckBox`)
	if (`gmatch $driverAttr "r*"`)//rotation && !blended
		{
		if (!`attributeExists "angleX" $driverObj`)
			asCreateAngleAttrs $driverObj;

		//Max 90 degrees
		float $FKdv=`getAttr ("FK"+$drivers[0])`;
		if (abs($FKdv)>90)
			{
			warning ("Angle rotation more than 90 degrees, now reducing rotation to 90.");
			if ($dv>0) $dv=90;
			if ($dv<0) $dv=-90;
			setAttr ("FK"+$drivers[0]) $dv;
			}
		for ($i=0;$i<size($drivers);$i++)
			{
			if (`gmatch $drivers[$i] "*[.]rotate*"`)
				{
				$drivers[$i]=`substitute "rotate" $drivers[$i] "angle"`;
				$driverAttr=`substitute "rotate" $driverAttr "angle"`;
				}
			$idv=$dv;
			$dv=`getAttr ($driverObj+"."+$driverAttr)`;
			if (`gmatch $driverAttr "*X"` && `objExists ("TwistBalancer"+$driverObj)`)
				{
				//$idv special case if RX from a twist-system
				$idv=`getAttr ("TwistBalancer"+$driverObj+"."+$directDriverAttr)`;
				}
			}
		//2 rotation attributes could be translated to 3 angle attributes
		string $XYZ[]={"X","Y","Z"};
		if (size($drivers)>1)
			for ($i=0;$i<size($drivers);$i++)
				{
				for ($y=0;$y<size($XYZ);$y++)
					{
					string $check=$driverObj+".angle"+$XYZ[$y];
					float $checkVal=`getAttr $check`;
					if (abs($checkVal)>0.001)
						if (!`stringArrayCount $check $drivers`)
							{
							$drivers[size($drivers)]=$check;
							$drivers=`sort $drivers`;
							}
					}
				}
		}

if (size($drivers)>1)
	{
	//We might have arrived back here from already created blendAttr
	if (`objExists BlendedCorrectiveDriver`)
		{
		$driverObj=`getAttr BlendedCorrectiveDriver.driverObj`;
		$driverAttr=`getAttr BlendedCorrectiveDriver.driverAttr`;
		$dv=`getAttr ($driverObj+"."+$driverAttr)`;
		}
	else
		{
		string $m="Create Corrective Shape from blend of these drivers?\n\n";
		for ($i=0;$i<size($drivers);$i++)
			{
			float $value=`getAttr $drivers[$i]`;
			$value=`asRoundOff $value 3`;
			$m+=$drivers[$i]+" = "+$value+"\n";
			}
		if (!$asSkipConfirm)
			if (`confirmDialog -t "Multiple Drivers Found"
				-m $m
				-b "OK" -b "Cancel" -db "Cancel"
				-ds "Cancel"`!="OK")
					return "";
		asCreateBlendedAttribute $drivers;
		asCreateCorrectiveShape;
		return "";
		}
	}

string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
$dv=`asRoundOff $dv 3`;

float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr+"__"+$posNeg;

if (size($drivers)==1 && !$asSkipConfirm)
	{
	string $dialog=`confirmDialog -t "Single Driver Found"
		-m ("Create Corrective Shape from this driver?\n\n"+$driverObj+"."+$driverAttr+" = "+$dv)
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`;
	if ($dialog!="OK")
		return "";
	}

asCorrectiveDuplicate $attrCode $sel[0];

addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

return $attrCode;
}

global proc float asCorrectiveGetIV (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $iv=1;
string $bs=$deformObj+"Corrective";
if (!`objExists $bs`)
	return 1;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
float $maxKeyVal;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount ($driverObj+"__"+$driverAttr+"__"+$posNeg) $weights`)
	{
	$tempString=`listConnections ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
	float $keyXValues[]=`keyframe -q -fc $tempString[0]`;
	float $keyYValues[]=`keyframe -q -vc $tempString[0]`;
	float $xvalueAtOneY=$keyXValues[size($keyXValues)-1];
	for ($i=0;$i<size($keyYValues);$i++)
		if ($keyYValues[$i]==1)
			$xvalueAtOneY=$keyXValues[$i];

	$iv=$dv/$xvalueAtOneY;
	$iv=`asRoundOff $iv 3`;
	}
return $iv;
}

global proc asCorrectiveDuplicate (string $attrCode, string $source)
{
float $charHeight=`asgetCharHeight`;
duplicate -n $attrCode $source;
asLockAttr $attrCode 0 0 0 0;
string $tempString[]=`listRelatives -p $attrCode`;
if ($tempString[0]!="")
	parent -w $attrCode;
$tempString=`listRelatives -f -s $attrCode`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="mesh")
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
$tempString=`listRelatives -f -s $attrCode`;
rename $tempString[0] ($attrCode+"Shape");

rowLayout -e -en 1 asCorrectiveEditChoicesRowLayout;
button -e -en 0 asCreateCorrectiveButton;
button -e -en 0 asEditCorrectiveButton;
button -e -en 0 asDeleteCorrectiveButton;
button -e -en 0 asGraphCorrectiveButton;
setAttr "Group.v" 0;

$tempString=`ls -sl -l $source`;
if (!`gmatch $tempString[0] "|Group|*"`)
	{
	setAttr ($source+".v") 0;
	if (!`attributeExists "correctiveShapeModeHidden" "Group"`)
		addAttr -ln "correctiveShapeModeHidden" -dt "string" "Group";
	setAttr -type "string" "Group.correctiveShapeModeHidden" $source;
	}

//setAttr ($attrCode+".tx") ($charHeight*0.5);
select $attrCode;
SculptGeometryTool;

headsUpDisplay -s 2 -b 0 -bs "medium" -l "Corrective Shape Mode" -lfs "large" HUDCSMMode;
scriptJob -runOnce true -e deleteAll "asExitCorrectiveShapeMode";
scriptJob -runOnce true -nodeDeleted $attrCode "asExitCorrectiveShapeMode";
}

global proc asConnectCorrectiveShape ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $tempString[];
if (size($sel)<1)
	error "Select the Corrective Shape";
if (`gmatch $sel[0] "*[.]*"`)
	$sel=`ls -sl -o`;
if (`objectType $sel[0]`!="transform")
	{
	$tempString=`listRelatives -p $sel[0]`;
	$sel[0]=$tempString[0];
	}
if (size($sel)!=1)
	error "Select only the Corrective Shape";
string $restoreCmds[];
tokenize `substituteAllString $sel[0] "__"  "|"` "|" $tempString;
string $deformObj=$tempString[0];
string $driverObj=$tempString[1];
string $driverAttr=$tempString[2];
float $dv=`getAttr ($sel[0]+".driverValue")`;
float $idv=`getAttr ($sel[0]+".indirectDriverValue")`;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
float $iv=`getAttr ($sel[0]+".inbetweenValue")`;
int $deleteMode=`objExists DeleteCorrectiveShape`;
string $deltaShape=$driverObj+"__"+$driverAttr+"__"+$posNeg;
string $sdk=$deformObj+"Corrective_"+$deltaShape;
float $keyXValues[];
if (`objExists $sdk`)
	$keyXValues=`keyframe -q -fc $sdk`;
if ($sel[0]==$deformObj)
	error "Can not use itself as Corrective Shape, Select the Corrective Shape";
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

int $isJoystick=0;
$tempString=`ls -l $driverObj`;
if (`gmatch $tempString[0] "*|ctrlBox|*"`)
	$isJoystick=1;
float $mirrorDv=$dv;
string $mirrorPosNeg=$posNeg;
if (($driverAttr=="translateX" && !$isJoystick) || (`gmatch $driverObj "FK*"` && `gmatch $driverAttr "translate*"`))
	{
	$mirrorDv=$dv*-1;
	if ($posNeg=="pos") $mirrorPosNeg="neg";
	if ($posNeg=="neg") $mirrorPosNeg="pos";
	}
int $doMirror=0;
string $mirrorDriverObj,$FKMirrorDriverObj,$mirrorDeltaShape,$mirrorSdk;
string $side="_R";
string $mirrorDriverAttr=$driverAttr;
string $mirrorSide="_L";
if (`gmatch $driverObj "*_L"`)
	{
	$side="_L";
	$mirrorSide="_R";
	}
if (`checkBox -q -v asCorrectiveMirrorCheckBox`)
	{
	$mirrorDriverObj=`substitute $side $driverObj $mirrorSide`;
	$FKMirrorDriverObj=`substitute $side $FKDriverObj $mirrorSide`;
	$mirrorDeltaShape=`substitute $side $deltaShape $mirrorSide`;
	if ($mirrorPosNeg!=$posNeg)
		$mirrorDeltaShape=`substitute $posNeg $mirrorDeltaShape $mirrorPosNeg`;
	$mirrorSdk=`substitute $side $sdk $mirrorSide`;

	if (`objExists $mirrorDriverObj` && $driverObj!=$mirrorDriverObj)
		{
		$doMirror=1;
		//angle attrs
		if (`gmatch $driverAttr "angle*"`)
			if (!`attributeExists "angleX" $mirrorDriverObj`)
				asCreateAngleAttrs $mirrorDriverObj;
		//blended attrs
		if (`gmatch $driverAttr "*_*"`)
			{
			string $drivers[]=`asSetBlendedAttribute $driverObj $driverAttr 0 1`;
			string $mirroredDrivers[];
			float $driverValues[],$mirroredDriverValues[],$rotates[];
			for ($i=0;$i<size($drivers);$i++)
				{
				$driverValues[$i]=`getAttr $drivers[$i]`;
				$mirroredDriverValues[$i]=$driverValues[$i];
				$mirroredDrivers[$i]=`substitute $side $drivers[$i] $mirrorSide`;
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						$rotates=`getAttr ($FKDriverObj+".r")`;
						setAttr -type float3 ($FKDriverObj+".r") 0 0 0;
						}
					}
				else
					setAttr $drivers[$i] 0;
				if ((`gmatch $mirroredDrivers[$i] "*[.]translateX"` && !$isJoystick) || (`objExists ("FK"+$driverObj)` && `gmatch $mirroredDrivers[$i] "*[.]translate*"`))
					$mirroredDriverValues[$i]=$driverValues[$i]*-1;
				//temporary mirror blended pose
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						setAttr -type float3 ($FKMirrorDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
					}
				else
					setAttr $mirroredDrivers[$i] $mirroredDriverValues[$i];
				}
			//asCreateBlendedAttribute
			$mirrorDriverAttr=`asCreateBlendedAttribute $mirroredDrivers`;
			$mirrorDeltaShape=$mirrorDriverObj+"__"+$mirrorDriverAttr+"__pos";
			//restore blended pose
			for ($i=0;$i<size($drivers);$i++)
				{
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						setAttr -type float3 ($FKMirrorDriverObj+".r") 0 0 0;
						setAttr -type float3 ($FKDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
						}
					}
				else
					{
					setAttr $mirroredDrivers[$i] 0;
					setAttr $drivers[$i] $driverValues[$i];					
					}
				}
			}
		}
	}

string $history[]=`listHistory $deformObj`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			{
			setAttr ($history[$i]+".envelope") 0;
			$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
			}
duplicate -n $deltaShape $deformObj;
asLockAttr $deltaShape 0 0 0 0;
$tempString=`listRelatives -p $deltaShape`;
if ($tempString[0]!="")
	parent -w $deltaShape;

addAttr -k 1 -ln driverValue -at double -dv $dv $deltaShape;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $deltaShape;
if($doMirror && !$deleteMode)
	{
	duplicate -n $mirrorDeltaShape $deformObj;
	asLockAttr $mirrorDeltaShape 0 0 0 0;
	$tempString=`listRelatives -p $mirrorDeltaShape`;
	if ($tempString[0]!="")
		parent -w $mirrorDeltaShape;
	addAttr -k 1 -ln driverValue -at double -dv $mirrorDv $mirrorDeltaShape;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $mirrorDeltaShape;
	}

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

//Inverse shapes from other deformers
//if (`gmatch $driverAttr "*_*"` && `objExists ($deformObj+"Corrective")`)
duplicate -n ($deltaShape+"_componentReverse") $deformObj;
$tempString=`listRelatives -p ($deltaShape+"_componentReverse")`;
if ($tempString[0]!="")
	parent -w ($deltaShape+"_componentReverse");
select $sel[0] $deformObj ($deltaShape+"_componentReverse");
blendShape -n ($deltaShape+"_componentReverseBS") -frontOfChain -w 0 1 -w 1 1;

$history=`listHistory $deformObj`;
string $weights[];
if (`objExists ($deformObj+"Corrective.w")`)
	$weights=`listAttr -m ($deformObj+"Corrective.w")`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			if ($history[$i]==($deformObj+"Corrective"))
				if (`gmatch $driverAttr "*_*"`)
					for ($y=0;$y<size($weights);$y++)
						{
						if ($weights[$y]!=$deltaShape)
							setAttr ($deformObj+"Corrective."+$weights[$y]) 0;
						}
select ($deltaShape+"_componentReverse");
DeleteHistory;
select ($deltaShape+"_componentReverse") $sel[0];
blendShape -n ($deltaShape+"_componentReverseBS2") -frontOfChain -w 0 1;
select $sel[0];
DeleteHistory;
for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);
delete ($deltaShape+"_componentReverse");

//Restore bsTargets that were rest to Zero, by dgdirty. SDK`s will ensure restore.
dgdirty -a;
//eval ($resetTargetsRestoreCmd);

select $deltaShape $deformObj;
asCorrectiveConnectBS;

$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
	setAttr ($deformObj+"Corrective."+$deltaShape) 1;

int $incOnce,$numVtxMoved;
int $numVtxs[]=`polyEvaluate -v $deltaShape`;
float $mag,$prevMag,$move;
float $tol=0.001;
float $selPos[]=`xform -q -ws -t $sel[0]`;
float $deformPos[]=`xform -q -ws -t $deformObj`;
xform -ws -t $deformPos[0] $deformPos[1] $deformPos[2] $sel[0];
float $posA[3],$posA2[3],$posB[3],$temp[3];
string $xyz[]={"x","y","z"};

//get current FKIK blend values
string $controlSetMembers[]=`sets -q ControlSet`;
string $restoreFKIKCmds[];
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`gmatch $controlSetMembers[$i] "FKIK*_*"`)
		if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
			$restoreFKIKCmds[size($restoreFKIKCmds)]="setAttr "+$controlSetMembers[$i]+".FKIKBlend "+`getAttr ($controlSetMembers[$i]+".FKIKBlend")`+";";

int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;

if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

float $zv=`getAttr ($driverObj+"."+$driverAttr)`;
$zv=`asRoundOff $zv 3`;
float $mirrorZv;
if($doMirror)
	{
	$mirrorZv=`getAttr ($mirrorDriverObj+"."+$mirrorDriverAttr)`;
	$mirrorZv=`asRoundOff $mirrorZv 3`;
	}

//restore all FKIK blend values as berfore GoToBuildPose, since we might have changed to FK to do corrective
for ($i=0;$i<size($restoreFKIKCmds);$i++)
	eval ($restoreFKIKCmds[$i]);

eval($restorePoseCmd);
dgdirty -a;

$tempString=`listRelatives -f -s $deformObj`;
string $preDeformMesh;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		$preDeformMesh=$tempString[$i];

//matrix loop utilities
float $xPoint[],$yPoint[],$zPoint[],$newPos[];
createNode -n correctiveMatrixUtilities transform;
createNode -n matrix2xform parentConstraint;
createNode -n matrix2scale scaleConstraint;
createNode -n invMReaderOffset transform;
addAttr -ln theMatrix -dt "matrix" invMReaderOffset;
createNode -n invMReader -p invMReaderOffset transform;
createNode -n invMNewPos -p invMReader transform;
createNode -n defOffset transform;
createNode -n corPos -p defOffset transform;
connectAttr -f corPos.translate invMNewPos.translate;
connectAttr -f corPos.rotate invMNewPos.rotate;
connectAttr -f corPos.scale invMNewPos.scale;
//invMReaderOffset.theMatrix to matrixInverter.xform
createNode -n matrixInverter transform;
createNode -n matrix2xform2 parentConstraint;
createNode -n matrix2scale2 scaleConstraint;
connectAttr invMReaderOffset.theMatrix  matrix2xform2.target[0].targetParentMatrix;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateX matrixInverter.translate.translateX;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateY matrixInverter.translate.translateY;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateZ matrixInverter.translate.translateZ;
connectAttr matrix2xform2.constraintRotate.constraintRotateX matrixInverter.rotate.rotateX;
connectAttr matrix2xform2.constraintRotate.constraintRotateY matrixInverter.rotate.rotateY;
connectAttr matrix2xform2.constraintRotate.constraintRotateZ matrixInverter.rotate.rotateZ;
connectAttr invMReaderOffset.theMatrix matrix2scale2.target[0].targetParentMatrix;
connectAttr matrix2scale2.constraintScale matrixInverter.scale;
//matrixInverter.inverseMatrix to invMReader.xform
connectAttr matrixInverter.inverseMatrix matrix2xform.target[0].targetParentMatrix;
connectAttr matrix2xform.constraintTranslate.constraintTranslateX invMReader.translate.translateX;
connectAttr matrix2xform.constraintTranslate.constraintTranslateY invMReader.translate.translateY;
connectAttr matrix2xform.constraintTranslate.constraintTranslateZ invMReader.translate.translateZ;
connectAttr matrix2xform.constraintRotate.constraintRotateX invMReader.rotate.rotateX;
connectAttr matrix2xform.constraintRotate.constraintRotateY invMReader.rotate.rotateY;
connectAttr matrix2xform.constraintRotate.constraintRotateZ invMReader.rotate.rotateZ;
connectAttr matrixInverter.inverseMatrix matrix2scale.target[0].targetParentMatrix;
connectAttr matrix2scale.constraintScale invMReader.scale;
parent matrix2xform matrix2scale invMReaderOffset defOffset matrixInverter matrix2xform2 matrix2scale2 correctiveMatrixUtilities;
//setAttr ($deformObj+"Corrective.envelope") 0;

//Existing blendShape nodes causes a inverse (&multiplied) deformation, so envelope off these.
$history=`listHistory $deformObj`;
clear $restoreCmds;
string $bsNodes[];
string $skinCluster;
for ($i=0;$i<size($history);$i++)
	{
	if (`objectType $history[$i]`=="skinCluster" && $skinCluster=="")
		$skinCluster=$history[$i];
	if (`objectType $history[$i]`=="blendShape" && $history[$i]!="asFaceBS")
		{
		setAttr ($history[$i]+".envelope") 0;
		$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
		}
	}

//Make sure the corrective is the first BS before the skinCluster
catchQuiet (`reorderDeformers $skinCluster ($deformObj+"Corrective") $deformObj`);
//And before "asFaceBS"
if (`objExists "asFaceBS"`)
	catchQuiet (`reorderDeformers "asFaceBS" ($deformObj+"Corrective") $deformObj`);

//xyz Offsets`s
move -r 1 0 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n xOffsetts $deformObj;
move -r -1 1 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n yOffsetts $deformObj;
move -r 0 -1 1 ($preDeformMesh+".vtx[0:999999]");
duplicate -n zOffsetts $deformObj;
move -r 0 0 -1 ($preDeformMesh+".vtx[0:999999]");
asLockAttr xOffsetts 0 0 0 0;
asLockAttr yOffsetts 0 0 0 0;
asLockAttr zOffsetts 0 0 0 0;
parent xOffsetts yOffsetts zOffsetts correctiveMatrixUtilities;

progressBar -e -st ("Computing Delta Shape") -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
		blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
		delete $deltaShape;
		if (`objExists $mirrorDeltaShape`)
			delete $mirrorDeltaShape;
		delete correctiveMatrixUtilities;
		select $sel[0];
		print ("// Corrective Shape Cancelled	\n");
		return;
		}
	if ($deleteMode)
		break;
	progressBar -e -s 1 $gMainProgressBar;

	$posA=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;

	if (abs($posA[0]-$posB[0])<$tol && abs($posA[1]-$posB[1])<$tol && abs($posA[2]-$posB[2])<$tol)
		continue;

	$numVtxMoved++;

	//inverseMatrix
	float $nonDefPos[]=`xform -q -ws -t ($preDeformMesh+".vtx["+$i+"]")`;
	float $defPos[]=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	float $corPos[]=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
	xform -ws -t $nonDefPos[0] $nonDefPos[1] $nonDefPos[2] invMReaderOffset;

	xform -ws -t $defPos[0] $defPos[1] $defPos[2] defOffset;
	xform -ws -t $corPos[0] $corPos[1] $corPos[2] corPos;

	$xPoint=`xform -q -ws -t ("xOffsetts.vtx["+$i+"]")`;
	$yPoint=`xform -q -ws -t ("yOffsetts.vtx["+$i+"]")`;
	$zPoint=`xform -q -ws -t ("zOffsetts.vtx["+$i+"]")`;

	setAttr -type "matrix" invMReaderOffset.theMatrix 
	($xPoint[0]-$defPos[0]) ($xPoint[1]-$defPos[1]) ($xPoint[2]-$defPos[2]) 0
	($yPoint[0]-$defPos[0]) ($yPoint[1]-$defPos[1]) ($yPoint[2]-$defPos[2]) 0
	($zPoint[0]-$defPos[0]) ($zPoint[1]-$defPos[1]) ($zPoint[2]-$defPos[2]) 0
	0 0 0 1;

	$newPos=`xform -q -ws -t invMNewPos`;
	xform -ws -t $newPos[0] $newPos[1] $newPos[2] ($deltaShape+".vtx["+$i+"]");
	}
progressBar -e -ep $gMainProgressBar;
//setAttr ($deformObj+"Corrective.envelope") 1;
delete correctiveMatrixUtilities;
xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
print ("//Calculated "+$numVtxMoved+" vtx for deltashape\n");

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
eval($restorePoseCmd);
dgdirty -a;

if($doMirror && !$deleteMode)
	{
	createNode -n ($deltaShape+"MirrorGroup") transform;
	parent $deltaShape ($deltaShape+"MirrorGroup");
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	duplicate -n ($mirrorDeltaShape+"Default") $mirrorDeltaShape;
	select ($mirrorDeltaShape+"Default") $deltaShape;
	blendShape -n tempMirrorCorrectiveBS -frontOfChain;
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 1;
	select $mirrorDeltaShape $deltaShape;
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "0", "0" };
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 0;
	select $mirrorDeltaShape;
	DeleteHistory;
	delete ($mirrorDeltaShape+"Default");
	select $mirrorDeltaShape $deformObj;
	asCorrectiveConnectBS;
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	}
if ($deleteMode)
	{
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	print ("deleting "+$deltaShape+", (inbetweenValue="+$iv+", value="+$dv+")\n");
	blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
	selectKey -add -k -f $dv $sdk;
	cutKey -animation keys -clear;
	}
delete $deltaShape;
delete $sel[0];
if($doMirror && !$deleteMode)
	delete $mirrorDeltaShape ($deltaShape+"MirrorGroup");
if ($deleteMode)
	delete DeleteCorrectiveShape;
$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if ($iv<1)
	;//print ("Inbetweener..skipping SDK..\n");
if ($iv==1) //SDK for inbetweens not done here
	if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
		{
		if (`objExists $sdk`) if (size($keyXValues)<2) delete $sdk;
		setDrivenKeyframe 														-v 0 -dv $zv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv $dv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		if($doMirror && !$deleteMode)
			{
			if (`objExists $mirrorSdk`) {float $mirrorKeyValues[]=`keyframe -q -fc $mirrorSdk`;if (size($mirrorKeyValues)<2) delete $mirrorSdk;}
			setDrivenKeyframe 														-v 0 -dv $mirrorZv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv $mirrorDv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			}
		}

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
autoKeyframe -state $autoKeyframe;
select $deformObj;
setToolTo $gSelect;
}

global proc asCancelCorrectiveShape ()
{
global string $gSelect;
string $tempString[];
string $rootLevelObjects[]=`ls -as -type transform`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		{
		delete $rootLevelObjects[$i];
		tokenize $rootLevelObjects[$i] "_" $tempString;
		if (`objExists $tempString[0]`)
			select $tempString[0];
		}
if (`objExists "Group"`)
	setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
setToolTo $gSelect;
}

global proc asExitCorrectiveShapeMode ()
{
//setAttr "Group.v" 1; crashes maya :(
rowLayout -e -en 0 asCorrectiveEditChoicesRowLayout;
button -e -en 1 asCreateCorrectiveButton;
button -e -en 1 asEditCorrectiveButton;
button -e -en 1 asDeleteCorrectiveButton;
button -e -en 1 asGraphCorrectiveButton;

if (`attributeExists "correctiveShapeModeHidden" "Group"`)
	setAttr (`getAttr "Group.correctiveShapeModeHidden"`+".v") 1;
if (`headsUpDisplay -q -ex HUDCSMMode`)
	headsUpDisplay -rem HUDCSMMode;
}

global proc asCorrectiveConnectBS ()
{
int $numLetters;
string $sel[]=`ls -sl`;
string $deltaShape=$sel[0];
string $deformObj=$sel[1];
string $tempString[];
tokenize `substituteAllString $deltaShape "__"  "|"` "|" $tempString;
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $posNeg="pos";
if (`getAttr ($deltaShape+".driverValue")`<0)
	$posNeg="neg";
float $iv=`getAttr ($deltaShape+".inbetweenValue")`;
int $existingTargetNr=-1;
if (`objExists ($deformObj+"Corrective")`) //BSnode Exists (Adding Target to BS node)
	{
	int $inputTargetGroups[]=`getAttr -mi ($deformObj+"Corrective.inputTarget[0].inputTargetGroup")`;
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	for ($i=0;$i<size($existingTargets);$i++)
		{
		if ($existingTargets[$i]==$deltaShape)
			$existingTargetNr=$i;
		}
	if ($existingTargetNr!=-1 && $iv==1) // BSnode and BStarget Exists (Replacing target)
		{
		print ("// Replacing BlendShape Target\n");
		connectAttr -f ($deltaShape+".worldMesh[0]") ($deformObj+"Corrective.inputTarget[0].inputTargetGroup["+$inputTargetGroups[$existingTargetNr]+"].inputTargetItem[6000].inputGeomTarget");
		}
	else if ($iv<1 || $iv>1) // BSnode and `similar` target Exists (This must be a inbetween target)
		{
		print ("// connecting inbeween shape at: "+$iv+" for targetNr: "+$existingTargetNr+"\n");
		blendShape -e -inBetween -t $deformObj $inputTargetGroups[$existingTargetNr] $deltaShape $iv ($deformObj+"Corrective");
		//add a key, so this inbeween can be extracted
		setDrivenKeyframe -v $iv -dv `getAttr ($deltaShape+".driverValue")` -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg);
		}
	else
		{
		print ("// Creating New BlendShape\n");
		blendShape -e -t $deformObj `size($existingTargets)` $deltaShape 1 ($deformObj+"Corrective");
		}
	}
else
	{
	blendShape -n ($deformObj+"Corrective") -frontOfChain;
//	$tempString=`listConnections ($deformObj+"Corrective.outputGeometry[0]")`;
//	rename $tempString[0] ($deformObj+"PB");
	}
}

global proc asPopulateCorrectivePopupMenu (string $action)
{
string $popupMenu="as"+$action+"CorrectiveShapesPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
string $correctiveBS[]=`ls -r 1 -type blendShape "*Corrective"`;
int $menuExisted,$en;
float $keyXValues[],$keyYValues[];
string $label;
string $weights[],$tempString[],$menu2s[],$menu3s[],$menu4s[];
for ($i=0;$i<size($correctiveBS);$i++)
	{
	string $deformObj=`substitute "Corrective" $correctiveBS[$i] ""`;
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph")
		$sm=0;
	$lev1Menu=`menuItem -sm $sm -l $deformObj`;
	if ($action=="Graph")
		{
		menuItem -e -c ("select "+$correctiveBS[$i]+";GraphEditor;") $lev1Menu;
		continue;
		}
	$weights=`listAttr -m ($correctiveBS[$i]+".w")`;
	$weights=`sort $weights`;
	for ($y=0;$y<size($weights);$y++)
		{
		tokenize `substituteAllString $weights[$y] "__"  "|"` "|" $tempString;
		string $driverObj=$tempString[0];
		string $driverAttr=$tempString[1];
		string $posNeg=$tempString[2];
		setParent -menu $lev1Menu;

		//$menu2s
		$menu="asCorrectiveMenu_"+$action+$driverObj;
		if(`stringArrayCount $menu $menu2s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $driverObj $menu;
			$menu2s[size($menu2s)]=$menu;
			}

		//$menu3s
		$menu="asCorrectiveMenu_"+$action+$driverObj+"_"+$driverAttr;
		if(`stringArrayCount $menu $menu3s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $driverAttr $menu;
			$menu3s[size($menu3s)]=$menu;
			}

		//$menu4s
		$menu="asCorrectiveMenu_"+$action+$driverObj+"_"+$driverAttr+"_"+$posNeg;
		if(`stringArrayCount $menu $menu4s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $posNeg $menu;
			$menu4s[size($menu4s)]=$menu;
			}
		$sdk=`listConnections ($correctiveBS[$i]+"."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
		$keyXValues=`keyframe -q -fc $sdk`;
		$keyYValues=`keyframe -q -vc $sdk`;
		$haveKeyAtOne=0;
		for ($z=0;$z<size($keyYValues);$z++)
			if ($keyYValues[$z]==1)
				$haveKeyAtOne=1;
		if (!$haveKeyAtOne)
			warning "Found No keys at with \"Y\" value of 1, Unable to determine which shape is not a inbetween";
		float $smallestKeyXValue=99;
		for ($z=0;$z<size($keyXValues);$z++)
			if (abs($keyXValues[$z])<$smallestKeyXValue)
				$smallestKeyXValue=abs($keyXValues[$z]);
		for ($z=0;$z<size($keyXValues);$z++)
			{
			if (($keyXValues[$z]>=0 && $keyXValues[$z]==$smallestKeyXValue) || ($keyXValues[$z]<0 && $keyXValues[$z]==-1*$smallestKeyXValue))
				continue;
			setParent -menu $menu;
			float $roundFactor;
			if ($keyXValues[$z]>0) $roundFactor=0.5;
			else $roundFactor=-0.5;
			$keyXValues[$z]=(trunc($keyXValues[$z]*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
			$cmd="";
			if ($action=="Delete")
				$cmd="createNode -n DeleteCorrectiveShape transform;";
			if ($action=="Edit" || $action=="Delete")
				$cmd+="asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" \""+$keyXValues[$z]+"\" ";
			if ($action=="Delete")
				$cmd+=";asConnectCorrectiveShape;";
			$en=1;
			$label=$keyXValues[$z];
			if ($action=="Delete")
				if ($keyYValues[$z]==1 && size($keyXValues)>2)
//				if (($keyXValues[$z]>0 && size($keyXValues)>2 && $z==size($keyXValues)-1)
//				 || ($keyXValues[$z]<0 && size($keyXValues)>2 && $z==0))
					$en=0;
//			if (($keyXValues[$z]>0 && $z<size($keyXValues)-1) || ($keyXValues[$z]<0 && $z>0))
			if ($keyYValues[$z]!=1)
				$label+=" (inbtw)";
			menuItem -en $en -l $label -c $cmd;
			}
		}
	}
}

global proc float asSetRotationFromAngle (string $driverObj, string $driverAttr, float $dv)
{
string $XYZ=`substitute "angle" $driverAttr ""`;
float $a=1-`abs($dv)`;
float $c=0.707;
float $b=0.707;
float $rads = ((`pow $b 2`) + (`pow $c 2`) - (`pow $a 2`)) /( 2*$b*$c);
float $deg=90-`acosd($rads)`;
if ($dv<0)
	$deg*=-1;
setAttr ("FK"+$driverObj+".rotate"+$XYZ) $deg;
return $deg;
}

global proc asEditCorrectiveShape (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $idv;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
//string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;
if (!`getAttr -settable ($driverObj+"."+$driverAttr)`)//blended (including blended angles
	{
	asSetBlendedAttribute $driverObj $driverAttr $dv 0;
	if (`gmatch $driverAttr "angle*"`)//single angles (not blended angles)
		$idv=`asSetRotationFromAngle $driverObj $driverAttr $dv`;
	}
else
	setAttr ($FKDriverObj+"."+$driverAttr) $dv;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr;
float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
		
if (`objExists $attrCode`)
	warning ("Object "+$attrCode+" already exists");
else
	{
	asCorrectiveDuplicate $attrCode $deformObj;
	addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
	addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;
	}
//asGoToBuildPose bodySetup;
//eval($restorePoseCmd);
autoKeyframe -state $autoKeyframe;
dgdirty -a;
}

global proc asBakeIntoCorrectiveShapes ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl`;
string $source=`textField -q -tx asBakeToCorrective1TextField`;
string $dest=`textField -q -tx asBakeToCorrective2TextField`;
if ($source=="" || !`objExists $source` || `gmatch $source "*[.]*"`)
	error "Source not valid";
if ($dest=="" || !`objExists $dest` || `gmatch $dest "*[.]*"`)
	error "Destination not valid";
string $tempString[]=`listRelatives -s -ni $source`;
string $sourceShape=$tempString[0];
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
asSetAllFK;
select -cl;
$asSkipConfirm=1;
string $xyz[]={"x","x","y","y","z","z"};
float $rots[]={90,-90,90,-90,90,-90};
for ($i=0;$i<size($sel);$i++)
	{
	print ("// Start checking:"+$sel[$i]+"\n");
	if (!`gmatch $sel[$i] "FK*"`)
		continue;
	if (!`sets -im ControlSet $sel[$i]`)
		continue;
	if (`gmatch $sel[$i] "FKExtra*"`)
		continue;
	if (`gmatch $sel[$i] "FKRoot*"`)
		continue;
	for ($y=0;$y<size($xyz);$y++)
		{
		if ($y==0 && !`checkBox -q -v asBakeX1CheckBox`) continue;
		if ($y==1 && !`checkBox -q -v asBakeX2CheckBox`) continue;
		if ($y==2 && !`checkBox -q -v asBakeY1CheckBox`) continue;
		if ($y==3 && !`checkBox -q -v asBakeY2CheckBox`) continue;
		if ($y==4 && !`checkBox -q -v asBakeZ1CheckBox`) continue;
		if ($y==5 && !`checkBox -q -v asBakeZ2CheckBox`) continue;
		print ("// Baking:"+$sel[$i]+".r"+$xyz[$y]+"="+$rots[$y]+"\n");
		setAttr ($sel[$i]+".r"+$xyz[$y]) $rots[$y];
		refresh;
		select $dest;
		$corrective=`asCreateCorrectiveShape`;
		$tempString=`listRelatives -s -ni $corrective`;
		$correctiveShape=$tempString[0];
		connectAttr -f ($sourceShape+".outMesh") ($correctiveShape+".inMesh");
		asConnectCorrectiveShape;
		setAttr ($sel[$i]+".r"+$xyz[$y]) 0;
		}
	}
$asSkipConfirm=0;
eval($restorePoseCmd);
select $sel;
}

global proc string asGetRestorePoseCmd ()
{
string $restorePoseCmd;
string $controlSetMembers[]=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	string $faceControlSetMembers[]=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $faceControlSetMembers`;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	string $attrs[]=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		$restorePoseCmd+="setAttr "+$controlSetMembers[$i]+"."+$attrs[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$attrs[$y])`+";";
	}

return $restorePoseCmd;
}

global proc asJointVis (int $onOff)
{
if (!`objExists Main`)
	return;
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asSkinCurvesToWidth ()
{
if (!`objExists SkinCurves2` || !`objExists SkinCurves1`)
	error "SkinCurves not found. Create SkinCage first";
float $pos[],$pos2[];
string $skinCruves1[]=`listConnections SkinCurves1.drawInfo`;
string $skinCruves2[]=`listConnections SkinCurves2.drawInfo`;
string $tempString[];
string $joint,$aboveBelowProfile,$belowProfile,$parentJoint,$parentTarget;
for ($i=0;$i<size($skinCruves1);$i++)
	{
	tokenize $skinCruves1[$i] "_" $tempString;
	$joint="";
	for ($y=0;$y<size($tempString)-1;$y++)
		{
		$joint+=$tempString[$y];
		if ($y<size($tempString)-2)
			$joint+="_";
		}
	if (!`objExists $joint`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	while (`gmatch $tempString[0] "*Part[0-9]*"`)
		$tempString=`listRelatives -type joint -p $tempString[0]`;
	$parentJoint=$tempString[0];
	if (!`objExists $parentJoint`)
		continue;
	$tempString=`listRelatives -type joint -c $joint`;
	$childJoint=$tempString[0];
	if (!`objExists $childJoint`)
		continue;

	for ($a=0;$a<2;$a++)
		{
		// find profile
		$aboveBelowProfile="";
		if ($a==0)
			{
			if (`objExists ($joint+"_startProfile")`)
				$aboveBelowProfile=$joint+"_startProfile";
			else
				{
				for ($y=20;$y>0;$y--)
					if (`objExists ($parentJoint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$parentJoint+"_twistProfile"+$y;
						break;
						}
				}
			if ($aboveBelowProfile=="")
				continue;
			}
		if ($a==1)
			{
			if (`objExists ($joint+"_endProfile")`)
				$aboveBelowProfile=$joint+"_endProfile";
			else
				{
				for ($y=1;$y<21;$y++)
					if (`objExists ($joint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$joint+"_twistProfile"+$y;
						break;
						}
				}
			}
		if ($aboveBelowProfile=="" || `gmatch $aboveBelowProfile "Neck*"`)//skip neck
			continue;
	
		// place profile
		int $targetIds[2]={0,1};
		$tempString=`listRelatives -p $aboveBelowProfile`;
		string $offsetNode=$tempString[0];
		string $parentConstraint=$offsetNode+"_pointConstraint1";
		string $scaleConstraint=$offsetNode+"_scaleConstraint1";
		string $targetAttrs[]=`listAttr -ud $parentConstraint`;
		setAttr -type float3 ($parentConstraint+".offset") 0 0 0;
		$tempString=`listConnections ($parentConstraint+".target[0].targetParentMatrix")`;
		if ($tempString[0]==`substitute "Profile" $skinCruves1[$i] "Curve"`)
			{
			$targetIds={1,0};
			$tempString=`listConnections ($parentConstraint+".target[1].targetParentMatrix")`;
			if ($tempString[0]=="")
				continue;
			}
		$parentTarget=$tempString[0];
		$pos=`xform -q -ws -t $skinCruves1[$i]`;
		$pos2=`xform -q -ws -t $parentTarget`;
		float $toParentDist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	
		$tempString=`listRelatives -c $skinCruves1[$i]`;
		$innerCurve=$tempString[0];
		$pos=`xform -q -ws -t ($innerCurve+".cv[0]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		float $curveHeight=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		$pos=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[2]")`;
		float $curveWidth=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		float $hwAverage=($curveHeight+$curveWidth)/2.0;
	
		if ($targetAttrs[1]!="")
			{
			float $weight=($hwAverage/2.0)/$toParentDist;
			if ($weight>1)
				$weight=1;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			}
		}
	}
}

global proc asCreateSkinCage ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
softSelect -e -softSelectEnabled 0;
string $tempString[];

if (`objExists MeshGeometry`)
	{
	asRebuildSkinCage;
	return;
	}

createNode -n Cages transform;
parent Cages Geometry;
createNode -n MeshGeometry transform;
parent MeshGeometry Geometry;
setAttr "MeshGeometry.overrideEnabled" 1;
createNode -n MeshCurves transform;
parent MeshCurves Geometry;
createNode -n NurbsGeometry transform;
setAttr NurbsGeometry.v 0;
parent NurbsGeometry Geometry;
sets -em -name SkinCageCurvesSet;
sets -add "Sets" SkinCageCurvesSet;

select -cl;
createDisplayLayer -e -name "SkinCage" -number 1 -nr;
createDisplayLayer -e -name "SkinCurves1" -number 2 -nr;
createDisplayLayer -e -name "SkinCurves2" -number 3 -nr;
setAttr SkinCurves2.visibility 0; setAttr SkinCurves2.displayType 0; setAttr SkinCurves2.color 13;
setAttr SkinCurves1.visibility 1; setAttr SkinCurves1.displayType 0; setAttr SkinCurves1.color 14;
setAttr SkinCage.displayType 2;


//Build tubes
string $topNodes[]=`listRelatives -type joint -c DeformationSystem`;
	asAnalyzeChainJoints $topNodes[0];

//pickup single brancers
string $children[];
$tempString=`asListAllDecents $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	{
	$children=`asListChildren $tempString[$i]`;
	if (size($children)>0)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asBuildChainCurves {$tempString[$i]};
	}

//Branch
asCreateBranchBoxes;

//merge copies.
select `ls -as "*_copy" "*_branch"`;
$tempString=`polyUnite -ch 0 -n skinCage`;
setAttr ($tempString[0]+".keepBorder") 0;
polyMergeVertex -d 0.0001 -am 1 -ch 1 skinCage;
select skinCage;
DeleteHistory;
polyNormal -normalMode 2 -userNormalMode 0 -ch 0 skinCage;
DeleteHistory;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
string $middleCurves[]=`ls -type transform "*_middleCurve"`;

//skinn
string $joint,$twistJoint;
select -cl;
for ($i=0;$i<size($middleCurves);$i++)
	{
	$joint=`substitute "_middleCurve" $middleCurves[$i] ""`;
	select -add $joint;
	//include twistJoints
	for ($y=1;$y<99;$y++)
		{
		tokenize $joint "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$y+"_"+$tempString[1];
		if (`objExists $twistJoint`)
			select -add ($twistJoint);
		else
			break;
		}
	//include nonListedParents
	$tempString=`listRelatives -type joint -p $joint`;
	if (size($tempString))
		if (!`objExists ($tempString[0]+"_middleCurve")`)
			if (!`gmatch $tempString[0] "*Part[0-9]*"`)
				select -add $tempString[0];
	//include 50`s
	if (`objExists ($joint+"_50")`)
		select -add ($joint+"_50");
	//deselect endJoints
	$tempString=`listRelatives -type joint -c $joint`;
	if (!`size($tempString)`)
		select -d $joint;
	}
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r `listRelatives -c MeshGeometry`;
select `ls -sl -ni "*_poly"`;
select -add skinCage;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
string $cylinders[]=`ls -type transform "*_poly"`;
for ($i=0;$i<size($cylinders);$i++)
	{
	delete `listConnections ($cylinders[$i]+"Shape.inMesh")`;
	setAttr -l 1 ($cylinders[$i]+".v") 0;
	}

//wrap
$cylinders=`ls -type transform "*_poly"`;
select -cl;
deformer -type wrap skinCage;
for ($i=0;$i<size($cylinders);$i++)
	{
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;

reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

//scale profileCurves to markers
float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;
$fitSkeletonJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitSkeletonJoints);$i++)
		{
		$fitSkeletonSide[$i]="_R";
		$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
		if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
			$fitSkeletonSide[$i]="_M";

		$side=$fitSkeletonSide[$i];
		if ($b==-1 && $fitSkeletonSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";

		string $profileCurve=$fitSkeletonJoints[$i]+$side+"_middleProfile";
		if (`objExists $profileCurve`)
			{
			if (!`attributeExists fat $fitSkeletonJoints[$i]`)
				continue;
			float $fat=`getAttr ($fitSkeletonJoints[$i]+$side+".fat")`;
			float $fatY=`getAttr ($fitSkeletonJoints[$i]+$side+".fatY")`;
			float $fatZ=`getAttr ($fitSkeletonJoints[$i]+$side+".fatZ")`;
//			float $sca[3]=`getAttr ($fitSkeletonJoints[$i]+".s")`;
//			setAttr -type float3 ($profileCurve+".s") $sca[0] $sca[1] $sca[2];
//			setAttr ($profileCurve+".sx") $scale;
			setAttr ($profileCurve+".sy") ($fat*$fatY*$scale);
			setAttr ($profileCurve+".sz") ($fat*$fatZ*$scale);
			refresh;
			}
		}

//Profiles tweaks
asProfileTweaks;
print "// SkinCage created\n";
select -cl;
}

global proc asDeleteSkinCage ()
{
string $deleteObjs[]={"skinCage","SkinSub","Cages","MeshGeometry","MeshCurves","NurbsGeometry","SkinCage","SkinCurves1","SkinCurves2","SkinCageCurvesSet"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asRebuildSkinCage ()
{
string $restoreShapesCmds[];
string $profileCurveShapes[]=`ls -type nurbsCurve "*ProfileShape*"`;
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($profileCurveShapes);$i++)
	{
	$form=`getAttr ($profileCurveShapes[$i]+".form")`;
	$spans=`getAttr ($profileCurveShapes[$i]+".spans")`;
	$degrees=`getAttr ($profileCurveShapes[$i]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($profileCurveShapes[$i]+".cv["+$y+"]")`;
		$restoreShapesCmds[size($restoreShapesCmds)]="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$profileCurveShapes[$i]+".cv["+$y+"];";
		}
	}

asDeleteSkinCage;
asCreateSkinCage;
for ($i=0;$i<size($restoreShapesCmds);$i++)
	print ($restoreShapesCmds[$i]+"\n");
for ($i=0;$i<size($restoreShapesCmds);$i++)
	catchQuiet (`eval $restoreShapesCmds[$i]`);
}

global proc asProfileTweaks ()
{
int $cvs[],$oppositeCvs[];
string $heelFitJoint;
string $tempString[];
string $ankleProfileEnds[]=`ls -type transform "*Ankle*_*endProfile"`;
for ($i=0;$i<size($ankleProfileEnds);$i++)
	{
	string $ankle=`substitute "_endProfile" $ankleProfileEnds[$i] ""`;
	int $numChar=size($ankle);
	string $fitAnkle=`substring $ankle 1 ($numChar-2)`;
	string $side=`substring $ankle ($numChar-1) 99`;
	int $b=1;
	if ($side=="_L") $b=-1;
	$heelFitJoint="";
	$tempString=`listRelatives -c -type joint $fitAnkle`;
	for ($y=0;$y<size($tempString);$y++)
		{
		string $label=`asLabel $tempString[$y]`;
		if (`gmatch $label "*Heel*"`)
			$heelFitJoint=$tempString[$y];
		}
	if ($heelFitJoint=="")
		continue;
	float $anklePos[]=`xform -q -ws -t $ankleProfileEnds[$i]`;
	float $heelPos[]=`xform -q -ws -t $heelFitJoint`;
	if (`gmatch $ankleProfileEnds[$i] "*_R_*"`)
		$cvs={0,1,4};
	else
		$cvs={2,3};
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -os -t ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t ($heelPos[0]*$b) $heelPos[1] $heelPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		move -r -os 0 0 $existingPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $anklePos[0] $anklePos[1] $anklePos[2] 1.2 1.2 1 ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		}
	}
string $toeProfileMiddle[]=`ls -type transform "*Toes*Profile"`;
for ($i=0;$i<size($toeProfileMiddle);$i++)
	{
	$transformPos=`xform -q -ws -t $toeProfileMiddle[$i]`;
	if (`gmatch $toeProfileMiddle[$i] "*_R_*"`)
		{$cvs={0,1,4};$oppositeCvs={2,3};}
	else
		{$cvs={2,3};$oppositeCvs={0,1,4};}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t $existingPos[0] 0 $existingPos[2] ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 1.2 1.2 1 ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]"); 
		}
	for ($y=0;$y<size($oppositeCvs);$y++)
		{
		if (`gmatch $toeProfileMiddle[$i] "*_start*"`)
			scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 0.5 0.5 1 ($toeProfileMiddle[$i]+".cv["+$oppositeCvs[$y]+"]"); 
		}
	}
}

global proc asCreateSliders ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";

if (`objExists closestSampler`)
	delete closestSampler;
if (!`objExists SlideSystem`)
	createNode -n SlideSystem -p MotionSystem transform;

int $sideFactor=1;
int $vtxNr[];
int $bendAxis;
string $tempString[],$branchVtxs[],$branchVtxSliderNrs[];
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*_L_*"`)
		$sideFactor=-1;
	else
		$sideFactor=1;

	$bendAxis=0;//all directions
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];

	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -type joint -p $parent`;
		$parent=$tempString[0];
		}
	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $firstPa=$tempString[0];

	if ($skinCurveSliderInfo[1]=="")
		{
		print ("// Skipping "+$sel[$i]+", as it`s not defining start or end or middle of deformation\n");
		continue;
		}
	string $stEnMid=$skinCurveSliderInfo[1];
	if (`objExists ($deformJoint+"_"+$stEnMid+"Slider0")` || `objExists ($deformJoint+"_"+$stEnMid+"Slider1")`)
		continue;

	createNode -n messureTemp transform;
	pointConstraint $sel[$i] messureTemp;
	parent messureTemp $firstPa;
	if ($skinCurveSliderInfo[1]=="end")
		parent messureTemp $deformJoint;
	float $xOffset=`getAttr messureTemp.tx`;
	delete messureTemp;

	//create the 50joint
	int $baseStrucExists=0;
	if (`objExists ($deformJoint+"_Slide50")`)
		$baseStrucExists=1;
	if (!$baseStrucExists)
		{
		select $deformJoint;
		joint -n ($deformJoint+"_Slide50");
		setAttr ($deformJoint+"_Slide50.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide50") $firstPa;
		createNode -n ($deformJoint+"_Slide00") transform;
		parent ($deformJoint+"_Slide00") $deformJoint;
		setAttr -type float3 ($deformJoint+"_Slide00.t") 0 0 0;
		setAttr -type float3 ($deformJoint+"_Slide00.r") 0 0 0;
		setAttr ($deformJoint+"_Slide00.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide00") $firstPa;
		$tempString=`orientConstraint ($deformJoint+"_Slide00") $deformJoint ($deformJoint+"_Slide50")`;
//		setAttr ($tempString[0]+".interpType") 2; //`shortest` seem to be stable
//	shortest works best on elbow that has twists
		$tempString=`pointConstraint $deformJoint ($deformJoint+"_Slide50")`;
		setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
		}

	//only 2 for elbow/knee, determine $bendAxis
	if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
		{
		float $jo[]=`getAttr ($deformJoint+".jointOrient")`; // check jointOrient to find bend axis
		if (abs($jo[1])>abs($jo[2])) $bendAxis=1;// .joY greater than .joZ, so not a Zbender
		if (abs($jo[2])>abs($jo[1])) $bendAxis=2;// .joZ greater than .joY, so not a Ybender
		}

	for ($y=0;$y<4;$y++)
		{
		//only 2 for elbow/knee, determine $bendAxis
		if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
			{
			if ($bendAxis==1) if ($y==0 || $y==2) continue;
			if ($bendAxis==2) if ($y==1 || $y==3) continue;
			}
		if ($skinCurveSliderInfo[1]=="start") select $firstPa;
		if ($skinCurveSliderInfo[1]=="middle") select ($deformJoint+"_Slide50");
		if ($skinCurveSliderInfo[1]=="end") select $deformJoint;
		joint -n ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		sets -add ("DeformSet") ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		float $posA[3]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		float $posB[3]=`xform -q -ws -t ($sel[$i]+".cv["+($y+1)+"]")`;
		float $pos[3]={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_"+$stEnMid+"Slider"+$y);

		if (!$baseStrucExists)
			{
			// recylcle these between starters, enders, and middlers
			createNode -n ($deformJoint+"_SlideDist"+$y) distanceBetween	;
			createNode -n ($deformJoint+"_SlideStart"+$y) transform;
			createNode -n ($deformJoint+"_SlideEnd"+$y) transform;
//			connectAttr -f ($deformJoint+"_SlideStart"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point1");
			connectAttr -f ($deformJoint+"_SlideEnd"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point2");
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideStart"+$y);
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideEnd"+$y);
//			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
//			setAttr -type float3 ($deformJoint+"_SlideEnd"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
			parent ($deformJoint+"_SlideStart"+$y) $firstPa;
			parent ($deformJoint+"_SlideEnd"+$y) $firstPa;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideStart"+$y);
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideEnd"+$y);		
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_Slide50");
			setAttr ($deformJoint+"_SlideEnd"+$y+".tx") 0;
			float $temp[3]=`getAttr ($deformJoint+"_SlideEnd"+$y+".t")`;
			float $mag=`mag <<$temp[0],$temp[1],$temp[2]>>`*$sideFactor;
			$temp[0]=`getAttr ($deformJoint+".tx")`;
			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".t") ($temp[0]-$mag) 0 0;
			parent ($deformJoint+"_SlideStart"+$y) SlideSystem;
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo $firstPa ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo ($deformJoint+"_Slide50") ($deformJoint+"_SlideEnd"+$y);
			//behaviour
			createNode -n ($deformJoint+"_SlideDistNormalize"+$y) multiplyDivide;
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDist"+$y+".distance") ($deformJoint+"_SlideDistNormalize"+$y+".input1X");
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".input2X") `getAttr ($deformJoint+"_SlideDistNormalize"+$y+".input1X")`;
			}

		//they all share `_SlideMultiply` & `SlideReducer` & `_SlidePlusOffset`
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
		setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") 0.3;
		if ($skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") -0.3;
		//on opposide side, the start and end must move opposite direction
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") (`getAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X")`*$sideFactor);
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y) multiplyDivide;
		addAttr -k 1 -ln slide -at double -dv 1 ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		connectAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".slide") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input2X");
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input1X");
		createNode -n ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y) plusMinusAverage;
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[0]");
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			{
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y) plusMinusAverage;
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[0]");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[1]") 1;

			connectAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") $xOffset;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".tx");
			}
		if ($skinCurveSliderInfo[1]=="middle")
			{
			string $slideAxis="z";
			if ($bendAxis==2)
				$slideAxis="y";
			if (($bendAxis==0) && ($y==0 || $y==2))
				$slideAxis="y";
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y) reverse;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".inputX");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y) condition;
			if (`getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`>0)
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 4;
			else
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 2;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".firstTerm");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfFalseR");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y) multiplyDivide;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input2X") -1;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfTrueR");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".outColorR") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");

			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") `getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis);

			}

		//skinning
		skinCluster -e -lw false -wt 0 -ai ($deformJoint+"_"+$stEnMid+"Slider"+$y) skinClusterSkinCage;
		float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$y) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
		if ($bendAxis==0) //all directions
			{
			if ($y>0) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+($y-1)) 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
			if ($y==3) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider3") 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[0]+"]");
			}
		if (($bendAxis==1 && $y==3) || ($bendAxis==2 && $y==2)) //last loop for Z or Ybender
			{
			int $pickupVtx=2;
			int $sliderNr=1;
			if ($bendAxis==2) {$pickupVtx=1;$sliderNr=0;}
			float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			$pickupVtx=4;
			$sliderNr=3;
			if ($bendAxis==2) {$pickupVtx=3;$sliderNr=2;}
			$temp=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			}
		}

	//branchVtx`s edgeloopCheck to see if there`s a extra vtx, if so.. this is a `brancher`
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	$branchVtxSliderNrs=`asGetBranchedVtx $tempString 1`;
	for ($y=0;$y<size($branchVtxs);$y++)
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$branchVtxSliderNrs[$y]) 1 skinClusterSkinCage $branchVtxs[$y];
	}

if (`objExists closestSampler`)
	delete closestSampler;
print "// Sliders created\n";
select $sel;
}

global proc string[] asGetBranchedVtx (string $inputVtxs[], int $vertsOrSliderNr)
{
string $return[],$branchVtxs[],$branchVtxSliderNrs[];
string $connectVtx0s[],$connectVtx1s[],$connectVtx2s[],$connectVtx3s[];
for ($y=0;$y<4;$y++)
	{
	select $inputVtxs[$y];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $inputVtxs[$y];
	$tempString=`ls -sl -fl`;
	if ($y==0) $connectVtx0s=$tempString;
	if ($y==1) $connectVtx1s=$tempString;
	if ($y==2) $connectVtx2s=$tempString;
	if ($y==3) $connectVtx3s=$tempString;
	}
for ($y=0;$y<size($connectVtx0s);$y++) {
	if (`stringArrayCount $connectVtx0s[$y] $connectVtx1s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=0;}
if (`stringArrayCount $connectVtx0s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=3;}}
for ($y=0;$y<size($connectVtx1s);$y++)
	if (`stringArrayCount $connectVtx1s[$y] $connectVtx2s`) {$branchVtxs[size($branchVtxs)]=$connectVtx1s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=1;}
for ($y=0;$y<size($connectVtx2s);$y++)
	if (`stringArrayCount $connectVtx2s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx2s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=2;}
if ($vertsOrSliderNr)
	$return=$branchVtxSliderNrs;
else
	$return=$branchVtxs;
return $return;
}

global proc asDeleteSliders ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
string $tempString[];
int $vtxNr[];
for ($i=0;$i<size($sel);$i++)
	{
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];
	int $haveSliderJoint[4];
	for ($y=0;$y<4;$y++)
		{
		//skinning
		float $pos[]=`xform -q -ws -t $sel[$i]`;
		createNode -n closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker1;
		$pos=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		createNode -n closestSamplerShrinker2 -p closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker2;
		$pos=`xform -q -ws -t closestSamplerShrinker2`;
		scale -r 0.832 0.832 0.832 closestSamplerShrinker1;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		delete closestSamplerShrinker1;
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		}
	//$branchVtxs
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	for ($y=0;$y<size($branchVtxs);$y++)
		{
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage $branchVtxs[$y];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage $branchVtxs[$y];
		}
	//delete the joint
	for ($y=0;$y<4;$y++)
		if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
			delete ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y);

	//remove 50 system, if no longer required
	int $remove50=0;
	if (!`objExists ($skinCurveSliderInfo[0]+"_SlideDistNormalize1")`)
		{
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide50")`)
			delete ($skinCurveSliderInfo[0]+"_Slide50");
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide00")`)
			delete ($skinCurveSliderInfo[0]+"_Slide00");
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y)`)
				delete ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y);
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
select -cl;
}

global proc string asListParent (string $obj)
{
string $tempString[]=`listRelatives -type joint -p $obj`;
if (`attributeExists Scapula $tempString[0]`)
	$tempString=`listRelatives -type joint -p $tempString[0]`;
return $tempString[0];
}

global proc string[] asListChildren (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -c $obj`;
string $tempString2[];
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	if (`attributeExists Scapula $tempString[$i]`)
		$skip=1;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempString[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skipChildrenToo=1;
	if (`attributeExists noMiddleCurve $tempString[$i]`)
		{
		$skip=1;
		$skipChildrenToo=1;
		}
	if ($skip)
		{
		if (!$skipChildrenToo)
			{
			$tempString2=`listRelatives -type joint -c $tempString[$i]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$skip=0;
				for ($y=0;$y<size($skips);$y++)
					if (`gmatch $tempString2[$z] ("*"+$skips[$y]+"*")`)
						$skip=1;
				if (!$skip)
					$result[size($result)]=$tempString2[$z];
				}
			}
		}
	else
		if ($tempString[$i]!="")
			$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc string[] asListAllDecents (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -ad $obj`;
string $tempStringFullPath[]=`listRelatives -type joint -ad -f $obj`;
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_","Jaw_","Eye_","_50","Float","Part[0-9]_","Part[0-9][0-9]_"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	if (`attributeExists Scapula $tempString[$i]`)
		$skip=1;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempStringFullPath[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skip=1;
	if (!$skip)
		$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc asAnalyzeChainJoints (string $firstJoint)
{
string $kids[]=`asListChildren $firstJoint`;
string $chainJoints[],$tempString[];
clear $chainJoints;
float $pos[3];

//If $firstJoint is "*Part[0-9]*", then downscan until solid firstJoint
if (`gmatch $firstJoint "*Part[0-9]*"`)
	{
	string $child=$firstJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`asListChildren $child`;
		$child=$tempString[0];
		if (!`gmatch $child "*Part[0-9]*"`)
			break;
		}
	$firstJoint=$child;
	clear $kids;
	$kids=`asListChildren $firstJoint`;
	}


while(size($kids)==1)
	{
	if (size($chainJoints)==0)
		$chainJoints[size($chainJoints)]=$firstJoint;
	if (!`gmatch $kids[0] "*Part[0-9]*"`)
		$chainJoints[size($chainJoints)]=$kids[0];
	$tempString=`asListChildren $kids[0]`;
	clear $kids;
	for ($y=0;$y<size($tempString);$y++)
			$kids[size($kids)]=$tempString[$y];
	}

if (size($kids)>1)
	for ($y=0;$y<size($kids);$y++)
		asAnalyzeChainJoints $kids[$y];

if (size($chainJoints))
	if (!`objExists ($chainJoints[0]+"_middleCurve")`)
		asBuildChainCurves $chainJoints;
}

global proc asBuildChainCurves (string $chainJoints[])
{
int $childIsTwistJoint;
int $firstChildMinusX[],$spineJoint[],$terminator[],$topJoint[],$downTwist[],$upTwist[];
float $twistAmount;
float $charHeight=`asgetCharHeight`;
string $curve,$startCurve,$endCurve,$twistCurve,$surface,$poly,$parent,$parentChainJoint,$childChainJoint,$twistJoint,$skinToJoint;
string $tempString[],$tempString2[],$children[],$siblings[],$curves[],$startCurves[],$middleCurves[],$endCurves[],$twistCurves[];
float $scale;
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (`gmatch $chainJoints[$i] "Head_M"` || `gmatch $chainJoints[$i] "Hair_M"` || `gmatch $chainJoints[$i] "Root_M"` || `gmatch $chainJoints[$i] "Spine*_M"` || `gmatch $chainJoints[$i] "Chest_M"` || `gmatch $chainJoints[$i] "Tail*_M"`)
		$spineJoint[$i]=1;
	$tempString=`asListChildren $chainJoints[$i]`;
	if (size($tempString))
		if (`getAttr ($tempString[0]+".tx")`<0)
			$firstChildMinusX[$i]=1;
	if (size($tempString)==0)
		$terminator[$i]=1;
	if (`asListParent $chainJoints[$i]`=="")
		$topJoint[$i]=1;
	}

//Middlecurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$middleCurve=$chainJoints[$i]+"_middleCurve";
	$middleCurves[size($middleCurves)]=$middleCurve;
	asCreateMeshCurve $middleCurve;
	$profileCurve=`substitute "Curve" $middleCurve "Profile"`;
	$scale=$charHeight/40;
	if (`gmatch $chainJoints[$i] "Wrist_*"`)
		$scale=$charHeight/80;
	if (`gmatch $chainJoints[$i] "Elbow_*"`)
		$scale=$charHeight/60;
	if (`gmatch $chainJoints[$i] "*Finger*"`)
		$scale=$charHeight/140;
	if ($spineJoint[$i])
		$scale=$charHeight/15;
	xform -os -s $scale $scale $scale $profileCurve;

	asAlign $profileCurve $chainJoints[$i] 1 1 0 0;
	if ($terminator[$i])
		asAlign $profileCurve `asListParent $chainJoints[$i]` 0 1 0 0;
	parent $profileCurve MeshCurves;
	editDisplayLayerMembers -noRecurse SkinCurves1 $profileCurve;
	refresh;
	}

//Twistcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$childIsTwistJoint=1;
	$joint=$chainJoints[$i];
	while($childIsTwistJoint)
		{
		$childIsTwistJoint=0;
		$tempString=`asListChildren $joint`;
		$twistJoint=$tempString[0];
		$joint=$twistJoint;
		if (`gmatch $joint "*Part[0-9]*"`)
			$childIsTwistJoint=1;
		else
			break;
		if ($childIsTwistJoint)
			{
			$downTwist[$i]=$downTwist[$i]+1;
			$twistCurve=$chainJoints[$i]+"_twistCurve"+$downTwist[$i];
			$twistCurves[size($twistCurves)]=$twistCurve;
			asCreateMeshCurve $twistCurve;
			$profileCurve=`substitute "Curve" $twistCurve "Profile"`;
			createNode -n ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") transform;
			parent ($chainJoints[$i]+"_twistProfile"+$downTwist[$i]) ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			parent ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") MeshCurves;
			editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
			asAlign ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") $twistJoint 1 1 0 0;
			$twistAmount=0.5;
			if (`attributeExists twistAmount $twistJoint`)
				$twistAmount=`getAttr ($twistJoint+".twistAmount")`*0.8;
			pointConstraint -mo -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			pointConstraint -mo -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			}
		}
	if ($i>0 && $downTwist[$i-1])
		$upTwist[$i]=$downTwist[$i-1];
	}

//Startcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		$startCurve=$chainJoints[$i]+"_startCurve";
		$startCurves[size($startCurves)]=$startCurve;
		asCreateMeshCurve $startCurve;
		$profileCurve=`substitute "Curve" $startCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_startCurveOffset") transform;
		parent ($chainJoints[$i]+"_startProfile") ($chainJoints[$i]+"_startCurveOffset");
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_startCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		//first startCurve
		if ($i==0)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_startProfile.tx") 0.482;
			else
				setAttr ($chainJoints[$i]+"_startProfile.tx") -0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		if ($i>0)
			{
			pointConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			}
		}
	}

//Endcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		$endCurve=$chainJoints[$i]+"_endCurve";
		$endCurves[size($endCurves)]=$endCurve;
		asCreateMeshCurve $endCurve;
		$profileCurve=`substitute "Curve" $endCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_endCurveOffset") transform;
		parent ($chainJoints[$i]+"_endProfile") ($chainJoints[$i]+"_endCurveOffset");
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_endCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		//last endCurve
		if ($i==size($chainJoints)-1)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_endProfile.tx") -0.482;
			else
				setAttr ($chainJoints[$i]+"_endProfile.tx") 0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		if ($i<size($chainJoints)-1)
			{
			pointConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			}
		}
	}

for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_startCurve";
	$curves[size($curves)]=$chainJoints[$i]+"_middleCurve";
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_endCurve";
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		$curves[size($curves)]=$chainJoints[$i]+"_twistCurve"+$y;


	//branch
	$children=`asListChildren $chainJoints[$i]`;
	$tempString[0]=`asListParent $chainJoints[$i]`;
	$parent=$tempString[0];
	if ($parent!="")
		$siblings=`asListChildren $parent`;
	if (!(size($children)>1 || size($siblings)>1))
		continue;
	}

$surface=$chainJoints[0]+"_surface";
$poly=$chainJoints[0]+"_poly";
if (size($chainJoints)==1)
		extrude -n $surface -ch 1 -rn false -po 0 -et 0 -upn 1 -length ($charHeight/-250) -rotation 0 -scale 1 -dl 3 $curves;
else
	loft -n $surface -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true $curves;
parent $surface NurbsGeometry;
nurbsToPoly -n $poly -mnd 1 -ch 1 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0 -es 0 -ntr 0 -mrt 0 -uss 1 $surface;
polySoftEdge -angle 0 -ch 1 $poly;
if (`gmatch $chainJoints[0] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $poly;
//polyMergeVertex -d 0.01 -am 1 -ch 1 $poly;
polyMergeVertex -d 0.0001 -am 1 -ch 1 $poly;
//displaySmoothness -polygonObject 3;
duplicate -n ($poly+"_copy") $poly;
parent $poly MeshGeometry;

//Create SkinCluster
select $chainJoints;
//include parentJoint
$tempString=`listRelatives -type joint -p $chainJoints[0]`;
if (size($tempString))
	select -add $tempString[0];
//deselect endJoints
for ($i=0;$i<size($chainJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
	if (!`size($tempString)`)
		select -d $chainJoints[$i];
	}
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -type joint -c $tempString[$i]`;
	if (size($tempString2))
		select -add $tempString[$i];
	}
//include twistJoints
for ($i=0;$i<size($chainJoints);$i++)
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		select -add ($tempString[0]+"Part"+$y+"_"+$tempString[1]);
		}
//include 50`s
for ($i=0;$i<size($chainJoints);$i++)
	if (`objExists ($chainJoints[$i]+"_50")`)
		select -add ($chainJoints[$i]+"_50");
select -add $poly;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

float $temp[3];
int $vertIndex;
if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($poly+"Shape.outMesh") closestSampler.inMesh;
$tempString=`listConnections ($poly+"Shape.inMesh")`;
string $skinCluster=$tempString[0];

//Skinning cylinders
for ($i=0;$i<size($chainJoints);$i++)
	{
	//Middlecurves
	for ($y=0;$y<4;$y++)
		{
		$temp=`xform -q -ws -t ($chainJoints[$i]+"_middleCurve.cv["+$y+"]")`;
		setAttr closestSampler.inPositionX $temp[0];
		setAttr closestSampler.inPositionY $temp[1];
		setAttr closestSampler.inPositionZ $temp[2];
		$vertIndex=`getAttr closestSampler.closestVertexIndex`;
		$skinToJoint=$chainJoints[$i];
		$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
		if (!`size($tempString)`)
			{
			$tempString2=`listRelatives -type joint -p $chainJoints[$i]`;
			if (`size($tempString2)`)
				$skinToJoint=$tempString2[0];
			}

		skinPercent -tv $skinToJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		$tempString=`listRelatives -type joint -p $chainJoints[$i]`;
		if (!$spineJoint[$i])
			if (size($tempString))
				if ($skinToJoint==$chainJoints[$i])
					skinPercent -tv $tempString[0] 0.5 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		if (`objExists ($chainJoints[$i]+"_50")`)
			skinPercent -tv ($chainJoints[$i]+"_50") 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
		}

	//Twistcurves
	for ($z=1;$z<$downTwist[$i]+1;$z++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$z+"_"+$tempString[1];
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_twistCurve"+$z+".cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $twistJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}

		}

	//Startcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$topJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_startCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			if ($i>0)
				skinPercent -tv $chainJoints[$i-1] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			else
				{
				$tempString=`listRelatives -type joint -p $chainJoints[0]`;
				skinPercent -tv $tempString[0] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
				}
			}
		}
	//Endcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_endCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $chainJoints[$i] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}
		}
	}
if (size($children)==0)
	{
	$endJoint=$chainJoints[size($chainJoints)-1];
	polyPlane -n ($endJoint+"_cap_copy") -w 1 -h 1 -sx 1 -sy 1 -ax 1 0 0 -cuv 2 -ch 0;
	if (`gmatch $endJoint "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($endJoint+"_cap_copy");
	setAttr -type float3 ($endJoint+"_cap_copy.s") ($scale*2*(1/1.2)) ($scale*2*(1/1.2)) ($scale*2*(1/1.2));
	asAlign ($endJoint+"_cap_copy") $endJoint 1 1 0 0;
	asAlign ($endJoint+"_cap_copy") `asListParent $endJoint` 0 1 0 0;
	}
}

global proc asCreateMeshCurve (string $curve)
{
$tempString[0]=`curve -d 1 -p 0 -1 1 -p 0 1 1 -p 0 1 -1 -p 0 -1 -1 -p 0 -1 1`;
rename $tempString[0] $curve;
reverseCurve -ch 0 -rpo 1 $curve;
$profileCurve=`substitute "Curve" $curve "Profile"`;
duplicate -n $profileCurve $curve;
sets -add SkinCageCurvesSet $profileCurve;
scale -r 1.2 1.2 1.2 $profileCurve;
parent $curve $profileCurve;
connectAttr ($profileCurve+".worldSpace[0]") ($curve+".create");
setAttr ($curve+".v") 0;
}

global proc asCreateBranchBoxes ()
{
int $sortedNr[],$closestParentCvs[],$closestChildCvs[],$furthestParentCvs[],$furthestChildCvs[];
int $tempInt;
string $parentCurve,$firstChild,$nextChild,$polyCreateFacetCmd;
string $tempString[],$tempString2[],$children[],$childrenCurves[],$sortedChildren[];
float $minX,$maxX,$minY,$maxY,$minZ,$maxZ,$min,$dist;
float $pos[3],$pos2[3],$childPos[3],$deltaPos[3],$spreadMostVector[3],$cubePos[3],$temp[3],$temp2[3];
float $Xs[],$Ys[],$Zs[],$sortValues[];
string $joints[]=`asListAllDecents DeformationSystem`;

for ($i=0;$i<size($joints);$i++)
	{
	$tempString=`asListChildren $joints[$i]`;
	if (size($tempString)<2) // branching only with 2 or more children
		continue;

	//find $children
	clear $children;
	clear $sortedChildren;
	clear $childrenCurves;
	for ($y=0;$y<size($tempString);$y++) // child with no child of it`s own, is not a branch
		{
		$tempString2=`asListChildren $tempString[$y]`;
		if (size($tempString2))
			$children[size($children)]=$tempString[$y];
		}

	if (size($children)<2) // branching only with 2 or more children (check again, now that `false` children has been removed)
		continue;

	//For the Root, pick the first *_M child as parent, and drop it as child
	string $rootParent="";
	if ($joints[$i]=="Root_M")
		{
		for ($y=0;$y<size($children);$y++)
			if (`gmatch $children[$y] "*_M"`)
				$rootParent=$children[$y];
		if ($rootParent=="")
			$rootParent=$children[0];
		if (`gmatch $rootParent "*Part[0-9]_M"`)
			{
			//Find first non-*Part[0-9]
			string $child=$rootParent;
			for ($y=0;$y<99;$y++)
				{
				$tempString=`listRelatives -c -type joint $child`;
				$child=$tempString[0];
				if (!`gmatch $child "*Part[0-9]*"`)
					break;
				}
			$children=`stringArrayRemove {$rootParent} $children`;
			$rootParent=$child;
			$children[size($children)]=$child;
			}
		$children=`stringArrayRemove {$rootParent} $children`;
		}

	//find $spreadMostVector
	$minX=99;$minY=99;$minZ=99;
	$maxX=-99;$maxY=-99;$maxZ=-99;
	for ($y=0;$y<size($children);$y++)
		{
		$temp=`xform -q -ws -t $children[$y]`;
		if ($temp[0]<$minX) $minX=$temp[0];
		if ($temp[0]>$maxX) $maxX=$temp[0];
		if ($temp[1]<$minY) $minY=$temp[1];
		if ($temp[1]>$maxY) $maxY=$temp[1];
		if ($temp[2]<$minZ) $minZ=$temp[2];
		if ($temp[2]>$maxZ) $maxZ=$temp[2];
		}
	$xDif=$maxX-$minX;$yDif=$maxY-$minY;$zDif=$maxZ-$minZ;
	if ($xDif>$yDif && $xDif>$zDif) $spreadMostVector={1,0,0}; //e.g. chest/root
	if ($yDif>$xDif && $yDif>$zDif) $spreadMostVector={0,1,0}; //e.g. dinospikes (could be chest if neck.ty>shoulder.tx
	if ($zDif>$xDif && $zDif>$yDif) $spreadMostVector={0,0,1}; //e.g. wrist

	//sort children (by distance between themselves)
	for ($y=0;$y<size($children);$y++)
		{
		$temp=`xform -q -ws -t $children[$y]`;
		$Xs[$y]=$temp[0];$Ys[$y]=$temp[1];$Zs[$y]=$temp[2];
		}
	$min=999;
	if ($spreadMostVector[0]) $sortValues=$Xs;
	if ($spreadMostVector[1]) $sortValues=$Ys;
	if ($spreadMostVector[2]) $sortValues=$Zs;
	for ($y=0;$y<size($children);$y++)
		if ($sortValues[$y]<$min)
			{
			$firstChild=$children[$y];
			$min=$sortValues[$y];
			}
	$sortedChildren[0]=$firstChild;
	$nextChild=$firstChild;
	for ($a=0;$a<size($children);$a++)
		{
		$min=999;
		$checkChild=$nextChild;
		$pos=`xform -q -ws -t $checkChild`;
		for ($y=0;$y<size($children);$y++)
			{
			if ($children[$y]==$checkChild || `stringArrayCount $children[$y] $sortedChildren`)
				continue;
			$dist=`mag<<$Xs[$y]-$pos[0],$Ys[$y]-$pos[1],$Zs[$y]-$pos[2]>>`;
			if ($dist<$min)
				{
				$nextChild=$children[$y];
				$min=$dist;
				}
			}
		if(!`stringArrayCount $nextChild $sortedChildren`)
			$sortedChildren[size($sortedChildren)]=$nextChild;
		}

	//find $parentCurve
	$parentCurve=$joints[$i]+"_middleCurve";
	if (`objExists ($joints[$i]+"_endCurve")`)
		$parentCurve=($joints[$i]+"_endCurve");
//		$parentCurve=($joints[$i]+"_middleCurve");
	if ($joints[$i]=="Root_M")
		$parentCurve=$rootParent+"_middleCurve";

	//find $childrenCurves
	for ($y=0;$y<size($sortedChildren);$y++)
		{
		if (`objExists ($sortedChildren[$y]+"_startCurve")`)
			$childrenCurves[$y]=$sortedChildren[$y]+"_startCurve";
		else if (`objExists ($sortedChildren[$y]+"_middleCurve")`)
			$childrenCurves[$y]=$sortedChildren[$y]+"_middleCurve";
		}

	//aimed $childrenCurves
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		duplicate -n ($childrenCurves[$y]+"TempAimed") $childrenCurves[$y];
		parent -w ($childrenCurves[$y]+"TempAimed");
		float $aimVec[]={-1,0,0};
		if (`gmatch $sortedChildren[$y] "*_L"`)
			$aimVec={1,0,0};
		string $aimAt=$joints[$i];
		if ($joints[$i]=="Root_M")
			$aimAt=$parentCurve;
		$tempString=`aimConstraint -aimVector $aimVec[0] $aimVec[1] $aimVec[2] -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $childrenCurves[$y] $aimAt ($childrenCurves[$y]+"TempAimed")`;
		delete $tempString[0];
		}

	//Find $closestCVS
	$min=999;
	for ($a=0;$a<4;$a++)
		{
		$pos=`xform -q -ws -t ($parentCurve+".cv["+$a+"]")`;
		for ($b=0;$b<4;$b++)
			{
			$pos2=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$b+"]")`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			if ($dist<$min)
				{
				$closestParentCvs[0]=$a;
				$closestChildCvs[0]=$b;
				$min=$dist;
				}
			}
		}
	//Find second $closestCVS
	$min=999;
	for ($a=0;$a<4;$a++)
		{
		if($a==$closestParentCvs[0])
			continue;
		$pos=`xform -q -ws -t ($parentCurve+".cv["+$a+"]")`;
		for ($b=0;$b<4;$b++)
			{
			if ($b==$closestChildCvs[0])
				continue;
			$pos2=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$b+"]")`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			if ($dist<$min)
				{
				$closestParentCvs[1]=$a;
				$closestChildCvs[1]=$b;
				$min=$dist;
				}
			}
		}

	//sideFace1
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$pos2=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$pos3=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
	$pos4=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchStart -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $sortedChildren[0] "*_L"` && `gmatch $joints[$i] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchStart");

	//child2childFace`s
	int $childACv[]=`asCvFlip $closestChildCvs`;
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		$pos3=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos4=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		if (`gmatch $sortedChildren[$y+1] "*_L"` && !`gmatch $sortedChildren[$y] "*_L"`)//first `mirrored`
			{
			$pos3=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
			$pos4=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
			}
		$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branch"+$y+" -ch 0 -tx 1 -s 1";
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
		$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
		eval ($polyCreateFacetCmd);
		if (`gmatch $sortedChildren[$y] "*_L"` && `gmatch $joints[$i] "*_L"`)
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branch"+$y);
		}

	//sideFace2
	int $childACv2[]=`asCvFlip $closestParentCvs`;
	int $lastChildNr=size($childrenCurves)-1;
	$pos1=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[1]+"]")`;
	$pos2=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[0]+"]")`;
	if (`gmatch $sortedChildren[$lastChildNr] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
		{
		$pos1=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[0]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[1]+"]")`;
		}
	$pos3=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$pos4=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchEnd -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $sortedChildren[$lastChildNr] "*_L"` && `gmatch $joints[$i] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchEnd");

	//backFace n-sided
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchBack -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		if (`gmatch $sortedChildren[$y] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
			{
			$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
			$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
			}
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);

	//frontFace n-sided
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchFront -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		if (`gmatch $sortedChildren[$y] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
			{
			$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
			$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
			}
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);
	polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchFront");

	//polyUnite branch-bits
	select ($joints[$i]+"_branchStart") ($joints[$i]+"_branchEnd") ($joints[$i]+"_branchFront") ($joints[$i]+"_branchBack");
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		select -add ($joints[$i]+"_branch"+$y);
	polyUnite -n ($joints[$i]+"_branch") -ch 0 -mergeUVSets 1;

	//wireDeform into place
	wire -n ($joints[$i]+"_branchWire") -dds 0 0.001 -gw false -en 1.0 -ce 0.0 -li 0.0 ($joints[$i]+"_branch");
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		select ($childrenCurves[$y]+"TempAimed");
		select -add ($joints[$i]+"_branch");
		AddWire;
		setAttr ($joints[$i]+"_branchWire.dropoffDistance["+$y+"]") 0.001;
		}
	for ($y=0;$y<size($childrenCurves);$y++)
		orientConstraint $childrenCurves[$y] ($childrenCurves[$y]+"TempAimed");

	//cleanup
	select ($joints[$i]+"_branch");
	DeleteHistory;
	for ($y=0;$y<size($childrenCurves);$y++)
		delete ($childrenCurves[$y]+"TempAimed") ($childrenCurves[$y]+"TempAimedBaseWire");
	}
}

global proc int[] asCvFlip (int $vc[])
{
int $flipCv[]=$vc;
if ($vc[0]==0 && $vc[1]==1) $flipCv={3,2};
if ($vc[0]==1 && $vc[1]==0) $flipCv={2,3};

if ($vc[0]==2 && $vc[1]==3) $flipCv={1,0};
if ($vc[0]==3 && $vc[1]==2) $flipCv={0,1};

if ($vc[0]==1 && $vc[1]==2) $flipCv={0,3};
if ($vc[0]==2 && $vc[1]==1) $flipCv={3,0};

if ($vc[0]==0 && $vc[1]==3) $flipCv={1,2};
if ($vc[0]==3 && $vc[1]==0) $flipCv={2,1};
return $flipCv;
}

global proc asCopySkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinCage`)
	return;
string $sel[]=`ls -sl`;
int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 skinCage`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r skinCage ;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc asWrapExlude ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

string $sel[]=`ls -sl`;
if (!size($sel))
	error "No vertices selected ";
if (!`gmatch $sel[0] "*[.]vtx[[]*"`)
	error "Selection must be  vertices";
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
string $wrapDeformer,$skinCluster;
int $hadSkinCluster=0;
for ($y=0;$y<size($tempString);$y++)
	{
	if (`nodeType $tempString[$y]` == "wrap")
		$wrapDeformer=$tempString[$y];
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
	}
if ($wrapDeformer=="")
	error "No wrap deformer on selected object";

if ($skinCluster=="")
	{
	asCopySkin;
	$tempString=`ls -sl -o`;
	$tempString=`listRelatives -p $tempString[0]`;
	select $tempString[0];
	asSmoothSkin;
	select $sel;
	}
else
	$hadSkinCluster=1;
$tempString=`listHistory -pdo 1 $sel[0]`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
$tempString=`listConnections ($wrapDeformer+".message")`;
string $wrapSet=$tempString[0];
$tempString=`listConnections ($skinCluster+".message")`;
string $skinClusterSet=$tempString[0];
sets -rm $wrapSet;
InvertSelection;
sets -rm $skinClusterSet;
if (!$hadSkinCluster)
	{
	$tempString=`ls -sl -o`;
	select $tempString[0];
	removeUnusedInfluences;
	}
select $sel;
print ("// Selected vertices are now deformed by "+$skinCluster+" instead of wrapDeformer\n");
}

global proc asCreateSkinSub ()
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "\"skinCage\" not found, You must create a skinCage (option2) first.";
if (`objExists skinSub`)
	error "\"skinSub\" already exists.";
if (!`objExists Cages`)
	{
	createNode -n Cages transform;
	parent Cages "Geometry";
	}

createNode -n subWrapPolySmoothProxy polySmoothProxy;
polyCube -n skinSub  -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
parent skinSub Cages;
connectAttr skinCageShape.outMesh subWrapPolySmoothProxy.inputPolymesh;
connectAttr subWrapPolySmoothProxy.output skinSub.inMesh;
select skinSub;
createDisplayLayer -name SkinSub -number 1 -nr;
//setAttr SkinSub.shading 0;
setAttr SkinSub.displayType 2;
setAttr SkinSub.color 30;
setAttr SkinCage.displayType 1;
select $sel;
}

global proc asDeleteSkinSub ()
{
if (`objExists skinSub`)
	delete skinSub;
if (`objExists SkinSub`)
	delete SkinSub;
}

global proc asWrapSkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
if (!`objExists skinSub`)
	error "\"skinSub\" not found, you must create SubWrap first";
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	{
	string $historyNodes[]=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]` == "wrap")
			error ($sel[$i]+" already have wrapDeformer");
	}

if (!`attributeExists wrapDeform Main`)
	{
	addAttr -k 1 -ln "wrapDeform" -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.wrapDeform;
	}
if (!`objExists wrapDeformReverse`)
	{
	createNode -n wrapDeformReverse reverse;
	connectAttr Main.wrapDeform wrapDeformReverse.inputX;
	}
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	select -add skinSub ;
	CreateWrap;
	}
string $wraps[]=`listConnections -type wrap skinSub.worldMesh`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
float $wrapValues[]={0,0,1,0,0};
string $wrap;

for ($i=0;$i<size($wraps);$i++)
	{
	$wrap=`rename $wraps[$i] ("subWrap"+($i+1))`;
	$tempString=`listConnections ($wrap+".outputGeometry")`;
	setAttr ($wrap+".nodeState") 1;
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (`attributeExists $wrapAttrs[$y] $tempString[0]`) //We could be reattaching, so reuse wrapInfo
			$wrapValues[$y]=`getAttr ($tempString[0]+"."+$wrapAttrs[$y])`;
		setAttr ($wrap+"."+$wrapAttrs[$y]) $wrapValues[$y];
		}
	setAttr skinSub.dropoff 4;
	setAttr skinSub.smoothness 0;
	setAttr skinSub.inflType 2;
	connectAttr wrapDeformReverse.output.outputX ($wrap+".nodeState");
	}
select -cl;
}

global proc asSkinSubAttach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinSub`) error "\"skinSub\" not found, you must create SubWrap first";
if (!`objExists skinCage`) error "\"skinCage\" not found, you must create SubWrap first";
if (!`attributeExists subWrapped skinCage`) error "No SubWraps have been detached";
int $numAttach;
string $msh;
string $tempString[];
$tempString[0]=`getAttr skinCage.subWrapped`;
tokenize $tempString[0] ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	$msh=$tempString[$i];
	if (!`objExists $msh`)
		continue;
	select $msh;
	asWrapSkin;
	$numAttach++;
	}
print ("//"+$numAttach+" SubWrap(s) attached");
}

global proc asSkinSubDetach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $subWraps[]=`ls -type wrap "subWrap*"`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
string $tempString[],$tempString2[];
string $msh,$subWrappedString;
for ($i=0;$i<size($subWraps);$i++)
	{
	//store wrapInfo on the meshes they deform.
	$tempString=`listHistory -f 1 ($subWraps[$i]+".outputGeometry")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="mesh")
			{
			$tempString2=`listRelatives -p $tempString[$y]`;
			$msh=$tempString2[0];
			}
	$subWrappedString+=$msh+";";
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (!`attributeExists $wrapAttrs[$y] $msh`) addAttr -ln $wrapAttrs[$y] -at double $msh;
		setAttr ($msh+"."+$wrapAttrs[$y]) `getAttr ($subWraps[$i]+"."+$wrapAttrs[$y])`;
		}
	delete $subWraps;
	print ("//"+`size($subWraps)`+" SubWrap(s) detached");
	}
if (!`attributeExists subWrapped skinCage`)
	addAttr -ln "subWrapped" -dt "string" skinCage;
setAttr -type "string" skinCage.subWrapped $subWrappedString;
}

global proc asSmoothSkin ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
float $pos[];
string $tempString[];
string $smoothJoints[];
if (`objExists Head_M`)
	{
	$tempString=`listRelatives -p Head_M`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$smoothJoints[size($smoothJoints)]=$parent;
		$tempString=`listRelatives -p $parent`;
		$parent=$tempString[0];
		}
	}
string $lookforJoints[]={"Root_M","Hip_R","Hip_L"};
for ($i=0;$i<size($lookforJoints);$i++)
if (`objExists $lookforJoints[$i]`)
	$smoothJoints[size($smoothJoints)]=$lookforJoints[$i];
string $skinCluster;
setToolTo $gSelect;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]` == "skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		error "Found no skinCluster on selected object";
	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Finding Vtx for smoothing" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		for ($z=0;$z<size($smoothJoints);$z++)
			{
			if (`progressBar -q -ic $gMainProgressBar`)
				{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
			if ($z==0)
				progressBar -e -s 1 $gMainProgressBar;
			$tempString=`skinPercent -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
			if (`stringArrayCount $smoothJoints[$z] $tempString`)
				{
				select -add ($sel[$i]+".vtx["+$y+"]");
				//middleVtx to root
				if (`gmatch $smoothJoints[$z] "*Root_M*"` || `gmatch $smoothJoints[$z] "*Hip_*"`)
					{
					$pos=`xform -q -ws -t ($sel[$i]+".vtx["+$y+"]")`;
					if ($pos[0]>($charHeight/-5000.0) && $pos[0]<($charHeight/5000.0))
						skinPercent -tv $smoothJoints[$z] 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
					}
				}
			}
		if (size(`ls -sl`))
			weightHammerVerts;
	}
progressBar -e -ep $gMainProgressBar;
}

global proc asDeleteSkinCurves ()
{
if (!`objExists skinCageShape` || !`objExists skinClusterSkinCage`)
	return;
setAttr skinClusterSkinCage.envelope 0;
duplicate -n asTempMesh skinCageShape;
setAttr skinClusterSkinCage.envelope 1;
string $deleteObjs[]={"SkinCurves1","SkinCurves2","MeshGeometry","MeshCurves","NurbsGeometry"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
string $tempString[]=`listRelatives -s -type mesh skinCage`;
for ($mesh in $tempString)
	if ($mesh!="skinCageShape")
		{
		connectAttr asTempMesh.outMesh ($mesh+".inMesh");
		evalDeferred -lp ("delete asTempMesh");
		break;
		}
}

global proc string asNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";if ($nr==1) $letter="A";if ($nr==2) $letter="B";
if ($nr==3) $letter="C";if ($nr==4) $letter="D";if ($nr==5) $letter="E";
if ($nr==6) $letter="F";if ($nr==7) $letter="G";if ($nr==8) $letter="H";
if ($nr==9) $letter="I";if ($nr==10) $letter="J";if ($nr==11) $letter="K";
if ($nr==12) $letter="L";if ($nr==13) $letter="M";if ($nr==14) $letter="N";
if ($nr==15) $letter="O";if ($nr==16) $letter="P";if ($nr==17) $letter="Q";
if ($nr==18) $letter="R";if ($nr==19) $letter="S";if ($nr==20) $letter="T";
if ($nr==21) $letter="U";if ($nr==22) $letter="V";if ($nr==23) $letter="W";
if ($nr==24) $letter="X";if ($nr==25) $letter="Y";if ($nr==26) $letter="Z";
return $letter;
}

global proc asAlign (string $object, string $alignToObject, int $translate, int $rotate, int $jointOrient, int $rotateOrder)
{
string $parents[]=`listRelatives -p $object`;
string $orientConstraint[];
float $rotation[];
parent $object $alignToObject;
//Might have generated a Xform
string $generatedXform;
string $tempString[]=`listRelatives -p $object`;
if ($tempString[0]!=$alignToObject)
	$generatedXform=$tempString[0];
if ($translate)
	{
	xform -os -t 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -t 0 0 0 $generatedXform;
	}
if ($rotateOrder)
	setAttr ($object+".rotateOrder") `getAttr ($alignToObject+".rotateOrder")`;
if ($rotate)
	{
	xform -os -ro 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -ro 0 0 0 $generatedXform;
	}
if (`objExists $parents[0]`)
	parent $object $parents[0];
else
	parent -w $object;
if ($jointOrient)
	{
	$orientConstraint=`orientConstraint $alignToObject $object`;
	$rotation=`xform -q -os -ro $object`;
	delete $orientConstraint[0];
	setAttr -type float3 ($object+".jointOrient") $rotation[0] $rotation[1] $rotation[2];
	setAttr -type float3 ($object+".rotate") 0 0 0;
	}
}

global proc asImportIconsFile (string $iconsFile)
{
string $beforeObj[]=`ls -l -as`;
string $afterObj[];
int $fromBefore[];
int $readLine;
$fileId=`fopen $iconsFile "r"`;
string $nextLine = `fgetline $fileId`;
string $previousLine;
while ( size( $nextLine ) > 0 )
	{
	if (!$readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
	if (`gmatch $nextLine "createNode nurbsCurve*"`)
		{
		$readLine=1;
		eval ($previousLine);
		$previousLine = $nextLine;
		$nextLine = `fgetline $fileId`;
		continue;
		}
	if ($readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
		else
			{
			$readLine=0;
			eval ($previousLine);
			}
	$previousLine=$nextLine;
	$nextLine = `fgetline $fileId`;
	}
fclose $fileId;
$afterObj=`ls -l -as`;
for ($i=0;$i<size($afterObj);$i++)
	for ($y=0;$y<size($beforeObj);$y++)
		if ($afterObj[$i]==$beforeObj[$y])
			$fromBefore[$i]=1;
for ($i=0;$i<size($afterObj);$i++)
	if (!$fromBefore[$i])
		parent $afterObj[$i] "iconsGroup";
}

global proc asCreateController (string $type, string $name, string $side, string $fitJoint)
{
string $sel[]=`ls -sl`;
select -cl;
int $rotOrder=`getAttr ($fitJoint+".rotateOrder")`;
if ($type=="FK")
	joint -n ($type+"Offset"+$name+$side);
else
	{
	createNode -n ($type+"Offset"+$name+$side) transform;
	parent ($type+"Offset"+$name+$side) "IKHandle";
	}
setAttr ($type+"Offset"+$name+$side+".rotateOrder") $rotOrder;
createNode -n ($type+"Extra"+$name+$side) transform;
sets -add ControlSet ($type+"Extra"+$name+$side);
setAttr ($type+"Extra"+$name+$side+".rotateOrder") $rotOrder;
parent ($type+"Extra"+$name+$side) ($type+"Offset"+$name+$side);
asLockAttr ($type+"Extra"+$name+$side) 0 0 1 1;
if (`gmatch $name "*Scapula*"`)
	duplicate -n ($type+$name+$side) "Scapula_icon";
else
	duplicate -n ($type+$name+$side) ($type+"_icon");
xform -os -t 0 0 0 -ro 0 0 0 ($type+$name+$side);
setAttr ($type+$name+$side+".rotateOrder") $rotOrder;

if ($side=="_L")
	setAttr -type float3 ($type+$name+$side+".s") -1 -1 -1;

float $height=`getAttr "Main.height"`;
float $fitSkeletonScaleX=`getAttr FitSkeleton.sx`;
float $defaultCtrlScale=$height/30.0;
float $sca[3]={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
$tempString=`listRelatives -c -type joint $fitJoint`;
if ($tempString[0]!="")
	{
	float $pos1[]=`xform -q -ws -t $fitJoint`;
	float $pos2[]=`xform -q -ws -t $tempString[0]`;
	float $boneLenght=`mag<<$pos2[0]-$pos1[0],$pos2[1]-$pos1[1],$pos2[2]-$pos1[2]>>`;
	if ($boneLenght>1)
		$boneLenght=$boneLenght/2.0;
	else
		$boneLenght=$boneLenght+((1-$boneLenght)/2.0);
	$defaultCtrlScale=$defaultCtrlScale*$boneLenght;
	$sca={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
	}

if (`attributeExists fat $fitJoint` && `attributeExists fatY $fitJoint` && `attributeExists fatZ $fitJoint`)
	{
	float $fat=`getAttr ($fitJoint+$side+".fat")`;
	float $fatY=`getAttr ($fitJoint+$side+".fatY")`;
	float $fatZ=`getAttr ($fitJoint+$side+".fatZ")`;
	$sca={$defaultCtrlScale,$fat*$fatY*$fitSkeletonScaleX,$fat*$fatZ*$fitSkeletonScaleX};
	}

string $shapes[]=`listRelatives -s ($type+$name+$side)`;
for ($i=0;$i<size($shapes);$i++)
	{
	xform -s $sca[1] $sca[1] $sca[1] ($shapes[$i]+".cv[0:99]");
	xform -s 1.5 1.5 1.5 ($shapes[$i]+".cv[0:99]");
	}
makeIdentity -a 1 -t 1 -r 1 -s 1 ($type+$name+$side);

parent ($type+$name+$side) ($type+"Extra"+$name+$side);

float $pos[]=`xform -q -ws -t ($fitJoint+$side)`;
float $rot[]=`xform -q -ws -ro ($fitJoint+$side)`;
//float $b=1;
//if ($side=="_L")
//	$b=-1;
xform -ws -t $pos[0] $pos[1] $pos[2] ($type+"Offset"+$name+$side);
if ($type=="FK")
	xform -ws -ro $rot[0] $rot[1] $rot[2] ($type+"Offset"+$name+$side);
select $sel;
}

global proc asCreateUnTwister (string $fitJoint, string $side, string $twistParent, string $twistParentSide, string $fitJointIK, int $b, int $IkUnTwister, string $ikFollow)
{
float $scale=`getAttr FitSkeleton.sx`;
if (`objExists ("TwistFollow"+$fitJoint+$side)`)
	return;
string $tempString[];
string $parentIK;
//find $parentIK
if (`objExists ($twistParent+$twistParentSide)`)
	{
	string $iKInfo[]=`asFitJointIKInfo $twistParent`;
	$parentIK=$iKInfo[0];
	}

createNode -n ("TwistFollow"+$fitJoint+$side) -p TwistSystem transform;
createNode -n ("TwistFollowParent"+$fitJoint+$side) -p TwistSystem transform;
asAlign ("TwistFollow"+$fitJoint+$side) ($fitJoint+$side) 1 1 0 1;
setAttr -l 1 ("TwistFollow"+$fitJoint+$side+".v") 0;
setAttr -l 1 ("TwistFollowParent"+$fitJoint+$side+".v") 0;


if ($IkUnTwister)
	{
	parentConstraint ($ikFollow+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		parentConstraint ("IKX"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);;
	}
else
	{
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		asConstraintToFKIK "parent" $parentIK ("FKX"+$twistParent+$twistParentSide) ("IKX"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
	}

if (!`objExists ($twistParent+$twistParentSide)`)
	parentConstraint RootX_M ("TwistFollowParent"+$fitJoint+$side);	
//Makes FKIK mixing less flippy, but `might` cause cycle
//		parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);
//setAttr ("TwistFollow"+$fitJoint+$side+"_parentConstraint1.interpType") 2;

//stabalize constraint by adding offsetNode
createNode -n ("TwistFollowOffset"+$fitJoint+$side) -p ("TwistFollow"+$fitJoint+$side) transform;
createNode -n ("TwistFollowParentOffset"+$fitJoint+$side) -p ("TwistFollowParent"+$fitJoint+$side) transform;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".r") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".r") 0 0 0;
parent ("TwistFollowOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollowParentOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowOffset"+$fitJoint+$side);
parent ("TwistFollowParent"+$fitJoint+$side) ("TwistFollowParentOffset"+$fitJoint+$side);

select ($fitJoint+$side);
joint -n ("UnTwist"+$fitJoint+$side);
joint -n ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwist"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);

if ($IkUnTwister)
	pointConstraint ($ikFollow+$side) ("UnTwist"+$fitJoint+$side);
else
	asConstraintToFKIK "point" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX"+$fitJoint+$side) ("UnTwist"+$fitJoint+$side);

setAttr ("UnTwistEnd"+$fitJoint+$side+".translateX") ($b*$scale);
ikHandle -n ("UnTwistIK"+$fitJoint+$side) -ns 2 -sol "ikRPsolver" -sj ("UnTwist"+$fitJoint+$side) -ee ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwistIK"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
poleVectorConstraint ("UnTwist"+$fitJoint+$side) ("UnTwistIK"+$fitJoint+$side);

select ("UnTwist"+$fitJoint+$side);
joint -n ("TwistBalancer"+$fitJoint+$side);
setAttr ("TwistBalancer"+$fitJoint+$side+".rotateOrder") 5;
if ($IkUnTwister)
	parentConstraint ($ikFollow+$side) ("TwistBalancer"+$fitJoint+$side);
else
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX"+$fitJoint+$side) ("TwistBalancer"+$fitJoint+$side);
//setAttr ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1.interpType") 2;
}

global proc asFollow (string $driver, string $driven, string $target)
{
if (!`objExists $target`)
	return;
string $setRange=$driver+"SetRangeFollow";
if (!`attributeExists "follow" $driver`)
	{
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 0 $driver;
	createNode -n $setRange setRange;
	setAttr ($setRange+".maxX") 1;
	setAttr ($setRange+".minY") 1;
	setAttr ($setRange+".oldMaxX") 10;
	setAttr ($setRange+".oldMaxY") 10;
	connectAttr ($driver+".follow") ($setRange+".value.valueX");
	connectAttr ($driver+".follow") ($setRange+".value.valueY");
	}
float $temp[]=`xform -q -ws -t $driven`;
createNode -n ($driven+"Static") transform;
asAlign ($driven+"Static") $driven 1 1 0 0;
parent ($driven+"Static") ("IKStatic");
string $tempString[]=`parentConstraint -mo ($driven+"Static") $target $driven`;
string $constraint=$tempString[0];
select $constraint;
connectAttr ($setRange+".outValue.outValueY") ($constraint+"."+$driven+"Static"+"W0");
connectAttr($setRange+".outValue.outValueX") ($constraint+"."+$target+"W1");
}

global proc asConstraintToFKIK (string $type, string $fitJointIK, string $fk, string $ik, string $target)
{
string $contraintCmd="pointConstraint ";
if ($type=="orient")
	$contraintCmd="orientConstraint ";
if ($type=="parent")
	$contraintCmd="parentConstraint ";
if ($type=="scale")
	$contraintCmd="scaleConstraint ";
$contraintCmd+=$fk;
if (`objExists $ik`)
	$contraintCmd+=" "+$ik;
$contraintCmd+=" "+$target;
string $tempString[];
tokenize $target "_" $tempString;
string $side="_"+$tempString[size($tempString)-1];
$tempString=`eval ($contraintCmd)`;
string $constraint=$tempString[0];
if (`objExists $ik` && `objExists ("FKIKBlend"+$fitJointIK+"Reverse"+$side)`)
	{
	connectAttr ("FKIKBlend"+$fitJointIK+"Reverse"+$side+".outputX") ($constraint+"."+$fk+"W0");
	connectAttr ("FKIKBlend"+$fitJointIK+"UnitConversion"+$side+".output") ($constraint+"."+$ik+"W1");
	}
//if ($type=="orient" || $type=="parent")
//	setAttr ($constraint+".interpType") 2;
}

global proc asRemoveAllUnusedInfluences ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
	{
	$tempString=`listHistory $meshes[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			select `listRelatives -p $meshes[$i]`;
			removeUnusedInfluences;
			}
	}
select $sel;
}

global proc asPrunAllClusters ()
{
string $sel[]=`ls -sl`;
string $clusters[]=`ls -type cluster`;
for ($i=0;$i<size($clusters);$i++)
	{
	select $clusters[$i];
	PruneCluster;
	}
select $sel;
}

global proc freezeSkinCluster (string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
int $numMatrix;
float $jointMatrix[];
string $tempString[]=`ls -showType $skinCluster`;

$numMatrix=`getAttr -s ($skinCluster+".bindPreMatrix")`;
for ($i=0;$i<$numMatrix;$i++)
	{
	$tempString=`listConnections -s 1 -d 1 ($skinCluster+".matrix["+$i+"]")`;
	if (!`objExists $tempString[0]`)
		continue;
	$jointMatrix=`getAttr ($tempString[0]+".worldInverseMatrix")`;
	setAttr ($skinCluster+".bindPreMatrix["+$i+"]") -type "matrix" $jointMatrix[0] $jointMatrix[1] $jointMatrix[2] $jointMatrix[3] $jointMatrix[4] $jointMatrix[5] $jointMatrix[6] $jointMatrix[7] $jointMatrix[8] $jointMatrix[9] $jointMatrix[10] $jointMatrix[11] $jointMatrix[12] $jointMatrix[13] $jointMatrix[14] $jointMatrix[15];
	}
}

global proc asPublish ()
{
string $sceneName=`file -q -sn`;
if ($sceneName=="")
	error "File not saved, can not publish";
string $tempString[];
string $filePath,$publishFile;
string $basename=`basenameEx $sceneName`;
tokenize $sceneName "/" $tempString;
for ($i=0;$i<size($tempString)-1;$i++)
	$filePath+=$tempString[$i]+"/";
if (`gmatch $sceneName "*[.]mb"`)
	{
	print "// Your working file is already MB format, appending \"_Published\" to the name.\n";
	$publishFile=$filePath+$basename+"_Published.mb";
	}
else
	$publishFile=$filePath+$basename+".mb";
if (`file -q -ex $publishFile`)
	{
	print ("// Publish file already exits, performing incrementalSave for backup.\n");
	file -rename $publishFile;
	incrementalSaveScene;
	file -rename $sceneName;
	}

//string $references[]=`file -q -r`;
//for ($i=0;$i<size($references);$i++)
//	file -importReference $references[$i];
file -f -op "v=0" -typ "mayaBinary" -ea $publishFile;

print ("// Published: \""+$publishFile+"\".\n");
}

global proc asReBuildAdvancedSkeleton ()
{
global int $asBuilding;
global int $asRebuilding;
global string $gMainProgressBar;

if (!`asConfirmIfNotInBuildPose`)
	return;

if (!`objExists "Group"`)
	{
	$asBuilding=1;
	asBuildAdvancedSkeleton;//First build
	if (`checkBox -q -ex asRebuildConnections`)
		checkBox -e -m 1 asRebuildConnections;
	if (`button -q -ex asToggleFitSkeletonButton`)
		button -e -m 1 asToggleFitSkeletonButton;
	if (`button -q -ex asBuildAdvancedSkeletonButton`)
		button -e -l "ReBuild AdvancedSkeleton" asBuildAdvancedSkeletonButton;
	$asBuilding=0;
	return;
	}
if (`objExists "prefix_Group"`)
	error "Object \"prefix_Group\" found, which means a previous build failed. Try to Undo previous build, to restore functional AdvancedSkeleton";

if (`objExists "Group"` && `objExists FitSkeleton`)
	if (!`getAttr FitSkeleton.visibility`)
		asToggleFitAdvancedSkeleton;

string $allSet="AllSet";
string $controlSet="ControlSet";
string $allSetMembers[]=`sets -q $allSet`;

int $rebuildConnections=`checkBox -q -v asRebuildConnections`;
string $tempString[],$tempString2[],$sources[],$destinations[],$sourcesNoPlug[],$destinationsNoPlug[];
string $roots[];

if (!`objExists FitSkeleton`)
	error "No skeleton to rebuild\n";
parent -w FitSkeleton;

progressBar -e -st "Analyzing AdvancedSkeleton" -bp -ii 0 -min 0 -max (size($allSetMembers)*2) $gMainProgressBar;

//Pre Rebuild
float $mx[];
string $userAttrs[],$children[],$connections[],$connectionsObj[],$connectCmdsSource[],$connectCmdsDest[];
string $addAttrCmds[],$cmds[],$connectCmds[],$skinClusters[],$jointClusters[];
string $sn,$ln,$at,$k,$cb,$dv,$minMax,$skinCluster;
string $charSet,$objectType,$tr,$xyz,$target;
int $childIsMember,$alreadyConnected;
int $locked;
int $e[2];
float $range[2];
float $vals[2];

if (`objExists FaceAllSet`)
	if (`sets -im "Sets" FaceAllSet`)
		sets -rm "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	if (`sets -im "Sets" FaceControlSet`)
		sets -rm "Sets" FaceControlSet;


//Pre Rebuild parentConstraints
string $constraintParent,$constraintChild;
string $parentConstraints[]=`ls -type parentConstraint`;
string $parentConstraintParents[],$parentConstraintChildren[];
for ($i=$y=0;$i<size($parentConstraints);$i++)
	{
	if (`sets -im $allSet $parentConstraints[$i]` || `gmatch $parentConstraints[$i] "*Box_*"`)
			continue;

	$tempString=`listConnections ($parentConstraints[$i]+".target[0].targetJointOrient")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintParent=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	$tempString=`listConnections ($parentConstraints[$i]+".constraintTranslate.constraintTranslateX")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintChild=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	if (!`objExists $constraintParent` || !`objExists $constraintChild`)
		continue;
	if (!`sets -im $allSet $constraintParent` && !`sets -im $allSet $constraintChild`)
		continue;

	$parentConstraintParents[$y]=$constraintParent;
	$parentConstraintChildren[$y]=$constraintChild;
	delete $parentConstraints[$i];
	$y++;
	}

//Pre Rebuild userDefinedAttr
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	$userAttrs=`listAttr -ud $allSetMembers[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$tempString=`listAttr -sn ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		if (`gmatch $at "*Array"` || $at=="message")
			continue;
		$dv=`getAttr ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$k=`getAttr -k ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$cb=`getAttr -cb ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="string")
			continue;
		if (`gmatch $ln "*W[0-9]"`)
			continue;
		$minMax="";
		if (`attributeQuery -re -n $allSetMembers[$i] $ln`)
			{
			$range=`attributeQuery -r -n $allSetMembers[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	addAttr -k "+$k+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$allSetMembers[$i]+";";
		//Non-keyable
		if ($k=="0" && $cb)
			$addAttrCmds[size($addAttrCmds)]="if (`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	setAttr -cb 1 "+$allSetMembers[$i]+"."+$userAttrs[$y]+";";
		}
	}


//Pre Rebuild Parenting
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	if (`objectType $allSetMembers[$i]`=="objectSet")
		continue;
	$children=`listRelatives -c $allSetMembers[$i]`;
	for ($y=0;$y<size($children);$y++)
		{
		$tempString=`ls $children[$y]`;
		if (size($tempString)>1)
			error ("ObjectName not unique "+$children[$y]+"\n");
		$childIsMember=0;
		for ($z=0;$z<size($allSetMembers);$z++)
			if ($children[$y]==$allSetMembers[$z])
				$childIsMember=1;
		if (!$childIsMember)
			{
			$tempString=`ls -s $children[$y]`;
			if ($tempString[0]!="")
				$cmds[size($cmds)]="parent -r -s "+$children[$y]+" "+$allSetMembers[$i]+";";
			else if (`getAttr ($children[$y]+".inheritsTransform")` && !`gmatch $children[$y] "*_?_[0-9][0-9]"`)
				$cmds[size($cmds)]="parent "+$children[$y]+" "+$allSetMembers[$i]+";";
			else
				$cmds[size($cmds)]="parent -r "+$children[$y]+" "+$allSetMembers[$i]+";";
			}
		}
	if (!$rebuildConnections)
		continue;

	//Incoming connections
	$connections=`listConnections -p 1 -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		if ($connections[$y+1]=="Group.message")
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver" || $objectType== "displayLayerManager")
			continue;
		if ($connections[$y+1]=="time1.outTime")
			continue;
		$connectCmds[size($connectCmds)]="if (`getAttr -l "+$connections[$y]+"`)  setAttr -l 0 "+$connections[$y]+";connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y+1];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y];
		}

	//Outgoing connections
	$connections=`listConnections -p 1 -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="materialInfo" || $objectType=="partition")
			continue;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
			continue;
		if (`gmatch $connections[$y] "*instObjGroups*"` || `gmatch $connections[$y+1] "*instObjGroups*"`)
			continue;
		if ($objectType=="skinCluster")
			$skinClusters[size($skinClusters)]=$connectionsObj[$y+1];
		if ($objectType=="jointCluster")
			$jointClusters[size($jointClusters)]=$connectionsObj[$y+1];
		$connectCmds[size($connectCmds)]="connectAttr -f "+$connections[$y]+" "+$connections[$y+1]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y+1];
		}

	//transformLimits
	if (`objectType $allSetMembers[$i]`=="joint")
		{
		$tr="r";
		for ($y=0;$y<2;$y++)
			{
			if ($y==1)
				continue;
			$xyz="x";
			for ($z=0;$z<3;$z++)
				{
				if ($z==1)
					$xyz="y";
				if ($z==2)
					$xyz="z";
				$e=`eval ("transformLimits -q -e"+$tr+$xyz+" "+$allSetMembers[$i])`;
				if ($e[0] || $e[1])
					{
					$vals=`eval ("transformLimits -q -"+$tr+$xyz+" "+$allSetMembers[$i])`;
					$cmds[size($cmds)]="transformLimits -"+$tr+$xyz+" "+$vals[0]+" "+$vals[1]+" -e"+$tr+$xyz+" "+$e[0]+" "+$e[1]+" "+$allSetMembers[$i]+";";
					}
				}
			}
		}
	}

//Pre Rebuild CurveShapes
string $controlSetMembers[]=`sets -q $controlSet`;
//add HipSwingerOffset_M, so placement of this is maintained in ReBuild
if (`objExists "HipSwingerOffset_M"`)
	$controlSetMembers[size($controlSetMembers)]="HipSwingerOffset_M";
string $curveShape;
int $spans,$degree,$numCVs;
float $cvPos[3];
if ($rebuildConnections)
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		$tempString=`listRelatives -s $controlSetMembers[$i]`;
		$curveShape=$tempString[0];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
			$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
			}
		}

//Pre Rebuild Disable expressions to avoid warnings
$tempString=`ls -type expression`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im $allSet $tempString[$i]`)
		setAttr ($tempString[$i]+".nodeState") 1;

//Rebuild
$allSetMembers[size($allSetMembers)]="Group";
$allSetMembers[size($allSetMembers)]="Sets";
$allSetMembers[size($allSetMembers)]="AllSet";
$allSetMembers[size($allSetMembers)]="ControlSet";
$allSetMembers[size($allSetMembers)]="DeformSet";

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
	else
		$allSetMembers[$i]="";

//unprefix CylShapes inorde to preserve these
$tempString=`ls -type nurbsSurface "*_CylShape*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		rename $tempString[$i] `substitute "prefix_" $tempString[$i] ""`;


progressBar -e -ep $gMainProgressBar;


$asRebuilding=1;
asBuildAdvancedSkeleton;
$asRebuilding=0;


//redo parentConstraints
for ($i=0;$i<size($parentConstraintParents);$i++)
	if (`objExists $parentConstraintParents[$i]` && `objExists $parentConstraintChildren[$i]`)
		parentConstraint -mo $parentConstraintParents[$i] $parentConstraintChildren[$i];


//Post Rebuild
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
for ($i=0;$i<size($connectCmds);$i++)
	{
	$alreadyConnected=0;
	if (`objExists $connectCmdsSource[$i]` && `objExists $connectCmdsDest[$i]`)
		if (`isConnected -iuc $connectCmdsSource[$i] $connectCmdsDest[$i]`)
			$alreadyConnected=1;
	if (!$alreadyConnected)
		if (catchQuiet (`eval ($connectCmds[$i])`)) warning ("Failed: "+$connectCmds[$i]+"\n");
	}
for ($cmd in $cmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

//reset bindPose
string $bindPose;
string $newSetMembers[]=`sets -q $allSet`;
for ($i=0;$i<size($newSetMembers);$i++)
	{
	if (`objectType $newSetMembers[$i]`=="joint")
		{
		select $newSetMembers[$i];
		$tempString=`dagPose -q -bp`;
		$bindPose=$tempString[0];
		if (`objExists $bindPose`)
			{
			$tempString=`listConnections ($newSetMembers[$i]+".bindPose")`;
			if ($tempString[0]==$bindPose)
				{
				select -add $bindPose;
				dagPose -rs;
				}
			}
		}
	}


for ($i=0;$i<size($allSetMembers);$i++)
	if (`gmatch $allSetMembers[$i] "*CurveInfo*"`)
		if (`objExists $allSetMembers[$i]`)
			delete $allSetMembers[$i];
for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		catchQuiet (`delete $allSetMembers[$i]`);

$skinClusters=`stringArrayRemoveDuplicates $skinClusters`;
$jointClusters=`stringArrayRemoveDuplicates $jointClusters`;
for ($i=0;$i<size($skinClusters);$i++)
	freezeSkinCluster $skinClusters[$i];
for ($i=0;$i<size($jointClusters);$i++)
	freezeJointCluster $jointClusters[$i];

if (`objExists FaceAllSet`)
	sets -add "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	sets -add "Sets" FaceControlSet;

//if ($runCmd!="")
//	evalEcho $runCmd;

eval ("dgdirty -a");

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		delete $allSetMembers[$i];

select -cl;
}

global proc asBuildAdvancedSkeleton ()
{
global int $asRebuilding;
global string $asDSAltPivot;
global string $gSelect;
string $iconsFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asIcons.ma";

//FitSkeleton from basic joints
string $selJoints[]=`ls -sl -type joint`;
if (!`objExists FitSkeleton` && size($selJoints))
	{
	asCreateFitSkeleton;
	parent $selJoints[0] FitSkeleton;
	}

float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;

//preBuild check
if (!`objExists FitSkeleton`)
	error "FitSkeleton not found. You must import a FitSkeleton, or select a joint-chain.\n";
if (!`file -q -ex $iconsFile`)
	error ("File not found:"+$iconsFile);
if (!$asRebuilding)
	if (`objExists "Group"`)
		error "AdvancedSkeleton already exists, use ReBuild instead";
string $tempString[]=`listRelatives -c -type joint FitSkeleton`;
if ($tempString[0]=="")
	error "FitSkeleton has no joints parented to it";
float $firstJointPos[3]=`xform -q -ws -t $tempString[0]`;
if ($tempString[0]=="Root" && ($firstJointPos[0]>$sideTreshold || $firstJointPos[0]<(-1*$sideTreshold)))
	{//Existing Root but not centered, gets renamed, so new centered root gets generated
	rename Root RootSide;
	$tempString=`listRelatives -c -type joint FitSkeleton`;
	}
if ($tempString[0]!="Root")
	{
	if (`objExists "Root"`)
		error "The top-level joint must be named \"Root\", but another object in this scene is already called Root";
	if ($firstJointPos[0]<$sideTreshold && $firstJointPos[0]>(-1*$sideTreshold))
		rename $tempString[0] Root;
	else
		{
		select FitSkeleton;
		joint -n Root;
		xform -ws -t 0 $firstJointPos[1] $firstJointPos[2] Root;
		parent $tempString[0];
		}
	}
string $rootIKInfo[]=`asFitJointIKInfo Root`;
string $nonCenteredSpineJoints="";
if ($rootIKInfo[0]=="Spine")
	{
	string $rootIKJoints[]=`asGetIKJoints $rootIKInfo[1] $rootIKInfo[3]`;
	for ($i=0;$i<size($rootIKJoints);$i++)
		{
		float $rootIKJointPos[]=`xform -q -ws -t $rootIKJoints[$i]`;
		if ($rootIKJointPos[0]>$sideTreshold || $rootIKJointPos[0]<($sideTreshold*-1))
			$nonCenteredSpineJoints+="\""+$rootIKJoints[$i]+"\" ";
		}
	if ($nonCenteredSpineJoints!="")
		error ("These Spine joints are not in the center: "+$nonCenteredSpineJoints);
	}


setToolTo $gSelect;
asSetFixedWrapOptions;
int $numLetters,$centerBtwFeet;
int $fitJointTwistJoints[],$fitJointUpTwistJoints[],$fitJointBendyJoints[],$fitJointUpBendyJoints[],$fitJointBend[],$fitJointInbetweenJoints[],$fitJointRotOrder[];
int $fitJointIsEndJoint[],$ikLocal[],$isScapula[],$fitJointGlobal[],$fitJointsWheel[],$fitJointFirstAfterIK[],$fitJointNonDef[];
int $fitJointsAim[],$fitJointNoMirror[],$fitJointNoFlip[],$fitJointNoControl[];
int $isIKStart[],$isIKEnd[],$fitJointIKNumCtrls[];
float $pos[3],$pos2[3],$rot[3],$sca[3],$parentPos[3],$parentRot[3],$temp[3],$temp2[3],$temp3[3];
float $footRotX[],$ikLenght[],$fitJointGlobalValue[];
float $fitSkeletonScaleX=`getAttr FitSkeleton.sx`;
string $side,$childSide,$joint,$multipleDivide,$childLabel,$ankle,$heel,$toes,$toesEnd,$bigToe,$pinkyToe,$scapula,$label;
string $fitJointLabel[],$fitJointSide[],$fitJointParent[],$fitJointParentSide[],$fitJointChild[],$fitJointChildSide[],$fitJointsAttachTo[],$tempString2[];
string $asFitJointIKInfo[],$fitJointIK[],$fitJointIKStartJoint[],$fitJointIKMiddleJoint[],$fitJointIKEndJoint[],$fitJointIKSolver[],$IKJoints[],$userAttrs[];
string $allBefore[]=`ls`;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;

asFitModeManualUpdate; //Ensure joint rotations & jointOrientations
asOffFitMode;
for ($i=0;$i<size($fitJoints);$i++)
	asEnsureFitJointAttrs $fitJoints[$i];

if (`objExists FitSkeletonVisualizers`)
	{
	delete FitSkeletonVisualizers;
	asUpdateButtonEnables;
	}

createNode -n "iconsGroup" transform;
setAttr "iconsGroup.visibility" 0;
asImportIconsFile $iconsFile;

//--Sets--//
select -cl;
sets -name ControlSet;
sets -name DeformSet;
sets -name AllSet;
sets -name "Sets";
sets -add "Sets" AllSet ControlSet DeformSet;
sets -add ControlSet `listRelatives -c iconsGroup`;

createNode -n "Group" transform;
asLockAttr "Group" 1 1 1 0;
duplicate -n Main Main_icon;
parent Main "Group";
xform -s (0.285*$scale) (0.285*$scale) (0.285*$scale) Main.cv[0:7];
connectAttr -f FitSkeletonShape.worldSpace[0] MainShape.create;
refresh;
disconnectAttr FitSkeletonShape.worldSpace[0] MainShape.create;


//--3rd level transforms--//
parent FitSkeleton Main;
createNode -n MotionSystem transform;
createNode -n DeformationSystem transform;
if (!$asRebuilding || !`objExists Geometry`)
	{
	createNode -n Geometry transform;
	setAttr -l 1 Geometry.inheritsTransform 0;
	parent Geometry "Group";
	}
parent MotionSystem DeformationSystem Main;
setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v 0;
connectAttr -f MotionSystem.visibility MainShape.visibility;

//--4th level transforms--//
createNode -n FKSystem -p MotionSystem transform;
createNode -n IKSystem -p MotionSystem transform;
createNode -n FKIKSystem -p MotionSystem transform;
createNode -n BendSystem -p MotionSystem transform;
createNode -n AimSystem -p MotionSystem transform;
createNode -n RootSystem -p MotionSystem transform;
createNode -n TwistSystem -p MotionSystem transform;
createNode -n GlobalSystem -p MotionSystem transform;
createNode -n ConstraintSystem -p MotionSystem transform;
createNode -n DynamicSystem -p MotionSystem transform;	
setAttr BendSystem.inheritsTransform 0;

//--5th level transforms--//
createNode -n IKJoints -p IKSystem transform;
createNode -n IKHandle -p IKSystem transform;
createNode -n IKStatic -p IKSystem transform;
createNode -n IKCurve -p IKSystem transform;
setAttr IKCurve.inheritsTransform 0;
createNode -n IKMessure -p IKSystem transform;

//--6th level transforms--//
createNode -n IKRootConstraint -p IKHandle transform;

addAttr -k 1 -ln fkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkVis;
connectAttr -f Main.fkVis FKSystem.v;
addAttr -k 1 -ln ikVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.ikVis;
connectAttr -f Main.ikVis "IKSystem.v";
addAttr -k 1 -ln fkIkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkIkVis;
connectAttr -f Main.fkIkVis FKIKSystem.v;
addAttr -k 1 -ln aimVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimVis;
connectAttr -f Main.aimVis AimSystem.v;
addAttr -k 1 -ln aimFKVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimFKVis;
addAttr -k 1 -ln aimLRVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimLRVis;
addAttr -k 1 -ln fingerVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fingerVis;
addAttr -k 1 -ln bendVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.bendVis;
addAttr -k 1 -ln arrowVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.arrowVis;
addAttr -k 1 -ln drvSysVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.drvSysVis;

connectAttr -f Main.bendVis BendSystem.v;

if (`objExists jointLayer`)
	delete jointLayer;
createNode -n jointLayer displayLayer;
//setAttr jointLayer.displayType 2;

//Zero out endJoints
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`listRelatives -c -type joint $tempString[$y]`;
		if (size($tempString2)==0)
			{
			if (!`getAttr -l ($tempString[$y]+".rx")` && `getAttr -l ($tempString[$y]+".ry")` && `getAttr -l ($tempString[$y]+".rz")`)
				setAttr -type float3 ($tempString[$y]+".rotate") 0 0 0;
			setAttr -type float3 ($tempString[$y]+".jointOrient") 0 0 0;
			}
		}
	}

//Analyze
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists inbetweenJoints $fitJoints[$i]`)
		continue;
	int $inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	if ($inbetweenJoints<1)
		continue;
	$rlaChild=`asRlaChild $fitJoints[$i]`;
	if ($rlaChild=="")
		continue;
	select $fitJoints[$i];
	string $inbetweenJoint;
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		$inbetweenJoint=$fitJoints[$i]+"Part"+$y;
		joint -n $inbetweenJoint;
		setAttr ($inbetweenJoint+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
		float $weight=(1.0/($inbetweenJoints+1))*$y;
		$tempString=`pointConstraint -w $weight $rlaChild $inbetweenJoint`;
		pointConstraint -w (1-$weight) $fitJoints[$i] $inbetweenJoint;
		delete $tempString[0];
		addAttr -k 1 -ln tempInbetweener -at bool -dv 1 $inbetweenJoint;
		addAttr -k 1 -ln noControl -at bool -dv 1 $inbetweenJoint;
		float $fat=(`getAttr ($fitJoints[$i]+".fat")`*(1-$weight)) + (`getAttr ($rlaChild+".fat")`*$weight);
		float $fatY=(`getAttr ($fitJoints[$i]+".fatY")`*(1-$weight)) + (`getAttr ($rlaChild+".fatY")`*$weight);
		float $fatZ=(`getAttr ($fitJoints[$i]+".fatZ")`*(1-$weight)) + (`getAttr ($rlaChild+".fatZ")`*$weight);
		addAttr -k 0 -ln fat -at double -dv $fat $inbetweenJoint;
		addAttr -k 0 -ln fatY -at double -dv $fatY $inbetweenJoint;
		addAttr -k 0 -ln fatZ -at double -dv $fatZ $inbetweenJoint;
		}
	parent $rlaChild $inbetweenJoint;
	}
$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	//Analyze $fitJointLabel
	$fitJointLabel[$i]=`asLabel $fitJoints[$i]`;

	//Analyze $fitJointSide
	$fitJointSide[$i]="_R";
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
		$fitJointSide[$i]="_M";

	//Analyze $fitJointNoMirror & $fitJointNoFlip
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`attributeExists noMirror $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noMirror")`)
				$fitJointNoMirror[$i]=1;
		if (`attributeExists noFlip $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noFlip")`)
				$fitJointNoFlip[$i]=1;
		}


	//Analyze $fitJointNoControl
	if (`attributeExists noControl $fitJoints[$i]`)
		$fitJointNoControl[$i]=`getAttr ($fitJoints[$i]+".noControl")`;

	//Analyze $fitJointIsEndJoint
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($tempString[0]=="")
		$fitJointIsEndJoint[$i]=1;
	else
		$fitJointIsEndJoint[$i]=0;

	//Analyze rotateOrder
	$fitJointRotOrder[$i]=`getAttr ($fitJoints[$i]+".rotateOrder")`;

	//Analyze Parent
	$tempString=`listRelatives -p -type joint $fitJoints[$i]`;
	$fitJointParent[$i]=$tempString[0];

	//Analyze ParentSide
	if ($fitJointParent[$i]!="")
		{
		$fitJointParentSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointParent[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointParentSide[$i]="_M";
		}

	//Analyze Child
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	$fitJointChild[$i]=$tempString[0];
	//Prefer X-down child
	if (size($tempString)>1)
		for ($y=0;$y<size($tempString);$y++)
			{
			$temp=`getAttr ($tempString[$y]+".t")`;
			if ($temp[1]>-0.01 && $temp[1]<0.01 && $temp[2]>-0.01 && $temp[2]<0.01)
				{
				$fitJointChild[$i]=$tempString[$y];
				break;
				}
			}

	//Analyze ChildSide
	if ($fitJointChild[$i]!="")
		{
		$fitJointChildSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointChild[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointChildSide[$i]="_M";
		}

	//Analyze TwistJoints
	if (`attributeExists twistJoints $fitJoints[$i]`)
		$fitJointTwistJoints[$i]=`getAttr ($fitJoints[$i]+".twistJoints")`;
	
	//Analyze UpTwistJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists twistJoints $fitJointParent[$i]`)
			$fitJointUpTwistJoints[$i]=`getAttr ($fitJointParent[$i]+".twistJoints")`;

	//Analyze BendyJoints
	if (`attributeExists bendyJoints $fitJoints[$i]`)
		$fitJointBendyJoints[$i]=`getAttr ($fitJoints[$i]+".bendyJoints")`;

	//Analyze UpBendyJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists bendyJoints $fitJointParent[$i]`)
			$fitJointUpBendyJoints[$i]=`getAttr ($fitJointParent[$i]+".bendyJoints")`;

	//Analyze inbetweenJoints
	if (`attributeExists inbetweenJoints $fitJoints[$i]`)
		$fitJointInbetweenJoints[$i]=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;

	//Analyze global
	if (`attributeExists "global" $fitJoints[$i]`)
		{
		$fitJointGlobal[$i]=1;
		$fitJointGlobalValue[$i]=`getAttr ($fitJoints[$i]+".global")`;
		}

	//Analyze Aim
	if (`attributeExists aim $fitJoints[$i]`)
		$fitJointsAim[$i]=1;

	//Analyze Wheel
	if (`attributeExists geoAttach $fitJoints[$i]`)
		$fitJointsAttachTo[$i]=`getAttr -asString ($fitJoints[$i]+".geoAttach")`;

	//Analyze Wheel
	if (`attributeExists wheel $fitJoints[$i]`)
		$fitJointsWheel[$i]=1;

	//Analyze IK
	$asFitJointIKInfo=`asFitJointIKInfo $fitJoints[$i]`;
	$fitJointIK[$i]=$asFitJointIKInfo[0];
	$fitJointIKStartJoint[$i]=$asFitJointIKInfo[1];
	$fitJointIKMiddleJoint[$i]=$asFitJointIKInfo[2];
	$fitJointIKEndJoint[$i]=$asFitJointIKInfo[3];
	$fitJointIKSolver[$i]=$asFitJointIKInfo[4];
	if ($asFitJointIKInfo[5]!="")
		$fitJointIKNumCtrls[$i]=$asFitJointIKInfo[5];
	if ($fitJointIKStartJoint[$i]==$fitJoints[$i])
		$isIKStart[$i]=1;
	if ($fitJointIKEndJoint[$i]==$fitJoints[$i])
		$isIKEnd[$i]=1;

	//Analyze Non-deform joints
	if (`gmatch $fitJointLabel[$i] "*Heel*"` || `gmatch $fitJointLabel[$i] "*BigToe*"` || `gmatch $fitJointLabel[$i] "*PinkyToe*"`)
		$fitJointNonDef[$i]=1;	

	//Analyze $footRotX
	if (`gmatch $fitJointLabel[$i] "*Foot*"`)
		{
		createNode -n rotationSampler1 transform;
		createNode -n rotationSampler2 -p rotationSampler1 transform;
		setAttr -type float3 rotationSampler1.r 90 0 -90;
		setAttr rotationSampler2.rotateOrder `getAttr ($fitJoints[$i]+".rotateOrder")`;
		orientConstraint $fitJoints[$i] rotationSampler2;
		$footRotX[$i]=`getAttr rotationSampler2.rx`*-1;
		delete rotationSampler1;
		}

	//Analyze $ikLocal
	if (`attributeExists ikLocal $fitJoints[$i]`)
		$ikLocal[$i]=`getAttr ($fitJoints[$i]+".ikLocal")`;

	//Analyze FirstAfterIK
	if ($fitJointParent[$i]!="")
		{
		$asFitJointIKInfo=`asFitJointIKInfo $fitJointParent[$i]`;
		if ($fitJointIK[$i]!=$asFitJointIKInfo[0])
			$fitJointFirstAfterIK[$i]=1;
		}
	}

//Analyze $centerBtwFeet
if (`attributeExists centerBtwFeet Root`)
	$centerBtwFeet=`getAttr Root.centerBtwFeet`;

//Analyze $ikLenght
for ($i=0;$i<size($fitJoints);$i++)
	{
	$ikLenght[$i]=0;
	if ($fitJointIK[$i]=="")
		continue;
	$tempString[0]=$fitJointIKEndJoint[$i];
	for ($a=0;$a<99;$a++)
		{
		if ($tempString[0]==$fitJointIKStartJoint[$i])
			break;
		$ikLenght[$i]+=`getAttr ($tempString[0]+".tx")`;
		$tempString=`listRelatives -p $tempString[0]`;
		}
	$ikLenght[$i]=abs($ikLenght[$i]);
	}

//height
float $height,$lenght,$width,$maxFitJoint,$minFitJoint;
for ($a=0;$a<3;$a++)
	{
	$maxFitJoint=0;
	$minFitJoint=99;
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		if ($pos[$a]>$maxFitJoint)
			$maxFitJoint=$pos[$a];
		if ($pos[$a]<$minFitJoint)
			$minFitJoint=$pos[$a];
		}
	if ($a==0) $width=$maxFitJoint-$minFitJoint;
	if ($a==1) $height=$maxFitJoint-$minFitJoint;
	if ($a==2) $lenght=$maxFitJoint-$minFitJoint;
	}
addAttr -ln height -at double Main;
setAttr -l 1 Main.height $height;
//$iconScaleFactor
float $iconScaleFactor=$height;
if ($lenght>$height && $lenght>$width) $iconScaleFactor=$lenght;
if ($width>$height && $width>$lenght) $iconScaleFactor=$width;
$iconScaleFactor=$iconScaleFactor/80.0;

//--Creation--//
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		$pos=`xform -q -ws -t $fitJoints[$i]`;
		$rot=`xform -q -ws -ro $fitJoints[$i]`;
		$joint=$fitJoints[$i]+$side;

		//Creation Deform
		select -cl;
		joint -n $joint;
		sets -add DeformSet $joint;
		setAttr ($joint+".rotateOrder") $fitJointRotOrder[$i];
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $joint;
		xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fat")` -ln fat -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatY")` -ln fatY -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatZ")` -ln fatZ -at double $joint;

		if ($side=="_L")
			{
			$tempString=`mirrorJoint -mirrorYZ -mirrorBehavior $joint`;
			if ($fitJointNoFlip[$i])
				rotate -r -os 0 0 180 $tempString[0];
			$rot=`xform -q -ws -ro $tempString[0]`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
			delete $tempString[0];
			}

		//Creation TwistJoints
		select $joint;
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			joint -n ($fitJoints[$i]+"Part"+$y+$side);
			sets -add DeformSet ($fitJoints[$i]+"Part"+$y+$side);
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
			}			

		if ($isScapula[$i])
			addAttr -k 0 -ln Scapula -at bool -dv 1 $joint;

		if($fitJoints[$i]=="Root")
			connectAttr -f jointLayer.drawInfo Root_M.drawOverride;
		}

//Parent Deform
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		$parentJoint=$fitJointParent[$i]+$parentSide;
		if ($fitJointParent[$i]=="")
			parent $joint DeformationSystem;
		else
			parent $joint $parentJoint;
		}

//Parent TwistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointTwistJoints[$i]<1)
			continue;refresh;

		float $twistDistance=`getAttr ($fitJointChild[$i]+$childSide+".tx")`/($fitJointTwistJoints[$i]+1.0);
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".tx") $twistDistance;
		//reParent child to last twist
		if ($fitJointTwistJoints[$i]>0)
			parent ($fitJointChild[$i]+$childSide) ($fitJoints[$i]+"Part"+($fitJointTwistJoints[$i])+$side);
		}

//Freeze rotation(move to jointOrient)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		makeIdentity -a 1 -r 1 $joint;
		}

//Creation FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;


		asCreateController "FK" $fitJoints[$i] $side $fitJoints[$i];
//		setAttr ("FKExtra"+$fitJoints[$i]+$side+".overrideEnabled") 1;

		select ("FK"+$fitJoints[$i]+$side);
		joint -n ("FKX"+$fitJoints[$i]+$side);
		connectAttr -f jointLayer.drawInfo ("FKX"+$fitJoints[$i]+$side+".drawOverride");
		setAttr ("FKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$fitJoints[$i]+$side);

		if ($fitJointInbetweenJoints[$i])
			{
			parent ("FKX"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side);
			for ($y=0;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				$joint="FKX"+$fitJoints[$i]+"Part"+$y+$side;
				if ($y==0)
					{
					$joint="FKX"+$fitJoints[$i]+$side;
					connectAttr ("FK"+$fitJoints[$i]+$side+".t") ($joint+".t");
					}
				orientConstraint ("FK"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side) $joint;
				float $w=(1.0/($fitJointInbetweenJoints[$i]+1))*($y+1);
				setAttr ($joint+"_orientConstraint1.FK"+$fitJoints[$i]+$side+"W0") $w;
				setAttr ($joint+"_orientConstraint1.FKExtra"+$fitJoints[$i]+$side+"W1") (1-$w);
				}
			}

		if($fitJointGlobal[$i])
			{
			createNode -n ("FKGlobalStatic"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("FKGlobalStatic"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			duplicate -n ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			duplicate -n ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			duplicate -n ("GlobalOffset"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);

			parent ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			parent ("FKExtra"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
			parent ("Global"+$fitJoints[$i]+$side) ("GlobalOffset"+$fitJoints[$i]+$side);
			parent ("GlobalOffset"+$fitJoints[$i]+$side) GlobalSystem;

			orientConstraint ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
			addAttr -k 1 -ln "Global"-at double -min 0 -max 10 -dv $fitJointGlobalValue[$i] ("FK"+$fitJoints[$i]+$side);
			createNode -n ("globalReverse"+$fitJoints[$i]+$side) reverse;
			createNode -n ("globalUnitConversion"+$fitJoints[$i]+$side) unitConversion;
			setAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".conversionFactor") 0.1;
			connectAttr ("FK"+$fitJoints[$i]+$side+".Global") ("globalUnitConversion"+$fitJoints[$i]+$side+".input");
			connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("globalReverse"+$fitJoints[$i]+$side+".inputX");
			connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.Global"+$fitJoints[$i]+$side+"W0");
			connectAttr ("globalReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");
			}

		if ($isIKEnd[$i])
			{
			createNode -n ("AlignIKTo"+$fitJoints[$i]+$side) transform;
			setAttr ("AlignIKTo"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			parent ("AlignIKTo"+$fitJoints[$i]+$side) ("FKX"+$fitJoints[$i]+$side);
			setAttr -type float3 ("AlignIKTo"+$fitJoints[$i]+$side+".t") 0 0 0;
			}

		if ($fitJointNoControl[$i])
			{
			setAttr ("FK"+$fitJoints[$i]+$side+"Shape.v") 0;
			sets -rm ControlSet {("FK"+$fitJoints[$i]+$side),("FKExtra"+$fitJoints[$i]+$side)};
			}
		}

//Parenting FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		if ($fitJointParent[$i]=="")
			parent ("FKOffset"+$fitJoints[$i]+$side) FKSystem;

		else if ($fitJointFirstAfterIK[$i])
			{
			$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
			if (!`objExists $parentContraintToXform`)
				{
				createNode -n $parentContraintToXform -p FKSystem transform;
				//-mo as this prevents Ankle from flipping. nut this make scaleConstraint wrong
				asAlign $parentContraintToXform ($fitJointParent[$i]+$parentSide) 1 0 0 0;
//				parentConstraint -mo ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
				parentConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;

				if ($fitJointParent[$i]=="Wrist")
					connectAttr Main.fingerVis ($parentContraintToXform+".v");
				}
			parent ("FKOffset"+$fitJoints[$i]+$side) $parentContraintToXform;
			connectAttr -f jointLayer.drawInfo ("FKOffset"+$fitJoints[$i]+$side+".drawOverride");
	
			}
		else
			parent ("FKOffset"+$fitJoints[$i]+$side) ("FKX"+$fitJointParent[$i]+$parentSide);
		}

//FK segmentScaleCompensate
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		//fingers/toes to scale up with hand/foot, and anything below head
		if (`gmatch $fitJoints[$i] "*Finger*"` || `gmatch $fitJoints[$i] "*Cup*"` || `gmatch $fitJoints[$i] "*Toes*"` || $fitJointParent[$i]=="Head")
			{
			setAttr ($fitJoints[$i]+$side+".segmentScaleCompensate") 0;
			$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
			if (`objExists $parentContraintToXform`)
				scaleConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
			}
		}

//Creation IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;

		select -cl;
		joint -n ("IKX"+$fitJoints[$i]+$side);
		setAttr ("IKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
		if ($isIKStart[$i])
			{
			createNode -n ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			setAttr ("IKParentConstraint"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			createNode -n ("IKXOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("IKXOffset"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			parent ("IKX"+$fitJoints[$i]+$side) ("IKXOffset"+$fitJoints[$i]+$side);
			if (`objExists ($fitJointParent[$i]+$parentSide)`)
				{
				$parentPos=`xform -q -ws -t ($fitJointParent[$i]+$parentSide)`;
				$parentRot=`xform -q -ws -ro ($fitJointParent[$i]+$parentSide)`;
				xform -ws -t $parentPos[0] $parentPos[1] $parentPos[2] -ro $parentRot[0] $parentRot[1] $parentRot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
				if ($fitJointIKSolver[$i]!="ikSplineSolver")
					parentConstraint ($fitJointParent[$i]+$parentSide) ("IKParentConstraint"+$fitJoints[$i]+$side);
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKXOffset"+$fitJoints[$i]+$side);
				makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
				}
			else
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
			asAlign ("IKXOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 1 0 0;
			parent ("IKXOffset"+$fitJoints[$i]+$side) ("IKParentConstraint"+$fitJoints[$i]+$side);
			}
		else
			xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKX"+$fitJoints[$i]+$side);
		if ($isIKStart[$i] && $fitJointIKSolver[$i]=="ikRPsolver")
			{
			createNode -n ("IKMessureFrom"+$fitJoints[$i]+$side) -p ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			asAlign ("IKMessureFrom"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) 1 1 0 1;
			}
		if ($isIKStart[$i])
			connectAttr -f jointLayer.drawInfo ("IKX"+$fitJoints[$i]+$side+".drawOverride");
		}

//Parenting IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		if ($isIKStart[$i])
			parent ("IKParentConstraint"+$fitJoints[$i]+$side) IKJoints;
		else
			{
			parent ("IKX"+$fitJoints[$i]+$side) ("IKX"+$fitJointParent[$i]+$parentSide);
			makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
			}
		}

//Constraint to FK (&IK)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		parentConstraint ("FKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
		if ($fitJointIK[$i]!="")
			parentConstraint -w 0 ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
//		setAttr ($fitJoints[$i]+$side+"_parentConstraint1.interpType") 2;
		parent ($fitJoints[$i]+$side+"_parentConstraint1") ConstraintSystem;
		}



//Advanced Aim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointsAim[$i])
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;

		if (!`objExists ("Aim"+$fitJoints[$i])`)
			{
			createNode -n ("Aim"+$fitJoints[$i]) -p AimSystem transform;
			createNode -n ("AimOffset"+$fitJoints[$i]) -p ("Aim"+$fitJoints[$i]) transform;
			createNode -n ("AimFollow"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			createNode -n ("AimFollowOn"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			createNode -n ("AimFollowOff"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
			rename $tempString[0] ("Aim"+$fitJoints[$i]+"_M");
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideEnabled") 1;
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideColor") 17;
			sets -add ControlSet ("Aim"+$fitJoints[$i]+"_M");
			scale -r -p 0 0 0 ($scale/3.0) ($scale/3.0) ($scale/3.0) ("Aim"+$fitJoints[$i]+"_M.cv[0:4]");
			parent ("Aim"+$fitJoints[$i]+"_M") ("AimFollow"+$fitJoints[$i]);
			$pos=`xform -q -ws -t $fitJoints[$i]`;
			xform -ws -t 0 $pos[1] ($pos[2]+$scale*2) ("AimOffset"+$fitJoints[$i]);

			//.follow setup
			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 ("Aim"+$fitJoints[$i]+"_M");
			createNode -n ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M") unitConversion;
			setAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.conversionFactor") 0.1;
			connectAttr ("Aim"+$fitJoints[$i]+"_M.follow") ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.input");
			createNode -n ("Aim"+$fitJoints[$i]+"FollowReverse_M") reverse;
			connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("Aim"+$fitJoints[$i]+"FollowReverse_M.inputX");

			parentConstraint ("AimFollowOn"+$fitJoints[$i]) ("AimFollowOff"+$fitJoints[$i]) ("AimFollow"+$fitJoints[$i]);
			parentConstraint -mo ($fitJointParent[$i]+$fitJointParentSide[$i]) ("AimFollowOn"+$fitJoints[$i]);

			connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOn"+$fitJoints[$i]+"W0");
			connectAttr ("Aim"+$fitJoints[$i]+"FollowReverse_M.outputX") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOff"+$fitJoints[$i]+"W1");
			}
		
		if ($side!="_M")
			{
			createNode -n ("AimOffset"+$fitJoints[$i]+$side) -p ("Aim"+$fitJoints[$i]+"_M") transform;
			duplicate -n ("Aim"+$fitJoints[$i]+$side) ("Aim"+$fitJoints[$i]+"_M");
			$tempString=`listRelatives -c -f -type transform ("Aim"+$fitJoints[$i]+$side)`;
			if (`size ($tempString)`) delete $tempString;
			parent ("Aim"+$fitJoints[$i]+$side) ("AimOffset"+$fitJoints[$i]+$side);
			asLockAttr ("Aim"+$fitJoints[$i]+$side) 0 1 1 1;
			deleteAttr ("Aim"+$fitJoints[$i]+$side+".follow");
			setAttr -type float3 ("AimOffset"+$fitJoints[$i]+$side+".s") 0.2 0.2 0.2;
			asAlign ("AimOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 0 0 0;
			setAttr ("AimOffset"+$fitJoints[$i]+$side+".tz") 0;
			connectAttr Main.aimLRVis ("Aim"+$fitJoints[$i]+$side+"Shape.v");
			}
		createNode -n ("FKAim"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAim"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side) 1 1 0 1;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		parent ("FKAim"+$fitJoints[$i]+$side) $tempString[0];
		aimConstraint -aim 1 0 0 -upVector 0 0 -1 -worldUpVector 0 0 -1 -worldUpType "objectrotation" 
			-worldUpObject ($fitJointParent[$i]+$fitJointParentSide[$i]) ("Aim"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
		connectAttr Main.aimFKVis ("FK"+$fitJoints[$i]+$side+"Shape.v");
		}


//Advanced IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;

		//IKSp jointChain
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			createNode -n ("IKSp"+$fitJointIK[$i]+"Offset"+$side) -p IKJoints transform;
			asAlign ("IKSp"+$fitJointIK[$i]+"Offset"+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 1;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("FKX"+$fitJointIKStartJoint[$i]+$side) ($fitJointIKEndJoint[$i]+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side)`;
			select ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
			for ($y=0;$y<size($IKJoints);$y++)
				{
				joint -n ("IKSp"+$IKJoints[$y]+$side);
//				connectAttr ("IKSp"+$IKJoints[$y]+$side+".r") ("IKX"+$IKJoints[$y]+$side+".r");
//				parent ("IKSp"+$fitJointIK[$i]+$IKJoints[$y]+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
				}
			//distribute IKSp joints straight and evenly
			for ($y=0;$y<size($IKJoints);$y++)
				{
				float $posFactor=0;
				$posFactor=(1.0/(`size($IKJoints)`-1)*$y);
				pointConstraint -w (1-$posFactor) ($fitJointIKStartJoint[$i]+$side) ("IKSp"+$IKJoints[$y]+$side);
				pointConstraint -w $posFactor ($fitJointIKEndJoint[$i]+$side) ("IKSp"+$IKJoints[$y]+$side);
				delete ("IKSp"+$IKJoints[$y]+$side+"_pointConstraint1");
				}
			//parent IKSp joints
//			for ($y=1;$y<size($IKJoints)-1;$y++)
//				parent ("IKSp"+$IKJoints[$y+1]+$side) ("IKSp"+$IKJoints[$y]+$side);
			}

		//IKfake, first & last 2 joints in splineIK chain are `fake`, so that`real` can blend btw fake and ..AlignTo (for fixed end.rot in stretchy mode)
		//Also IKfake3 ensures correct twist distribution, as splikeIK twist assumes `end bone`
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			select ("IKSp"+$fitJointIKStartJoint[$i]+$side);
			joint -n ("IKfake0"+$fitJointIK[$i]+$side);
			setAttr -l 1 ("IKfake0"+$fitJointIK[$i]+$side+".v") 0;
			parent ("IKfake0"+$fitJointIK[$i]+$side) ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side);
			$tempString=`listRelatives -c ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
			parent $tempString[0] ("IKfake0"+$fitJointIK[$i]+$side);
			$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
			select $tempString[0];
//			select ("IKfake0"+$fitJointIK[$i]+$side);
			joint -n ("IKfake1"+$fitJointIK[$i]+$side);
			joint -n ("IKfake2"+$fitJointIK[$i]+$side);
			joint -n ("IKfake3"+$fitJointIK[$i]+$side);
			asAlign ("IKfake2"+$fitJointIK[$i]+$side) ("IKSp"+$fitJointIKEndJoint[$i]+$side) 1 1 1 0;
			$tempString=`listRelatives -p $tempString[0]`;
			parent ("IKfake1"+$fitJointIK[$i]+$side) $tempString[0];
			setAttr -l 1 ("IKfake1"+$fitJointIK[$i]+$side+".visibility") 0;
			setAttr ("IKfake3"+$fitJointIK[$i]+$side+".tx") `getAttr ("IKfake2"+$fitJointIK[$i]+$side+".tx")`;			
			}

		string $startJoint="IKX"+$fitJointIKStartJoint[$i]+$side;
		string $endJoint="IKX"+$fitJointIKEndJoint[$i]+$side;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			$startJoint="IKfake0"+$fitJointIK[$i]+$side;
			$endJoint="IKfake2"+$fitJointIK[$i]+$side;
			if (`objExists ("IKfake2"+$fitJointIK[$i]+$side)`)
				$endJoint="IKfake3"+$fitJointIK[$i]+$side;
			}
		joint -e -setPreferredAngles -children $startJoint;
		if (`objExists ("IKfake1"+$fitJointIK[$i]+$side)` && size($IKJoints)==2)
			{
			$tempString=`listRelatives -p ("IKfake1"+$fitJointIK[$i]+$side)`;
			if ($tempString[0]!="IKfake0"+$fitJointIK[$i]+$side)
				parent ("IKfake1"+$fitJointIK[$i]+$side) ("IKfake0"+$fitJointIK[$i]+$side);
			}
		$tempString=`ikHandle -n ("IK"+$fitJointIK[$i]+"Handle"+$side) -ccv 0 -ns 2 -sol $fitJointIKSolver[$i] -sj $startJoint -ee $endJoint`;
		rename $tempString[1] ("IK"+$fitJointIK[$i]+"Effector"+$side);
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Handle"+$side+".v") 0;
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Effector"+$side+".v") 0;
		setAttr ("IK"+$fitJointIK[$i]+"Effector"+$side+".rotateOrder") $fitJointRotOrder[$i];
		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//controller
			asCreateController "IK" $fitJointIK[$i] $side $fitJoints[$i];		
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+$side);
			//pole
			asCreateController "Pole" $fitJointIK[$i] $side $fitJoints[$i];	
			asLockAttr ("Pole"+$fitJointIK[$i]+$side) 0 1 1 1;
			//place poleVector
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
//			$startJointChildJoint=$tempString[0];
			createNode -n tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer2 -p tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer3 -p tempPoleVecPlacer2 transform;
			$tempString=`pointConstraint $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i] tempPoleVecPlacer1`;
			setAttr ($tempString[0]+"."+$fitJointIKStartJoint[$i]+"W0") `getAttr ($fitJointIKEndJoint[$i]+".tx")`;
			setAttr ($tempString[0]+"."+$fitJointIKEndJoint[$i]+"W1") `getAttr ($fitJointIKMiddleJoint[$i]+".tx")`;
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $fitJointIKStartJoint[$i] $fitJointIKMiddleJoint[$i] tempPoleVecPlacer2;
			setAttr tempPoleVecPlacer3.tx $ikLenght[$i];
			$temp=`xform -q -ws -t tempPoleVecPlacer3`;
			delete tempPoleVecPlacer1;
			xform -ws -t ($temp[0]*$b) $temp[1] $temp[2] ("PoleOffset"+$fitJointIK[$i]+$side);
			poleVectorConstraint ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side);
			$tempString[0]=`createNode annotationShape`;
			$tempString=`listRelatives -p $tempString[0]`;
			string $direction=`rename $tempString[0] ("PoleAnnotation"+$fitJointIK[$i]+$side)`;
			setAttr ($direction+"Shape.overrideEnabled") 1;
			setAttr ($direction+"Shape.overrideDisplayType") 2;
			connectAttr Main.arrowVis ($direction+".v");
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
			parent $direction ("IKX"+$fitJointIKMiddleJoint[$i]+$side);
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $direction;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+"Shape.worldMatrix[0]") ($direction+"Shape.dagObjectMatrix[0]");
			//orientCnstraint last segment to controller
			createNode -n ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			createNode -n ("IKFKAligned"+$fitJointIK[$i]+$side) -p ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) transform;
			asAlign ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
			orientConstraint ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKEndJoint[$i]+$side);
			//$ikLocal
			if ($ikLocal[$i])
				{
				asCreateController "IKLocal" $fitJointIK[$i] $side $fitJoints[$i];
				asAlign ("IKLocalOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				asLockAttr ("IKLocal"+$fitJointIK[$i]+$side) 1 0 1 1;
				parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKLocal"+$fitJointIK[$i]+$side);
				}
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) IKHandle;
			string $crvCmd="curve -n IK"+$fitJointIK[$i]+"Curve"+$side+" -d 3";
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				 $crvCmd+=" -p 0 0 0";
			eval ($crvCmd);
			$tempString=`listRelatives -s ("IK"+$fitJointIK[$i]+"Curve"+$side)`;
			rename $tempString[0] ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
			parent ("IK"+$fitJointIK[$i]+"Curve"+$side) IKCurve;

			$ikControlNr=1;
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				{
				spaceLocator -n ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				setAttr -l 1 ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".v") 0;
				connectAttr ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

				float $posFactor=0;
				if ($z>1)
					$posFactor=($z-1)/($fitJointIKNumCtrls[$i]-1.0);
				if ($z>$fitJointIKNumCtrls[$i]-1)
				    $posFactor=1;
				float $invPosFactor=1-$posFactor;
				$tempString=`pointConstraint -w $invPosFactor ("IKSp"+$fitJointIKStartJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side)`;
				pointConstraint -w $posFactor ("IKSp"+$fitJointIKEndJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				delete $tempString[0];

				if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])//Controller for each loc except second and seconLast (they are for stiffness)
					{
					asCreateController "IK" ($fitJointIK[$i]+$ikControlNr) $side $fitJointIKStartJoint[$i];
					parent ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) IKRootConstraint;
					asAlign ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) 1 1 0 1;
					parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
					$rot=`xform -q -ws -ro ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
					xform -s 0.1 1 1 ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
					$ikControlNr++;
					}
				}
			//inbetween Ik Controllers to follow start & end (Spine only)
			if (`gmatch $fitJointIK[$i] "*Spine*"`)
				for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
					{
					float $weight=(1.0/($fitJointIKNumCtrls[$i]-1))*($z-1);
					parentConstraint -mo -w (1-$weight) ("IK"+$fitJointIK[$i]+"1"+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
					parentConstraint -mo -w $weight ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
					}
			//inbetween Ik Controllers: lock rotate
			for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
				{
				asLockAttr ("IK"+$fitJointIK[$i]+$z+$side) 0 1 0 1;
				asLockAttr ("IKExtra"+$fitJointIK[$i]+$z+$side) 0 1 0 1;
				}

			parent ("IK"+$fitJointIK[$i]+"Locator1"+$side) ("IK"+$fitJointIK[$i]+"1"+$side);
			parent ("IK"+$fitJointIK[$i]+"Locator"+$fitJointIKNumCtrls[$i]+$side) ("IK"+$fitJointIK[$i]+($ikControlNr-1)+$side);
			connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") ("IK"+$fitJointIK[$i]+"Handle"+$side+".inCurve");

			createNode -n ("IKCurveInfo"+$fitJointIK[$i]+$side) curveInfo;
			connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.worldSpace[0]") ("IKCurveInfo"+$fitJointIK[$i]+$side+".inputCurve");

			//if 1 Ik control, build 2, but expose 1
			if (`attributeExists ikCtrls $fitJointIKStartJoint[$i]`)
				if(`getAttr ($fitJointIKStartJoint[$i]+".ikCtrls")`==1)
					{
					sets -rm ControlSet ("IK"+$fitJointIK[$i]+"1"+$side) ("IKExtra"+$fitJointIK[$i]+"1"+$side);
					setAttr -l 1 ("IK"+$fitJointIK[$i]+"1"+$side+".v") 0;
					}

			//IK spline stretchy
			addAttr -k 1 -ln stretchy -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			createNode -n ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".operation") 2;
			createNode -n ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".operation") 2;
			connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".outputX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input1X");
			connectAttr ("Main.scaleX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input2X");
			connectAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength") ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input1X");
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input2X") `getAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength")`;
			createNode -n ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
			setAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stretchy") ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
			createNode -n ("stretchy"+$fitJointIK[$i]+"Reverse"+$side) reverse;
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".inputX");
			select `listRelatives -ad -type joint $startJoint`;
			select -d ("IKSp"+$fitJointIKEndJoint[$i]+$side);
			$tempString=`ls -sl`;
			for ($x=0;$x<size($tempString);$x++)
				{
				createNode -n ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side) multiplyDivide;
				setAttr ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".input1X") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".input2X");

				createNode -n ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side) blendTwoAttr;
				connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".attributesBlender");
				setAttr ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".input[0]") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".outputX") ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".input[1]");
				connectAttr ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".output") ($tempString[$x]+".translateX");
				}

			//IKFake (ChestOrientationLock)
			$tempString=`spaceLocator -n ("IKFake1UpLoc"+$fitJointIK[$i]+$side)`;
			$loc1=$tempString[0];
			asAlign $loc1 ("IKfake1"+$fitJointIK[$i]+$side) 1 1 0 0;
			parent $loc1 ("IKfake1"+$fitJointIK[$i]+$side);
			setAttr ($loc1+".translateY") 1;
			$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
			$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $loc1 ("IKfake2"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) $tempString[0]`;
			$constraint=$tempString[0];
			$attrs=`listAttr -k -ud $constraint`;
			connectAttr ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ($tempString[0]+"."+$attrs[0]);
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($tempString[0]+"."+$attrs[1]);


			createNode -n ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IK"+$fitJointIK[$i]+"1"+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IKfake2"+$fitJointIK[$i]+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IKfake2"+$fitJointIK[$i]+$side) 1 0 0 0;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side) 0 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side);

			parentConstraint ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side);

			//IK spline FixedEnd
			addAttr -k 1 -ln fixedEnd -at bool -dv 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side) -p ("IKSp"+$fitJointIKEndJoint[$i]+$side) transform;
			$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side) $tempString[0];
			parentConstraint ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side) blendColors;
			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side) blendColors;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side+".t") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side+".color1");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side+".r") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side+".color1");
			connectAttr ($tempString[0]+".t") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side+".color2");
			connectAttr ($tempString[0]+".r") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side+".color2");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side+".output") ("IKSp"+$fitJointIKEndJoint[$i]+$side+".t");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side+".output") ("IKSp"+$fitJointIKEndJoint[$i]+$side+".r");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".fixedEnd") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side+".blender");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".fixedEnd") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side+".blender");
			


			//IK spline Stiff
			$ikControlNr=1;
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				{
				if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])
					continue;
				if ($z==$fitJointIKNumCtrls[$i])
					$ikControlNr=$fitJointIKNumCtrls[$i];
				addAttr -k 1 -ln stiff -at double -min 0 -max 10 -dv 5 ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
				createNode -n ("IKStiff"+$fitJointIK[$i]+$z+$side) setRange;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".minX") 0.01;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".oldMinX") 0;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".oldMaxX") 10;
				connectAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".stiff") ("IKStiff"+$fitJointIK[$i]+$z+$side+".valueX");
				createNode -n ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) transform;
				if ($z==1)
					asAlign ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ($fitJointIKStartJoint[$i]+$side) 1 0 0 0;
				else
					asAlign ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ($fitJointIKEndJoint[$i]+$side) 1 0 0 0;
				string $aimAt=$fitJointIKEndJoint[$i]+$side;
				float $aimV[3]={1,0,0};
				if ($z==$fitJointIKNumCtrls[$i])
					$aimAt=$fitJointIKStartJoint[$i]+$side;
				$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($fitJointIKStartJoint[$i]+$side) $aimAt ("IKStiffOrient"+$fitJointIK[$i]+$z+$side)`;
				delete $tempString[0];
				parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IKStiffOrient"+$fitJointIK[$i]+$z+$side);
				parent ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".maxX") ($ikLenght[$i]/2.0);
				connectAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".outValueX") ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".translateX");

//				if ($fitJointIKNumCtrls[$i]<3)
//					setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".stiff") 10;
				}

			parentConstraint -mo ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side);
			asCreateUnTwister $fitJoints[$i] $side $fitJointIKStartJoint[$i] $side $fitJointIK[$i] $b 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo");
			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("IK"+$fitJointIK[$i]+"Handle"+$side+".twist");

			//IK spline Follow
			if ($fitJointIKSolver[$i]=="ikSplineSolver")
				{
				$ikControlNr=1;
				for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
					if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])//Controller for each loc except second and seconLast (they are for stiffness)
						{
						$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
						string $ikParent=$tempString[0];
						if ($ikParent!="DeformationSystem")
							asFollow ("IK"+$fitJointIK[$i]+$ikControlNr+$side) ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) $ikParent;
						$ikControlNr++;
						}
				}

			//Constraint to IKSp jointChain
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) -p ("IKSp"+$IKJoints[$y]+$side) transform;
				asAlign ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ($IKJoints[$y]+$side) 1 1 0 0;
				parentConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
				}
			}

		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//PoleAim (PoleLeg avoid flipping in the forward plane)
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				createNode -n ("PoleAim"+$fitJointIK[$i]+$side) transform;
				asAlign ("PoleAim"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 0;
//				if ($msLegAim[$i]!="")
//					asAlign ("PoleAim"+$fitJointIK[$i]+$side) ($msLegAim[$i]+$side) 1 0 0 0;
				$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side)`;
				$constraint=$tempString[0];
				parent ("PoleAim"+$fitJointIK[$i]+$side) ("IKHandle");
				pointConstraint Root_M ("PoleAim"+$fitJointIK[$i]+$side);
				}

			//Follow
			if (!`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
				string $ikParent=$tempString[0];
				asFollow ("IK"+$fitJointIK[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$side) $ikParent;
				}
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side);
			else
				asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
			}
		}


//Advanced FKIK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKStart[$i])
			continue;

		duplicate -n ("FKIK"+$fitJointIK[$i]+$side) "FKIK_icon";
		xform -ws -t 0 0 0 -ro 0 0 0 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".scale") $iconScaleFactor $iconScaleFactor $iconScaleFactor;
		setAttr ("FKIK"+$fitJointIK[$i]+$side+".rotateY") 90;
		makeIdentity -a 1 -t 1 -r 1 -s 1 ("FKIK"+$fitJointIK[$i]+$side);

		createNode -n ("FKIKParentConstraint"+$fitJointIK[$i]+$side) transform;
		$tempString=`listRelatives -p -type joint ($fitJointIKStartJoint[$i]+$side)`;
		string $parent=$tempString[0];
		if(`objExists $parent`)
			parentConstraint $parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		else
			parentConstraint ($fitJointIKStartJoint[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side) ("FKIKSystem");

		$sca=`xform -q -r -s $fitJointIKStartJoint[$i]`;
		$sca[0]*=$fitSkeletonScaleX;$sca[1]*=$fitSkeletonScaleX;$sca[2]*=$fitSkeletonScaleX;
		parent ("FKIK"+$fitJointIK[$i]+$side) ($fitJointIKStartJoint[$i]+$side);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".t") ($iconScaleFactor*$b*5) 0 ($iconScaleFactor*$b*5);
		//`fat` based side-distance
		if (`attributeExists fatZ $fitJoints[$i]`)
			{
			$pos=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[0]")`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[5]")`;
			$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`*$b;
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") ((`getAttr ($fitJoints[$i]+".fat")`*`getAttr ($fitJoints[$i]+".fatZ")`*$b)+($dist/2.0));
			}

		//ensure its moved to `outside` direction
		if ($side!="_M")
			{
			$pos=`xform -q -ws -t ($fitJointIKStartJoint[$i]+$side)`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side)`;
			if ($side=="_R" && $pos2[0]>$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			if ($side=="_L" && $pos2[0]<$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			}

		parent ("FKIK"+$fitJointIK[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		asLockAttr ("FKIK"+$fitJointIK[$i]+$side) 1 1 1 1;

		addAttr -k 1 -ln FKIKBlend -at double -min 0 -max 10 -dv 0 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln autoVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -k 0 -cb 1 ("FKIK"+$fitJointIK[$i]+$side+".autoVis");
		addAttr -k 1 -ln FKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln IKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -ln startJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".startJoint") $fitJointIKStartJoint[$i];
		addAttr -ln middleJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".middleJoint") $fitJointIKMiddleJoint[$i];
		addAttr -ln endJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".endJoint") $fitJointIKEndJoint[$i];

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side) reverse;
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".inputX");

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side) condition;
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side) setRange;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".minX") 10;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".oldMaxX") 10;

		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".autoVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".firstTerm");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".IKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueR");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueG");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".valueX");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseR");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".outValueX") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseG");


		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("PoleOffset"+$fitJointIK[$i]+$side+".visibility");
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			for ($z=1;$z<$fitJointIKNumCtrls[$i]+1;$z++)
				connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$z+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IK"+$fitJointIK[$i]+"Curve"+$side+".visibility");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideDisplayType") 1;
			}
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR")  ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side+".visibility");
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorG")  ("FKOffset"+$fitJointIKStartJoint[$i]+$side+".visibility");
		}


//FKIK connect to constraints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointIK[$i]!="")
			{
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX")       ($fitJoints[$i]+$side+"_parentConstraint1.FKX"+$fitJoints[$i]+$side+"W0");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($fitJoints[$i]+$side+"_parentConstraint1.IKX"+$fitJoints[$i]+$side+"W1");
			}
	}


//Advanced FootRoll
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!`gmatch $fitJointLabel[$i] "*Foot*"`)
			continue;

		//find $ankle,$heel,$toes,$toesEnd
		$ankle=$fitJoints[$i];
		$heel="";$toes="";$toesEnd="";$bigToe="";$pinkyToe="";
		$tempString=`listRelatives -ad -type joint $ankle`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			if (`gmatch $childLabel "*Toes*"` && !`gmatch $childLabel "*ToesEnd*"`)
				$toes=$tempString[$y];
			if (`gmatch $childLabel "*BigToe*"`)
				$bigToe=$tempString[$y];
			if (`gmatch $childLabel "*PinkyToe*"`)
				$pinkyToe=$tempString[$y];
			if (`gmatch $childLabel "*ToesEnd*"`)
				$toesEnd=$tempString[$y];
			}
		if ($heel=="" || $toes=="" || $toesEnd=="")
			continue;

		//create FootRoll IkJoints
		select ("IKX"+$ankle+$side);
		joint -n ("IKX"+$toes+$side);
		asAlign ("IKX"+$toes+$side) ($toes+$side) 1 1 1 0;
		joint -n ("IKX"+$toesEnd+$side);
		asAlign ("IKX"+$toesEnd+$side) ($toesEnd+$side) 1 1 1 0;
//		createNode -n ("FKIKBlend"+$toesEnd+$side) blendColors;
//		connectAttr ("FKX"+$fitJoints[$i]+$side+".r") ("FKIKBlend"+$toesEnd+$side+".color2");
//		connectAttr ("IKX"+$fitJoints[$i]+$side+".r") ("FKIKBlend"+$toesEnd+$side+".color1");
//		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKIKBlend"+$toesEnd+$side+".blender");

//		parentConstraint ("IKX"+$toes+$side) ($toes+$side);
//		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX")       ($toes+$side+"_parentConstraint1.FKX"+$toes+$side+"W0");
//		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($toes+$side+"_parentConstraint1.IKX"+$toes+$side+"W1");
		$tempString=`listRelatives -p ("FKExtra"+$toes+$side)`;
		createNode -n ("FKFootRollIK"+$toes+$side) -p $tempString[0] transform;
		asAlign ("FKFootRollIK"+$toes+$side) ("FKExtra"+$toes+$side) 1 1 0 1;
		duplicate -n ("FKFootRollIKStatic"+$toes+$side) ("FKFootRollIK"+$toes+$side);
		parent ("FKExtra"+$toes+$side) ("FKFootRollIK"+$toes+$side);
		orientConstraint ("IKX"+$toes+$side) ("FKFootRollIKStatic"+$toes+$side) ("FKFootRollIK"+$toes+$side);
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKFootRollIK"+$toes+$side+"_orientConstraint1.IKX"+$toes+$side+"W0");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ("FKFootRollIK"+$toes+$side+"_orientConstraint1.FKFootRollIKStatic"+$toes+$side+"W1");

		addAttr -k 1 -ln swivel -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln toe -at double ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln roll -at double -min -5 -max 10 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln rollAngle -at double -dv 25 ("IK"+$fitJointIK[$i]+$side);

		connectAttr ("IK"+$fitJointIK[$i]+$side+".swivel") ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX");
		$tempString=`listConnections ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX")`;
		setAttr ($tempString[0]+".conversionFactor") 0.1;

		createNode -n ("IK"+$fitJointIK[$i]+"FootRoll"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
		$temp=`xform -q -ws -t ($fitJointIKEndJoint[$i]+$side)`;
		xform -ws -t $temp[0] $temp[1] $temp[2] ("IK"+$fitJointIK[$i]+"FootRoll"+$side);
		setAttr ("IK"+$fitJointIK[$i]+"FootRoll"+$side+".ry") ($footRotX[$i]*$b);

		asCreateController "Roll" $toes $side $toes;
		asCreateController "Roll" $toesEnd $side $toesEnd;
		asCreateController "Roll" $heel $side $heel;

		setAttr ("RollOffset"+$heel+$side+".ry") ($footRotX[$i]*$b);
		setAttr ("RollOffset"+$toes+$side+".ry") ($footRotX[$i]*$b);
		setAttr ("RollOffset"+$toesEnd+$side+".ry") ($footRotX[$i]*$b);

		parent ("RollOffset"+$toes+$side) ("Roll"+$toesEnd+$side);
		parent ("RollOffset"+$toesEnd+$side) ("Roll"+$heel+$side);
		parent ("RollOffset"+$heel+$side) ("IK"+$fitJointIK[$i]+$side);

		//Pinky/index toe side2side rocking
		if (`objExists $toes`)
			{
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
//			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rotateOrder") 5;
			asAlign ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side) 1 1 0 0;
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $bigToe`)
				$pos=`xform -q -ws -t $bigToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side);
			duplicate -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $pinkyToe`)
				$pos=`xform -q -ws -t $pinkyToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side) clamp;
			if ($side=="_R")
				setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".minR") -200;
			else
				setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".maxR") 200;
			connectAttr ("Roll"+$toes+$side+".rz") ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rz");
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side) clamp;
			if ($side=="_R")
				setAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".maxR") 200;
			else
				setAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".minR") -200;
			connectAttr ("Roll"+$toes+$side+".rz") ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side+".rz");
			parent ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("RollOffset"+$heel+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			if (`objExists ("IKLocalOffset"+$fitJointIK[$i]+$side)`)
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);

			createNode -n ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side) -p ("Roll"+$toes+$side) transform;
			xform -os -t 0 0 0 -ro 0 0 0 ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockReverseMultiplyDivide"+$side) multiplyDivide;
			connectAttr ("Roll"+$toes+$side+".rz") ("IK"+$fitJointIK[$i]+"FootRockReverseMultiplyDivide"+$side+".input1Z");
			setAttr ("IK"+$fitJointIK[$i]+"FootRockReverseMultiplyDivide"+$side+".input2Z") -1;
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockReverseMultiplyDivide"+$side+".outputZ") ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side+".rz");
			}

		if ($ikLocal[$i])
			{
			createNode -n ("RollOffsetOffset"+$heel+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			asAlign ("RollOffsetOffset"+$heel+$side) ("RollOffset"+$heel+$side) 1 1 0 0;
			parent ("RollOffset"+$heel+$side) ("RollOffsetOffset"+$heel+$side);
			parent ("RollOffsetOffset"+$heel+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			}

		$tempString=`ikHandle -n ("IK"+$toes+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$fitJointIKEndJoint[$i]+$side) -ee ("IKX"+$toes+$side)`;
		rename $tempString[1] ("IK"+$toes+"Effector"+$side);
		parent ("IK"+$toes+"Handle"+$side) ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);
		setAttr -l 1 ("IK"+$toes+"Handle"+$side+".v") 0;

		$tempString=`ikHandle -n ("IK"+$toesEnd+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$toes+$side) -ee ("IKX"+$toesEnd+$side)`;
		rename $tempString[1] ("IK"+$toesEnd+"Effector"+$side);
		createNode -n ("IK"+$fitJointIK[$i]+"LiftToe"+$side) -p ("Roll"+$toesEnd+$side) transform;
		asAlign ("IK"+$fitJointIK[$i]+"LiftToe"+$side) ($toes+$side) 1 0 0 0;
		parent ("IK"+$toesEnd+"Handle"+$side) ("IK"+$fitJointIK[$i]+"LiftToe"+$side);
		setAttr -l 1 ("IK"+$toesEnd+"Handle"+$side+".v") 0;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".toe") ("IK"+$fitJointIK[$i]+"LiftToe"+$side+".rx");

		//move LegIKHandel to end of RollHierarchy
		parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);

		createNode -n ($fitJointIK[$i]+$side+"AngleReverse") multiplyDivide;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ($fitJointIK[$i]+$side+"AngleReverse.input1X");
		setAttr ($fitJointIK[$i]+$side+"AngleReverse.input2X") -1;

		createNode -n ("IKRollAngle"+$fitJointIK[$i]+$side) setRange;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueY");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueZ");
		connectAttr ($fitJointIK[$i]+$side+"AngleReverse.output.outputX") ("IKRollAngle"+$fitJointIK[$i]+$side+".minX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ("IKRollAngle"+$fitJointIK[$i]+$side+".maxY");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ("IKRollAngle"+$fitJointIK[$i]+$side+".maxZ");
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMinX") -5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMaxY") 5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMinZ") 5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMaxZ") 10;

		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueX") ("RollOffset"+$heel+$side+".rotateX");
		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueY") ("RollOffset"+$toes+$side+".rotateX");
		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueZ") ("RollOffset"+$toesEnd+$side+".rotateX");
		}
	if (`objExists deleteMe`)
		delete deleteMe;


//Advanced LegAim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKStart[$i])
			continue;
		$tempString=`listRelatives -p $fitJoints[$i]`;
		$scapula=$tempString[0];
		if ($scapula!="")
			{
			$tempString[0]=`asLabel $scapula`;
			if (!`gmatch $tempString[0] "*LegAim*"`)
				continue;
			}

		addAttr -k 1 -ln legAim -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
		$tempString=`listRelatives -p ("FKOffset"+$scapula+$side)`;
		$parent=$tempString[0];
		createNode -n ("LegAim"+$scapula+$side) -p $parent transform;
		asAlign ("LegAim"+$scapula+$side) ("FKOffset"+$scapula+$side) 1 1 0 0;
		duplicate -n ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
		duplicate -n ("LegAimOff"+$scapula+$side) ("LegAim"+$scapula+$side);

//		aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "object" -worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
		aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "object" -worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
		asAlign ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) 1 1 0 0;
		orientConstraint ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
		parent ("FKOffset"+$scapula+$side) ("LegAim"+$scapula+$side);

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side) unitConversion;
		setAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".legAim") ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".input");

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side) multiplyDivide;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input1X");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input2X");

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side) reverse;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".inputX");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOn"+$scapula+$side+"W1");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOff"+$scapula+$side+"W0");
		}

//Advanced Scaling
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

//		if ($fitJointIsEndJoint[$i])
//			continue;

		if ($fitJointIK[$i]!="")
			{
			createNode -n ("ScaleBlend"+$fitJoints[$i]+$side) blendColors;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color1") 1 1 1;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color2") 1 1 1;
			if (`objExists ("FK"+$fitJoints[$i]+$side)`)
				connectAttr ("FK"+$fitJoints[$i]+$side+".scale") ("ScaleBlend"+$fitJoints[$i]+$side+".color2");
			connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".output") ($fitJoints[$i]+$side+".scale");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("ScaleBlend"+$fitJoints[$i]+$side+".blender");
			}
		else if (`objExists ("FK"+$fitJoints[$i]+$side)`)
			connectAttr ("FK"+$fitJoints[$i]+$side+".scale") ($fitJoints[$i]+$side+".scale");
		}

for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

//		if ($fitJointIsEndJoint[$i])
//			continue;

		if ($fitJoints[$i]==$fitJointIKEndJoint[$i])
			{
			if ($fitJointIKSolver[$i]=="ikRPsolver")
				{
				connectAttr ("IK"+$fitJointIK[$i]+$side+".scale") ("ScaleBlend"+$fitJoints[$i]+$side+".color1");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".scale") ("IKX"+$fitJoints[$i]+$side+".scale");
				}
			if ($fitJointIKSolver[$i]=="ikSplineSolver")
				{
				$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;
				for ($y=0;$y<size($IKJoints);$y++)
					{
					createNode -n ("IKScaler"+$IKJoints[$y]+$side) -p IKHandle transform;
					createNode -n ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side) multiplyDivide;
					connectAttr ("IKScaler"+$IKJoints[$y]+$side+".scale") ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1");
					connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".output") ("ScaleBlend"+$IKJoints[$y]+$side+".color1");		
					for ($z=0;$z<$fitJointIKNumCtrls[$i];$z++)
						{
		        float $yy=(1.0/(size($IKJoints)-1))*$y;
		        float $zz=(1.0/($fitJointIKNumCtrls[$i]-1))*$z;
		        $weight=1-(abs($yy-$zz));
		        $weight=` smoothstep 0.5 1 $weight`;
						scaleConstraint -w $weight ("IK"+$fitJointIK[$i]+($z+1)+$side) ("IKScaler"+$IKJoints[$y]+$side);
						}
					float $scalerWeight=((1.0 / (`size($IKJoints)`+1))*($y+1))*2;
					if ($scalerWeight>1)
						$scalerWeight=1-($scalerWeight-1);
					addAttr -k 1 -ln scalerWeight -at double -dv $scalerWeight ("IKScaler"+$IKJoints[$y]+$side);
					}
				}
			}
		}

//Advanced Stretchy (arms/legs)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if ($fitJointIKSolver[$i]!="ikRPsolver")
			continue;
		if (`asIsMayaLT`)
			continue;

		addAttr -k 1 -ln stretchy -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln antiPop -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);

		createNode -n ("IKSetRangeStretch"+$fitJointIK[$i]+$side) setRange;
		createNode -n ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side) setRange;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".stretchy") ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".antiPop") ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".valueX");

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc1"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLoc1"+$fitJointIK[$i]+$side+".visibility") 0;
		pointConstraint ("IKX"+$fitJointIKStartJoint[$i]+$side)  ("IKmessureLoc1"+$fitJointIK[$i]+$side);
		parent ("IKmessureLoc1"+$fitJointIK[$i]+$side) ("IKMessure");
		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc2"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLoc2"+$fitJointIK[$i]+$side+".visibility") 0;
		asAlign ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 0 0 0;
		parent ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IKmessureLoc1"+$fitJointIK[$i]+$side);

		createNode -n ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) transform;
		asAlign ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 1 0 0;
		$tempString=`listRelatives -p ("IK"+$fitJointIK[$i]+"Handle"+$side)`;
		parent ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) $tempString[0];
		pointConstraint ("IKmessureConstrainTo"+$fitJointIK[$i]+$side)  ("IKmessureLoc2"+$fitJointIK[$i]+$side);

		createNode -n ("IKdistance"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistance"+$fitJointIK[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistance"+$fitJointIK[$i]+$side);
		parent ("IKdistance"+$fitJointIK[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistance"+$fitJointIK[$i]+$side+".visibility") 0;
		connectAttr ("IKmessureLoc2"+$fitJointIK[$i]+$side+".translate") ("IKdistance"+$fitJointIK[$i]+$side+".endPoint");
		createNode -n ("IKmessureDiv"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".operation") 2;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".input2X") $ikLenght[$i];

		$distance=`getAttr ("IKdistance"+$fitJointIK[$i]+$side+".distance")`;
		createNode -n ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".attributesBlender");
		addAttr -ln antiPop -at double ("IKdistance"+$fitJointIK[$i]+$side+"Shape");
		setDrivenKeyframe -itt "spline" -ott "linear" -v $ikLenght[$i] -dv $ikLenght[$i] -cd ("IKdistance"+$fitJointIK[$i]+$side+".distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.antiPop");
		setKeyframe -itt "spline" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.1) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*1.2) -f ($ikLenght[$i]*1.2) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "linear" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.70) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*0.9) -f ($ikLenght[$i]*0.85) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		selectKey ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setInfinity -poi linear;
		duplicate -n ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		cutKey -in 0 -in 1 -in 2 ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+".distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.input");

		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[1]");

		createNode -n ("IKdistanceClamp"+$fitJointIK[$i]+$side) clamp;
		setAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".maxR") $ikLenght[$i];
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKdistanceClamp"+$fitJointIK[$i]+$side+".inputR");
		createNode -n ("IKmessureBlendStretch"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".attributesBlender");
		connectAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".outputR") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[1]");
		connectAttr ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".output") ("IKmessureDiv"+$fitJointIK[$i]+$side+".input1X");

		addAttr -k 1 -ln lock -at double -min 0 -max 10 ("Pole"+$fitJointIK[$i]+$side);
		createNode -n ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("Pole"+$fitJointIK[$i]+$side+".lock") ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".input");

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			$temp[0]=`getAttr ($tempString[0]+".translateX")`;
			createNode -n ($tempString[0]+"_IKmessureDiv"+$side) multiplyDivide;
			setAttr ($tempString[0]+"_IKmessureDiv"+$side+".input2X") $temp[0];
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input1X");
//			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ($tempString[0]+".translateX");
			//IkLengtControl
			addAttr -k 1 -ln ("Lenght"+($a+1)) -at double -dv 1 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ($tempString[0]+"_IKLenght"+$side) multiplyDivide;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".Lenght"+($a+1)) ($tempString[0]+"_IKLenght"+$side+".input1X");
			setAttr ($tempString[0]+"_IKLenght"+$side+".input2X") $temp[0];
			connectAttr ($tempString[0]+"_IKLenght"+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input2X");

			//pole.lock
			createNode -n ("PoleLockBlender"+$tempString[0]) blendTwoAttr;
			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ("PoleLockBlender"+$tempString[0]+".input[0]");
			connectAttr ("PoleLockBlender"+$tempString[0]+".output") ($tempString[0]+".translateX");
			connectAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".output")  ("PoleLockBlender"+$tempString[0]+".attributesBlender");
			createNode -n ($tempString[0]+"Distance") distanceBetween;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix1");
			if ($a==0)
				connectAttr ("IKMessureFrom"+$fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			else
				connectAttr ("IK"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			createNode -n ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side) unitConversion;
			setAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".conversionFactor") $b;
//			connectAttr ($tempString[0]+"Distance.distance") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");
			//divide by Main.sy scale
			createNode -n ("PoleLockMainScaler"+$tempString[0]) multiplyDivide;
			setAttr ("PoleLockMainScaler"+$tempString[0]+".operation") 2;
			connectAttr ($tempString[0]+"Distance.distance") ("PoleLockMainScaler"+$tempString[0]+".input1X");
			connectAttr Main.sy ("PoleLockMainScaler"+$tempString[0]+".input2X");
			connectAttr ("PoleLockMainScaler"+$tempString[0]+".outputX") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");

			connectAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".output") ("PoleLockBlender"+$tempString[0]+".input[1]");;

			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}
		}


//Advanced Root
asCreateController "Root" "X" "_M" "Root";
xform -s 0.23 0.23 0.23 RootX_M;
setAttr RootX_M.rotateOrder 3;
makeIdentity -a 1 -s 1 RootX_M;
parent RootOffsetX_M RootSystem;
createNode -n RootZeroXform transform;
parent RootZeroXform RootX_M;
parentConstraint RootZeroXform FKSystem;
parentConstraint RootZeroXform IKRootConstraint;
//HipSwinger
int $buildHipSwinger=`objExists Spine1_M`;
if (`attributeExists inbetweenJoints Root`)
	$buildHipSwinger=0;
if ($buildHipSwinger)
	{
	createNode -n HipSwingerGroupRoot_M transform;
	string $spine1="Spine1";
	asAlign HipSwingerGroupRoot_M ($spine1+"_M") 1 1 0 1;
	duplicate -n HipSwingerStabalizeRoot_M HipSwingerGroupRoot_M;
	duplicate -n HipSwingerGroupOffsetRoot_M HipSwingerGroupRoot_M;
	parent HipSwingerGroupRoot_M HipSwingerGroupOffsetRoot_M;
	parent HipSwingerGroupOffsetRoot_M FKRoot_M;
	parent HipSwingerStabalizeRoot_M FKXRoot_M;
	orientConstraint FKRoot_M HipSwingerStabalizeRoot_M;
	parent FKXRoot_M HipSwingerGroupRoot_M;

	asCreateController "HipSwinger" "" "_M" $spine1;
	asAlign HipSwingerOffset_M HipSwingerGroupOffsetRoot_M 0 1 0 0;
	parent HipSwinger_M HipSwingerOffset_M;
	delete HipSwingerExtra_M;

	parent HipSwingerOffset_M FKRoot_M;
	parent ("FKOffset"+$spine1+"_M") HipSwingerStabalizeRoot_M;

	connectAttr HipSwinger_M.r HipSwingerGroupRoot_M.r;

	$pos=`xform -q -ws -t HipSwinger_M.cv[3]`;
	$pos2=`xform -q -ws -t HipSwinger_M.cv[7]`;
	$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
	$temp=`xform -q -ws -t HipSwinger_M`;
	float $hipSwingerHeight=$temp[1]/3.0;
	float $hipSwingerScale=$hipSwingerHeight/$dist;
	xform -ws -s $hipSwingerScale $hipSwingerScale $hipSwingerScale HipSwinger_M.cv[0:99];

	$pos=`xform -q -ws -t Root`;
//	xform -ws -t ($pos[0]+(`getAttr Root.sz`*$scale*-2)) ($pos[1]+(`getAttr Root.sz`*$scale)) $pos[2] HipSwingerOffset_M;
	delete `pointConstraint $spine1 Root_M HipSwingerOffset_M`;
	setAttr HipSwingerOffset_M.tz ($iconScaleFactor*-7.5);
	if (`attributeExists fatZ Root`)
		{
		$pos=`xform -q -ws -t HipSwinger_M.cv[3]`;
		$pos2=`xform -q -ws -t HipSwinger_M.cv[7]`;
		$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		setAttr HipSwingerOffset_M.translateZ ((`getAttr Root.fat`*`getAttr Root.fatZ`*-1)-$dist/4.0);
		}

	asLockAttr HipSwinger_M 1 0 1 0;
	}

//CenterBetweenFeet
string $ikLegs[];
$tempString=`ls "IKLeg*_*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im ControlSet $tempString[$i]`)
		$ikLegs[size($ikLegs)]=$tempString[$i];
if (size($ikLegs) && $centerBtwFeet)
	{
	createNode -n RootCenterBtwLegsBlended_M transform;
	asAlign RootCenterBtwLegsBlended_M Root_M 1 0 0 1;
	parent RootCenterBtwLegsBlended_M RootSystem;
	parent RootOffsetX_M RootCenterBtwLegsBlended_M;
	createNode -n RootCenterBtwLegsOffset_M -p RootSystem transform;
	asAlign RootCenterBtwLegsOffset_M Root_M 1 0 0 1;
	duplicate -n RootCenter_M RootCenterBtwLegsOffset_M;
	duplicate -n RootCenterBtwLegs_M RootCenterBtwLegsOffset_M;
	for ($i=0;$i<size($ikLegs);$i++)
		{
		pointConstraint -skip y $ikLegs[$i] RootCenterBtwLegs_M;
		orientConstraint -skip x -skip z $ikLegs[$i] RootCenterBtwLegs_M;
		}
	parent RootCenterBtwLegsOffset_M RootCenterBtwLegs_M;
	parentConstraint RootCenter_M RootCenterBtwLegsOffset_M RootCenterBtwLegsBlended_M;
	createNode -n CenterBtwLegsUnitConversion unitConversion;
	setAttr CenterBtwLegsUnitConversion.conversionFactor 0.1;
	addAttr -k 1 -ln CenterBtwFeet -at double -min 0 -max 10 RootX_M;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsUnitConversion.input;
	createNode -n CenterBtwLegsUnitReverse reverse;
	connectAttr CenterBtwLegsUnitConversion.output CenterBtwLegsUnitReverse.inputX;
	connectAttr CenterBtwLegsUnitConversion.output RootCenterBtwLegsBlended_M_parentConstraint1.RootCenterBtwLegsOffset_MW1;
	connectAttr CenterBtwLegsUnitReverse.outputX RootCenterBtwLegsBlended_M_parentConstraint1.RootCenter_MW0;
	createNode -n CenterBtwLegsNodeStateSetRange setRange;
	setAttr CenterBtwLegsNodeStateSetRange.minX 1;
	setAttr CenterBtwLegsNodeStateSetRange.oldMaxX 0.1;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsNodeStateSetRange.valueX;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_pointConstraint1.nodeState;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_orientConstraint1.nodeState;
	}
//Locking
asLockAttr FKRoot_M 1 0 0 0;
asLockAttr FKExtraRoot_M 1 0 0 0;
asLockAttr RootX_M 0 0 1 0;

//Advanced Twist
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointTwistJoints[$i])
			catchQuiet (`delete ($fitJoints[$i]+$side+"_parentConstraint1")`);
		else if (!$fitJointUpTwistJoints[$i])
			continue;refresh;

		asCreateUnTwister $fitJoints[$i] $side $fitJointParent[$i] $parentSide $fitJointIK[$i] $b 0 "";

		if ($fitJointTwistJoints[$i])
			{
			asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
			parent ($fitJoints[$i]+$side+"_pointConstraint1") ConstraintSystem;	
			}

		int $numTwisters=$fitJointTwistJoints[$i]+1;
		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			$numTwisters=$fitJointUpTwistJoints[$i]+1;
		for ($y=0;$y<$numTwisters;$y++)
			{
			createNode -n ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side) multiplyDivide;
			createNode -n ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side) plusMinusAverage;
			createNode -n ("Twister"+$fitJoints[$i]+$y+$side) -p ("UnTwist"+$fitJoints[$i]+$side) transform;

			if ($fitJointTwistJoints[$i])
				{
				if ($y==0)
					$joint=$fitJoints[$i]+$side;
				else
					$joint=$fitJoints[$i]+"Part"+$y+$side;
				addAttr -k 1 -ln twistAmount -at double -min 0 -max 1 $joint;
				addAttr -k 1 -ln twistAddition -at double $joint;
				setAttr ($joint+".twistAmount") ($y/($fitJointTwistJoints[$i]+1.0));
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2X");
				connectAttr ($joint+".twistAddition") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[1]");
				orientConstraint ("Twister"+$fitJoints[$i]+$y+$side) $joint;
				parent ($joint+"_orientConstraint1") ConstraintSystem;
				}

			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input1X");
			connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[0]");
			connectAttr ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".output1D") ("Twister"+$fitJoints[$i]+$y+$side+".rotateX");
			}
		}

//Advanced Twist ($fitJointUpTwistJoints)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			for ($y=0;$y<$fitJointUpTwistJoints[$i]+1;$y++)
				{
				if ($y==0)
					$joint=$fitJointParent[$i]+$parentSide;
				else
					$joint=$fitJointParent[$i]+"Part"+$y+$parentSide;
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2X");
				connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1D[2]");
//				connectAttr -f ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("twistAmountDivide"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1X");
				}
		}

//Advanced BendyJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if (!$fitJointBendyJoints[$i])
			continue;

		string $crvCmd="curve -n Bend"+$fitJoints[$i]+"Curve"+$side+" -d 3";
		for ($z=0;$z<5;$z++)
			 $crvCmd+=" -p 0 0 0";
		eval ($crvCmd);
		$tempString=`listRelatives -s ("Bend"+$fitJoints[$i]+"Curve"+$side)`;
		rename $tempString[0] ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape");
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
		parent ("Bend"+$fitJoints[$i]+"Curve"+$side) BendSystem;

		createNode -n ("BendParentConstraint"+$fitJoints[$i]+$side) -p BendSystem transform;
		asConstraintToFKIK "parent" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
		asConstraintToFKIK "scale" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);

		createNode -n ("BendParentConstraintOffset"+$fitJoints[$i]+$side) -p BendSystem transform;
		asAlign ("BendParentConstraintOffset"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side) 1 1 0 0;
		parent ("BendParentConstraint"+$fitJoints[$i]+$side) ("BendParentConstraintOffset"+$fitJoints[$i]+$side);

		$bendControlNr=1;
		for ($z=0;$z<5;$z++)
			{
			spaceLocator -n ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);
			setAttr -l 1 ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+".v") 0;
			connectAttr ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

			float $posFactor=(1.0/4.0)*$z;

			float $invPosFactor=1-$posFactor;
			$tempString=`pointConstraint -w $invPosFactor ($fitJoints[$i]+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side)`;
			pointConstraint -w $posFactor ($fitJointChild[$i]+$childSide) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);
			delete $tempString[0];

			if ($z==0)//Start
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			if ($z==2 || $z==0)//Controllers
				{
				asCreateController "Bend" ($fitJoints[$i]+$bendControlNr) $side $fitJoints[$i];
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) BendSystem;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) 1 0 0 0;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("FK"+$fitJoints[$i]+$side) 0 1 0 0;
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("Bend"+$fitJoints[$i]+$bendControlNr+$side);
				$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
				xform -s 0.1 1 1 ("Bend"+$fitJoints[$i]+$bendControlNr+$side+".cv[0:99]");
				$bendControlNr++;
				}
			if ($z==0)//Create BendStiff node
				{
				createNode -n ("BendStiff"+$fitJoints[$i]+$side) setRange;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".minX") 0;setAttr ("BendStiff"+$fitJoints[$i]+$side+".minY") 1;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".maxX") 1;setAttr ("BendStiff"+$fitJoints[$i]+$side+".maxY") 0;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMinX") -10;setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMinY") -10;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMaxX") 10;setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMaxY") 10;
				}
			if ($z==2)//`Bezier handles`(stiffness)
				{
				addAttr -k 1 -ln stiff -at double -min -10 -max 10 -dv 0 ("Bend"+$fitJoints[$i]+"2"+$side);
				connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".stiff") ("BendStiff"+$fitJoints[$i]+$side+".valueX");
				}

			if ($z==1 || $z==3)//`Bezier handles`(stiffness)
				{
				createNode -n ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) -p ("BendParentConstraint"+$fitJoints[$i]+$side) transform;
				if ($z==1)
					parent ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"1"+$side);
				if ($z==3 && `objExists ("Bend"+$fitJointParent[$i]+"BezOff"+$z+$side)` && `objExists ("Bend"+$fitJoints[$i]+"1"+$side)`)
					{
					createNode -n ("Bend"+$fitJointParent[$i]+"BezOffOffset"+$z+$side) -p ("BendParentConstraint"+$fitJoints[$i]+$side) transform;
					pointConstraint ("Bend"+$fitJoints[$i]+"1"+$side) ("Bend"+$fitJointParent[$i]+"2"+$parentSide) ("Bend"+$fitJointParent[$i]+"BezOffOffset"+$z+$side);
					parent ("Bend"+$fitJointParent[$i]+"BezOff"+$z+$side) ("Bend"+$fitJointParent[$i]+"BezOffOffset"+$z+$side);
					}

				asAlign ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) 1 1 0 0;
				duplicate -n ("Bend"+$fitJoints[$i]+"BezOn"+$z+$side) ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side);
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				pointConstraint ("Bend"+$fitJoints[$i]+"BezOn"+$z+$side) ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);

				connectAttr ("BendStiff"+$fitJoints[$i]+$side+".outValueX") ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$fitJoints[$i]+"BezOn"+$z+$side+"W0");
				connectAttr ("BendStiff"+$fitJoints[$i]+$side+".outValueY") ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$fitJoints[$i]+"BezOff"+$z+$side+"W1");

				}
			if ($z==4)
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			if ($z==3)
				{
				parent ("Bend"+$fitJoints[$i]+"BezOn"+"1"+$side) ("Bend"+$fitJoints[$i]+"2"+$side);
				parent ("Bend"+$fitJoints[$i]+"BezOn"+"3"+$side) ("Bend"+$fitJoints[$i]+"2"+$side);
				}
			}

		//connect to twistJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{

			if ($y==0)
				$joint=$fitJoints[$i]+$side;
			else
				{
				$joint=$fitJoints[$i]+"Part"+$y+$side;
				delete ($joint+"_orientConstraint1");
				}
			if ($y==0)
				delete (`listConnections -s 1 -d 0 ($fitJoints[$i]+$side+".tx")`);//could be point or parent constraint

			//bend hookup
			if ($y==0)
				{
				pointConstraint ("Bend"+$fitJoints[$i]+"1"+$side) $joint;				
				parent ($joint+"_pointConstraint1") ConstraintSystem;			
				}
			else
				{
				createNode -n ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side) pointOnCurveInfo;
				connectAttr -f ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.worldSpace[0]") ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".inputCurve");
				createNode -p BendSystem -n ($fitJoints[$i]+"PointOnCurveXform"+$y+$side) transform;
				connectAttr -f ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".position") ($fitJoints[$i]+"PointOnCurveXform"+$y+$side+".t");
//				setAttr ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".turnOnPercentage") 1;
				//make tempSurface, so a closestPointOnSurface node can find $parameter
				extrude -n tempSurface -ch true -rn false -po 0 -et 0 -upn 1 -length 1 -rotation 0 -scale 1 -dl 3 ("Bend"+$fitJoints[$i]+"Curve"+$side);
				createNode -n tempClosestPointOnSurface closestPointOnSurface;
				spaceLocator -n tempClosestPointOnSurfaceLoc;
				connectAttr tempSurface.worldSpace[0] tempClosestPointOnSurface.inputSurface;
				connectAttr tempClosestPointOnSurfaceLoc.worldPosition[0] tempClosestPointOnSurface.inPosition;
				pointConstraint ($fitJoints[$i]+$side) ($fitJointChild[$i]+$childSide) tempClosestPointOnSurfaceLoc;
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$fitJoints[$i]+$side+"W0") (1-((1.0/($fitJointTwistJoints[$i]+1.0))*$y));
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$fitJointChild[$i]+$childSide+"W1")((1.0/($fitJointTwistJoints[$i]+1.0))*$y);
				float $parameter=`getAttr tempClosestPointOnSurface.parameterU`;
				delete tempClosestPointOnSurface tempSurface tempClosestPointOnSurfaceLoc;
				setAttr ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".parameter") $parameter;

				pointConstraint ($fitJoints[$i]+"PointOnCurveXform"+$y+$side) $joint;
				parent ($joint+"_pointConstraint1") ConstraintSystem;	
				tangentConstraint -weight 1 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("Twister"+$fitJoints[$i]+$y+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side) $joint;
				parent ($joint+"_tangentConstraint1") ConstraintSystem;
				}
			}
		}

//Advanced BendyJoints (attached to parent)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpBendyJoints[$i])
			{
			if (!$fitJointBendyJoints[$i])//e.g. wrist
				asConstraintToFKIK "parent" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide);
			if ($fitJointBendyJoints[$i])//e.g. elbow
				parent ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide) ("Bend"+$fitJoints[$i]+"1"+$side);
			}

		//twisty BendyJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			if (!$fitJointBendyJoints[$i])
				continue;
			//startTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1X");
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2X") (1-(1/($fitJointTwistJoints[$i]+0.00))*$y);
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[3]");
			//midTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"2"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Y");
			float $hf=(1.0/$fitJointTwistJoints[$i])*$y*2;
			if ($y>$fitJointTwistJoints[$i]/2) $hf=2-$hf;
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Y") $hf;
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputY") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[4]");
			//endTwister
			if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx")`)
				{
				connectAttr ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Z");
				setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Z") ((1/($fitJointTwistJoints[$i]+0.00))*$y);
				connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputZ") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[5]");
				}
			}
		}

//Advanced distribution of twistJoints (non-BendyJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointTwistJoints[$i])
			continue;

		//Seem to work.Nope, makes foot unasable with stretchy leg
//		setAttr ($fitJoints[$i]+"Part"+"1"+$side+".segmentScaleCompensate") 0;

		//if there`s no ("FKX"+$fitJointChild[$i]+$childSide), the skip Advanced distribution
		if (!`objExists ("FKX"+$fitJointChild[$i]+$childSide)`)
			continue;

		string $contraintTo="FKX"+$fitJointChild[$i]+$childSide;
		if ($fitJointIK[$i]!="")
			{
			$contraintTo=("FKIKMix"+$fitJointChild[$i]+$childSide);
			createNode -n $contraintTo -p TwistSystem transform;
			if (`objExists $contraintTo`)
				asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJointChild[$i]+$childSide) ("IKX"+$fitJointChild[$i]+$childSide) $contraintTo;
			}

		if (!$fitJointBendyJoints[$i] && `objExists $contraintTo`)
			{
			for ($y=1;$y<$fitJointTwistJoints[$i]+1;$y++)
				{
				$tempString=`pointConstraint $contraintTo ($fitJoints[$i]+$side) ($fitJoints[$i]+"Part"+$y+$side)`;
				$constraint=$tempString[0];
				parent $constraint ConstraintSystem;
				setAttr ($constraint+"."+$contraintTo+"W0") ($y/($fitJointTwistJoints[$i]+1.0));
				setAttr ($constraint+"."+$fitJoints[$i]+$side+"W1") (1-($y/($fitJointTwistJoints[$i]+1.0)));
				}
			}
		}


//volume (Squash Scaling) - `IK setup` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if (`asIsMayaLT`)
			continue;

		$ikHandle = ("IK"+$fitJointIK[$i]+$side);
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			$ikHandle = ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $ikHandle;
		createNode -n ("volume"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ($ikHandle+".volume") ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("multWithStretchy"+$fitJointIK[$i]+$side) multiplyDivide;
		connectAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input1X");
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input2X");
		createNode -n ("volume1Over"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".operation") 2;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");
		else
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");			
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".input1X") 1;
		createNode -n ("volumepow"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".operation") 3;
		connectAttr ("volume1Over"+$fitJointIK[$i]+$side+".outputX") ("volumepow"+$fitJointIK[$i]+$side+".input1X");
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".input2X") 0.5;
		createNode -n ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side) blendTwoAttr;
		connectAttr ("multWithStretchy"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".attributesBlender");
		setAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[0]") 1;
		connectAttr ("volumepow"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[1]");
		}

//volume (Squash Scaling) - `Connect to scale` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJoints[$i]=="Root")
			continue;
		if ($isIKEnd[$i])
			continue;

		if (`asIsMayaLT`)
			continue;

		string $volumeOutPlug="volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output";
		if (`objExists ("IKScaler"+$fitJoints[$i]+$side)`)
			{
			createNode -n ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side) plusMinusAverage;
			createNode -n ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side) plusMinusAverage;
			connectAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output") ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[0]");
			setAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[1]") -1;
			setAttr ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[1]") 1;

			createNode -n ("IKSquashDistributer"+$fitJoints[$i]+$side) multiplyDivide;
			connectAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".output1D") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input1X");
			connectAttr ("IKScaler"+$fitJoints[$i]+$side+".scalerWeight") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input2X");

			connectAttr ("IKSquashDistributer"+$fitJoints[$i]+$side+".outputX") ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[0]");
			$volumeOutPlug="IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".output1D";
			}

		if (`objExists ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side)`)//splineIkScaling
			{
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Y");
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Z");
			}
		else
			{
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1.color1G");
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1.color1B");
			}
		}

//Advanced Attach
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointsAttachTo[$i]=="")
			continue;

		if (`objExists closestSampler`)
			delete closestSampler;
		createNode -n closestSampler closestPointOnMesh;
		connectAttr -f ($fitJointsAttachTo[$i]+".outMesh") closestSampler.inMesh;
		float $temp[]=`xform -q -ws -t $fitJoints[$i]`;
		setAttr closestSampler.inPosition ($temp[0]*$b) $temp[1] $temp[2];
		int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
		delete closestSampler;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		string $offsetParent=$tempString[0];
		createNode -n ("FKAttach"+$fitJoints[$i]+$side) transform;
		createNode -n ("FKAttachOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAttachOffset"+$fitJoints[$i]+$side) $offsetParent 1 1 0 0;
		select -r ($fitJointsAttachTo[$i]+".f["+$closestFaceIndex+"]");
		select -add ("FKAttach"+$fitJoints[$i]+$side);
		doCreatePointOnPolyConstraintArgList 1 { "0","0","0","1","","1" };
//		cMuscleSurfAttachSetup();
//		$tempString=`listRelatives -c grpSurfAttachRIG`;
//		rename $tempString[`size($tempString)`-1] ("FKAttach"+$fitJoints[$i]+$side);
//		setAttr ("FKAttach"+$fitJoints[$i]+$side+"Shape.v") 0;
		parent ("FKAttach"+$fitJoints[$i]+$side) $offsetParent;
//		$tempString=`listRelatives -c grpSurfAttachRIG`;
//		if (!size($tempString))
//			delete grpSurfAttachRIG;
		parent ("FKAttachOffset"+$fitJoints[$i]+$side) ("FKAttach"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAttachOffset"+$fitJoints[$i]+$side);
		}

//Advanced Wheel
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointsWheel[$i])
			continue;

		if (!`objExists WheelSystem`)
			{
			createNode -n WheelSystem -p MotionSystem transform;
			setAttr -l 1 WheelSystem.inheritsTransform 0;
			}

		xform -os -t 0 -0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[0]");
		xform -os -t 0 0 -1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[1]");
		xform -os -t 0 0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[2]");
		xform -os -t 0 1.108194 0  ("FK"+$fitJoints[$i]+$side+"Shape.cv[3]");
		xform -os -t 0 0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[4]");
		xform -os -t 0 0 1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[5]");
		xform -os -t 0 -0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[6]");
		xform -os -t 0 -1.108194 0 ("FK"+$fitJoints[$i]+$side+"Shape.cv[7]");

		$temp=`xform -q -ws -t $fitJoints[$i]`;
		float $diameter=$temp[1]*2;
//		float $scaleFactor= $diameter * 1.1054;// 1.1054->nurbs
		float $scaleFactor=$diameter/2.0;
		xform -ws -s $scaleFactor $scaleFactor $scaleFactor ("FK"+$fitJoints[$i]+$side+"Shape.cv[0:999]");
		addAttr -k 1 -ln "diameter" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 1 -ln "autoRoll" -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 1 ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosX" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosY" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosZ" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);

		createNode -n ("prevPosOffset"+$fitJoints[$i]+$side) -p WheelSystem transform;
		createNode -n ("prevPos"+$fitJoints[$i]+$side) -p ("prevPosOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("prevPosAngler"+$fitJoints[$i]+$side) -p ("prevPos"+$fitJoints[$i]+$side) transform;
		createNode -n ("nowPos"+$fitJoints[$i]+$side) -p WheelSystem transform;
		pointConstraint ("FK"+$fitJoints[$i]+$side) ("nowPos"+$fitJoints[$i]+$side);
		asAlign ("prevPosOffset"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side) 1 0 0 0;
		$temp=`xform -q -ws -ro ("FK"+$fitJoints[$i]+$side)`;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rz") 90;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rx") $temp[1];
		duplicate -n ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		parent ("prevPosSteer"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side);
		orientConstraint ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "vector" -worldUpVector 0 1 0 ("FK"+$fitJoints[$i]+$side) ("prevPos"+$fitJoints[$i]+$side);


		string $exp="";
		$exp+="float $diameter = FK"+$fitJoints[$i]+$side+".diameter;\n";
		$exp+="float $autoRoll = FK"+$fitJoints[$i]+$side+".autoRoll;\n";
		$exp+="float $sideAngle=prevPosAngler"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $prevPosX=FK"+$fitJoints[$i]+$side+".prevPosX;\n";
		$exp+="float $prevPosY=FK"+$fitJoints[$i]+$side+".prevPosY;\n";
		$exp+="float $prevPosZ=FK"+$fitJoints[$i]+$side+".prevPosZ;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateX=$prevPosX;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateY=$prevPosY;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateZ=$prevPosZ;\n";
		$exp+="float $nowPosX=nowPos"+$fitJoints[$i]+$side+".translateX;\n";
		$exp+="float $nowPosY=nowPos"+$fitJoints[$i]+$side+".translateY;\n";
		$exp+="float $nowPosZ=nowPos"+$fitJoints[$i]+$side+".translateZ;\n";
		$exp+="float $distance=`mag<<$nowPosX-$prevPosX,$nowPosY-$prevPosY,$nowPosZ-$prevPosZ>>`;\n";
		$exp+="float $curRotX=FKX"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $piD = 3.14 * $diameter;\n";
		$exp+="FKX"+$fitJoints[$i]+$side+".rotateX=$curRotX+($distance/$piD)*360 * $autoRoll * "+($b*-1)+" * sin(deg_to_rad($sideAngle));\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosX=$nowPosX;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosY=$nowPosY;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosZ=$nowPosZ;\n";

		expression -n ($fitJoints[$i]+"WheelExpression"+$side) -s $exp -o ("FKX"+$fitJoints[$i]+$side) -ae 1 -uc all ;

		}


connectAttr -f jointLayer.drawInfo FKOffsetRoot_M.drawOverride;

//Custom controller shapes
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
		$sca=`xform -q -r -s $fitJoints[$i]`;

		//Head 
		if (`gmatch $fitJoints[$i] "*Head*"` && $fitJointChild[$i]!="")
			{
			$pos2=`xform -q -ws -t $fitJointChild[$i]`;
			xform -r -s 2 2 2 ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			xform -r -ws -t ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
//			xform -s (1/$sca[0]) (1/$sca[1]) (1/$sca[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");//restore uniform scale first
//			float $frontAxisScale=`getAttr ($fitJoints[$i]+".s"+$U)`;
//			xform -s $frontAxisScale $frontAxisScale $frontAxisScale ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			}
		//IKLegs
		if (`gmatch $fitJointLabel[$i] "*Foot*"` && `objExists ("IK"+$fitJointIK[$i]+$side)`)
			{
			//First find $toesEnd
			$toesEnd="";
			$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
			for ($y=0;$y<size($tempString);$y++)
				{
				$childLabel=`asLabel $tempString[$y]`;
				if (`gmatch $childLabel "*ToesEnd*"`)
					$toesEnd=$tempString[$y];
				}
			int $numCVs=`getAttr ("IK"+$fitJointIK[$i]+$side+".spans")`+`getAttr ("IK"+$fitJointIK[$i]+$side+".degree")`;
			if ($toesEnd!="")
				for ($y=0;$y<$numCVs;$y++)
					{
					$temp=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]")`;
					$temp2=`xform -q -ws -t ("IKX"+$fitJoints[$i]+$side)`;
					$temp3=`xform -q -ws -t ($toesEnd+$side)`;
					if ($temp[1]<$temp2[1])
						{
						xform -ws -t $temp[0] 0 $temp[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						if ($temp[2]>$temp2[2])
							xform -ws -t $temp[0] 0 $temp3[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						}
					}
			$temp=`xform -q -ws -t ($fitJoints[$i]+$side)`;
			rotate -r -p $temp[0] $temp[1] $temp[2] -ws 0 ($footRotX[$i]*$b) 0 ("IK"+$fitJointIK[$i]+$side+".cv[0:99]");
			}
		}

//Default System values
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		if (`gmatch $fitJointLabel[$i] "*Foot*"`)
			{
			//Legs in IK
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") 10;
			//Legs have pole follow
			setAttr ("Pole"+$fitJointIK[$i]+$side+".follow") 10;
			}
		if (`gmatch $fitJointIK[$i] "*Spline*"`)
			{
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".fixedEnd") 0;
			//IK tail stiffness, start = 5 & end= 0, and follow=10 for first
			setAttr ("IK"+$fitJointIK[$i]+"1"+$side+".stiff") 5;
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stiff") 0;
			if (`attributeExists follow ("IK"+$fitJointIK[$i]+"1"+$side)`)
				setAttr ("IK"+$fitJointIK[$i]+"1"+$side+".follow") 10;
			}
		}

delete "iconsGroup";

//delete $fitJointNonDef
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointNonDef[$i])
			delete ($fitJoints[$i]+$side);
		}

//Remove tempInbetweeners
for ($i=0;$i<size($fitJoints);$i++)
	if (`attributeExists tempInbetweener $fitJoints[$i]`)
		{
		$tempString=`listRelatives -c $fitJoints[$i]`;
		$tempString2=`listRelatives -p $fitJoints[$i]`;
		parent $tempString[0] $tempString2[0];
		delete $fitJoints[$i];
		}

//buildPose
createNode -n "buildPose" dagPose;
select `sets -q ("ControlSet")`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	int $kT=0;
	int $kR=0;
	int $kS=0;
	if (`getAttr -k ($controlSetMembers[$i]+".tx")`) $kT=1;
	if (`getAttr -k ($controlSetMembers[$i]+".rx")`) $kR=1;
	if (`getAttr -k ($controlSetMembers[$i]+".sx")`) $kS=1;
	if ($kT || $kR || $kS)
		$setAttrCmd+="xform -os ";
	if ($kT)
		{
		$temp=`xform -q -os -t $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-t "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kR)
		{
		$temp=`xform -q -os -ro $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-ro "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kS)
		{
		$temp=`xform -q -r -os -s $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-s "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kT || $kR || $kS)
		$setAttrCmd+=$controlSetMembers[$i]+";";
	$tempString=`listAttr -k -shortNames -ud $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
if (!`attributeExists udAttr buildPose`)
	addAttr -ln udAttr -dt "string"  buildPose;
setAttr -type "string" buildPose.udAttr $setAttrCmd;

//Ensure mirrored controls
//asMirrorControlCurves 0 ControlSet;

//drivingSystems
$userAttrs=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	{
	if (!`gmatch $userAttrs[$i] "drivingSystem_*"`)
		continue;
	string $ds=`substitute "drivingSystem_" $userAttrs[$i] ""`;
	int $numChar=size($ds);
	string $dsObjName=`substring $ds 1 ($numChar-2)`;
	string $dsSide=`substring $ds ($numChar-1) 99`;
	string $sdks[]=`listConnections ("FitSkeleton."+$userAttrs[$i])`;
	string $sdkPlugs[]=`listConnections -p 1 ("FitSkeleton."+$userAttrs[$i])`;
//	$sdks=`sort $sdks`;
//	$sdkPlugs=`sort $sdkPlugs`;
	for ($y=0;$y<size($sdks);$y++)
		{
		tokenize $sdkPlugs[$y] "." $tempString;
		string $dsAttrName=$tempString[1];

		tokenize $sdks[$y] "_" $tempString;
		string $drivenObj=`substring $tempString[0] 5 99`+"_"+$tempString[1];
		if (!`objExists $drivenObj`)
			continue;
		string $drivenAttr=$tempString[2];
		if (`gmatch $drivenAttr "*[0-9]"`)
			{
			$numChar=size($drivenAttr);
			$drivenAttr=`substring $drivenAttr 1 ($numChar-1)`;
			}

		string $controllerName=$dsObjName+$dsSide;
		if (!`objExists $controllerName`)
			asCreateDrivingSystemController $controllerName {$drivenObj};
		string $sdkXform=`asCreateSDKXform $drivenObj`;
		if (`attributeExists $drivenAttr $sdkXform`)
			connectAttr -f ($sdks[$y]+".output") ($sdkXform+"."+$drivenAttr);
		else
			warning ("failed: connectAttr -f "+$sdks[$y]+".output "+$sdkXform+"."+$drivenAttr+";");
		if (!`attributeExists $dsAttrName $ds`)
			{
			string $addAttrCmd="addAttr -k 1 -ln "+$dsAttrName+" -at \"float\"  ";
			if (`addAttr -q -hasMinValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasMaxValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMinValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMaxValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($sdks[$y]+"."+$dsAttrName)`+" ";
			$addAttrCmd+=$ds;
			eval ($addAttrCmd);
			setAttr -type "string" buildPose.udAttr (`getAttr buildPose.udAttr`+";setAttr "+$ds+"."+$dsAttrName+" 0;");
			}
		if (`attributeExists $dsAttrName $ds`)
			connectAttr -f ($ds+"."+$dsAttrName) ($sdks[$y]+".input");
		}
	}
asOptimizeDrivingSystemControllers;

//Run
if (`attributeExists "run" FitSkeleton`)
	{
	string $run=`getAttr FitSkeleton.run`;
	catch (`eval ($run)`);
	}

//version
addAttr -ln version -at double Main;
setAttr -l 1 Main.version `asGetScriptVersion`;

//Allset
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;
select $allAfter;
select -d $allSame;
select -ne -d "Sets" "Geometry";
select -d `ls -type ikSolver -type ikSystem`;
sets -add AllSet `ls -sl`;
select -cl;
sets -rm AllSet `listRelatives -ad FitSkeleton`;
asUpdateButtonEnables;
print "// Build Complete\n";
}
